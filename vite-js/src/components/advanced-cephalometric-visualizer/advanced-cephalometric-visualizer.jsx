/**
 * Advanced Cephalometric Visualizer
 * 
 * Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§:
 * - Drag & Drop Ù†Ù‚Ø§Ø·
 * - Ø§ÙÚ©Øª Hover Ø¨Ø§ Scale
 * - ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ Ùˆ Ø¶Ø®Ø§Ù…Øª Ø®Ø·ÙˆØ·
 * - Ø§ÙØ²ÙˆØ¯Ù† Ùˆ Ø­Ø°Ù Ù†Ù‚Ø§Ø·
 * - Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§
 * - Tracing Ø³Ø§Ø®ØªØ§Ø±Ù‡Ø§ (molar, incisor)
 */

import PropTypes from 'prop-types';
import React, { useRef, useMemo, useState, useEffect, useCallback, useLayoutEffect } from 'react';

import Box from '@mui/material/Box';
import Card from '@mui/material/Card';
import Menu from '@mui/material/Menu';
import Grow from '@mui/material/Grow';
import Stack from '@mui/material/Stack';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import Portal from '@mui/material/Portal';
import Divider from '@mui/material/Divider';
import Popover from '@mui/material/Popover';
import Tooltip from '@mui/material/Tooltip';
import MenuItem from '@mui/material/MenuItem';
import Snackbar from '@mui/material/Snackbar';
import TextField from '@mui/material/TextField';
import { useTheme } from '@mui/material/styles';
import IconButton from '@mui/material/IconButton';
import Typography from '@mui/material/Typography';
import DialogTitle from '@mui/material/DialogTitle';
import CardContent from '@mui/material/CardContent';
import useMediaQuery from '@mui/material/useMediaQuery';
import DialogContent from '@mui/material/DialogContent';
import DialogActions from '@mui/material/DialogActions';

import { Iconify } from '../iconify';
import { ColorPicker } from '../color-utils';

// ----------------------------------------------------------------------

// Custom Zoom Transition for Snackbar with proper enter/exit animations
// This ensures both enter and exit animations work correctly
const ZoomTransition = React.forwardRef((props, ref) => {
  const { children, in: inProp, timeout = { enter: 300, exit: 300 }, ...other } = props;
  
  return (
    <Grow
      ref={ref}
      in={inProp}
      timeout={timeout}
      {...other}
      style={{
        transformOrigin: 'center center',
      }}
    >
      {children}
    </Grow>
  );
});
ZoomTransition.displayName = 'ZoomTransition';

// ----------------------------------------------------------------------


// ----------------------------------------------------------------------

// Object Ù…Ø±Ú©Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ (Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ ØªÚ©Ø±Ø§Ø± Ú©Ø¯)
const LANDMARK_VARIATIONS = {
  S: ['S', 's', 'Sella', 'sella'],
  N: ['N', 'n', 'Nasion', 'nasion'],
  A: ['A', 'a', 'Point A'],
  B: ['B', 'b', 'Point B'],
  Pog: ['Pog', 'pog', 'POG', 'pogonion', 'Pogonion'],
  'Pog\'': ['Pogâ€²', 'Pog\'', 'pogâ€²', 'pog\'', 'Soft tissue Pogonion', 'soft tissue pogonion'],
  'Pog`': ['Pog`', 'pog`', 'Pog`', 'pog`', 'Soft tissue Pogonion', 'soft tissue pogonion'],
  Go: ['Go', 'go', 'GO', 'gonion', 'Gonion'],
  Me: ['Me', 'me', 'ME', 'menton', 'Menton'],
  'Me\'': ['Meâ€²', 'Me\'', 'meâ€²', 'me\'', 'Soft tissue Menton', 'soft tissue menton'],
  'Me`': ['Me`', 'me`', 'Me`', 'me`', 'Soft tissue Menton', 'soft tissue menton'],
  Or: ['Or', 'or', 'OR', 'orbitale', 'Orbitale'],
  Po: ['Po', 'po', 'PO', 'porion', 'Porion'],
  Ar: ['Ar', 'ar', 'AR', 'articulare', 'Articulare'],
  ANS: ['ANS', 'ans', 'Anterior Nasal Spine'],
  PNS: ['PNS', 'pns', 'posterior nasal spine', 'Posterior Nasal Spine'],
  Gn: ['Gn', 'gn', 'GN', 'gnathion', 'Gnathion'],
  'Gn\'': ['Gnâ€²', 'Gn\'', 'gnâ€²', 'gn\'', 'GN\'', 'GN', 'Soft tissue Gnathion', 'soft tissue gnathion'],
  'Gn`': ['Gn`', 'gn`', 'Gn`', 'gn`', 'Soft tissue Gnathion', 'soft tissue gnathion'],
  'N\'': ['Nâ€²', 'N\'', 'nâ€²', 'n\'', 'Nprime', 'nprime'],
  'N`': ['N`', 'n`', 'N`', 'n`', 'Nprime', 'nprime'],
  UL: ['UL', 'ul', 'ULâ€²', 'UL\'', 'ulâ€²', 'ul\'', 'Ls', 'ls', 'LS', 'Labiale Superius', 'labiale superius', 'Upper Lip'],
  'UL\'': ['ULâ€²', 'UL\'', 'ulâ€²', 'ul\''],
  'UL`': ['UL`', 'ul`', 'UL`', 'ul`'],
  LL: ['LL', 'll', 'LLâ€²', 'LL\'', 'llâ€²', 'll\'', 'Li', 'li', 'LI', 'Labiale Inferius', 'labiale inferius', 'Lower Lip'],
  'LL\'': ['LLâ€²', 'LL\'', 'llâ€²', 'll\''],
  'LL`': ['LL`', 'll`', 'LL`', 'll`'],
  U1: ['U1', 'u1', 'upper_incisor', 'Upper Incisor'],
  U1A: ['U1A', 'u1a', 'U1a', 'upper_incisor_apex', 'Upper_incisor_apex'],
  L1: ['L1', 'l1', 'lower_incisor', 'Lower Incisor', 'lower', 'incisor'],
  L1A: ['L1A', 'l1a', 'L1a', 'lower_incisor_apex', 'Lower_incisor_apex'],
  LMT: ['LMT', 'lmt', 'lower_molar', 'Lower Molar', 'L6', 'l6'],
  UMT: ['UMT', 'umt', 'upper_molar', 'Upper Molar', 'U6', 'u6'],
  G: ['G', 'g', 'Glabella', 'glabella'],
  Sn: ['Sn', 'sn', 'SN', 'Subnasale', 'subnasale'],
  Cm: ['Cm', 'cm', 'CM', 'Columella', 'columella'],
  Pn: ['Pn', 'pn', 'PN', 'Prn', 'prn', 'PRN', 'Pronasale', 'pronasale'],
  Co: ['Co', 'co', 'CO', 'condyle', 'Condyle'],
  Ba: ['Ba', 'ba', 'BA'],
  Pt: ['Pt', 'pt', 'PT'],
  C: ['C', 'c', 'Cervical', 'cervical', 'Cervical Point', 'cervical point', 'C point', 'c point'],
};

// ----------------------------------------------------------------------

// 5 Ø±Ù†Ú¯ Ø³Ø±ÛŒØ¹ (Ù†Ù…Ø§ÛŒØ´ Ú©Ù†Ø§Ø± Ø¯Ú©Ù…Ù‡)
const QUICK_COLORS = [
  '#7eebff', // Ø¢Ø¨ÛŒ Ù†Ø¦ÙˆÙ†ÛŒ - Skeletal
  '#ff7497', // ØµÙˆØ±ØªÛŒ Ù‚Ø±Ù…Ø² - Dental  
  '#ffd33b', // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø¯Ø±Ø®Ø´Ø§Ù† - Soft Tissue
  '#74ffbb', // Ø³Ø¨Ø² Ù†Ø¦ÙˆÙ†ÛŒ - Reference
  '#c78eff', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Tracing
];

// ØªÙˆØ¶ÛŒØ­Ø§Øª Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ tooltip
const LANDMARK_DESCRIPTIONS = {
  'N': {
    name: 'Nasion (N)',
    description: 'Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø®Ø· Ø³Ø§Ø¬ÛŒØªØ§Ù„ Ù…ÛŒØ§Ù†ÛŒ Ø¨Ø§ Ø§Ø³ØªØ®ÙˆØ§Ù† Ø¨ÛŒÙ†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ù…Ù‡Ù… Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ ØµÙˆØ±Øª Ùˆ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'N\'': {
    name: 'Soft Nasion (N\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù†Ø±Ù… Ù†Ø§Ø³ÛŒÙˆÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù… Ø¨ÛŒÙ†ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'N`': {
    name: 'Soft Nasion (N`)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù†Ø±Ù… Ù†Ø§Ø³ÛŒÙˆÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù… Ø¨ÛŒÙ†ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Nprime': {
    name: 'Soft Nasion (N\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù†Ø±Ù… Ù†Ø§Ø³ÛŒÙˆÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù… Ø¨ÛŒÙ†ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Nâ€²': {
    name: 'Soft Nasion (Nâ€²)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù†Ø±Ù… Ù†Ø§Ø³ÛŒÙˆÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù… Ø¨ÛŒÙ†ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'S': {
    name: 'Sella (S)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù…Ø±Ú©Ø²ÛŒ Ø­ÙØ±Ù‡ Ø³Ù„Ø§Ø± (sella turcica) Ø¯Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ø§Ø³ÙÙ†ÙˆØ¦ÛŒØ¯. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø³ÙØ§Ù„ÙˆÙ…ØªØ±ÛŒ.'
  },
  'A': {
    name: 'Point A (A)',
    description: 'Ø¹Ù…ÛŒÙ‚â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª ÙÚ© Ø¨Ø§Ù„Ø§.'
  },
  'B': {
    name: 'Point B (B)',
    description: 'Ø¹Ù…ÛŒÙ‚â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒ Ù…Ù†Ø¯ÛŒØ¨Ù„ Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª ÙÚ© Ù¾Ø§ÛŒÛŒÙ†.'
  },
  'Pog': {
    name: 'Pogonion (Pog)',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ù†Ù…Ø§ÛŒ Ù„ØªØ±Ø§Ù„. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø¯Ø§Ù…ÛŒ-Ø®Ù„ÙÛŒ Ú†Ø§Ù†Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pog\'': {
    name: 'Soft Pogonion (Pog\')',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pog`': {
    name: 'Soft Pogonion (Pog`)',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pogprime': {
    name: 'Soft Pogonion (Pog\')',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Go': {
    name: 'Gonion (Go)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø²Ø§ÙˆÛŒÙ‡â€ŒØ§ÛŒ Ù…Ù†Ø¯ÛŒØ¨Ù„ Ø¯Ø± Ù…Ø­Ù„ ØªÙ‚Ø§Ø·Ø¹ Ø±Ø§Ù…ÙˆØ³ Ùˆ Ø¨Ø§Ø¯ÛŒ Ù…Ù†Ø¯ÛŒØ¨Ù„. Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ú¯ÙˆÙ†ÛŒØ§Ù„ Ùˆ Ø·ÙˆÙ„ Ù…Ù†Ø¯ÛŒØ¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Me': {
    name: 'Menton (Me)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ù†Ù…Ø§ÛŒ Ù„ØªØ±Ø§Ù„. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø§Ø±ØªÙØ§Ø¹ ØµÙˆØ±Øª Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¹Ù…ÙˆØ¯ÛŒ Ú†Ø§Ù†Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Me\'': {
    name: 'Soft Menton (Me\')',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Me`': {
    name: 'Soft Menton (Me`)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'MeSoft': {
    name: 'Soft Menton (MeSoft)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Meprime': {
    name: 'Soft Menton (Meprime)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Meâ€²': {
    name: 'Soft Menton (Meâ€²)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Or': {
    name: 'Orbitale (Or)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ ØªØ­ØªØ§Ù†ÛŒ Ú©Ø§Ø³Ù‡ Ú†Ø´Ù…. Ø¨Ø®Ø´ÛŒ Ø§Ø² Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Frankfort Horizontal) Ø§Ø³Øª.'
  },
  'Po': {
    name: 'Porion (Po)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú©Ø§Ù†Ø§Ù„ Ú¯ÙˆØ´ Ø®Ø§Ø±Ø¬ÛŒ. Ø¨Ø®Ø´ÛŒ Ø§Ø² Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Frankfort Horizontal) Ø§Ø³Øª.'
  },
  'ANS': {
    name: 'Anterior Nasal Spine (ANS)',
    description: 'Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù†ÙˆÚ©â€ŒØªÛŒØ² Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ ÙÚ© Ø¨Ø§Ù„Ø§'
  },
  'PNS': {
    name: 'Posterior Nasal Spine (PNS)',
    description: 'Ø®Ù„ÙÛŒ ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù†ÙˆÚ©â€ŒØªÛŒØ² Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ ÙÚ© Ø¨Ø§Ù„Ø§'
  },
  'Gn': {
    name: 'Gnathion (Gn)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø³Ù…Øª Ú†Ø§Ù†Ù‡ Ø¯Ø± Ù†Ù…Ø§ÛŒ Ù„ØªØ±Ø§Ù„. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¹Ù…ÙˆØ¯ÛŒ Ú†Ø§Ù†Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Gn\'': {
    name: 'Soft Gnathion (Gn\')',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø³Ù…Øª Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Gn`': {
    name: 'Soft Gnathion (Gn`)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø³Ù…Øª Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Gnâ€²': {
    name: 'Soft Gnathion (Gnâ€²)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø³Ù…Øª Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'G': {
    name: 'Glabella (G)',
    description: 'Ø¨Ø±Ø¬Ø³ØªÙ‡â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±ØªÙØ§Ø¹ ØµÙˆØ±Øª Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'g': {
    name: 'Glabella (G)',
    description: 'Ø¨Ø±Ø¬Ø³ØªÙ‡â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±ØªÙØ§Ø¹ ØµÙˆØ±Øª Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'glabella': {
    name: 'Glabella (G)',
    description: 'Ø¨Ø±Ø¬Ø³ØªÙ‡â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø¯Ø± Ø®Ø· Ù…ÛŒØ§Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±ØªÙØ§Ø¹ ØµÙˆØ±Øª Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù¾ÛŒØ´Ø§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Ar': {
    name: 'Articulare (Ar)',
    description: 'Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ú©Ø§Ù†ØªÙˆØ± Ø®Ù„ÙÛŒ Ø±Ø§Ù…ÙˆØ³ Ù…Ù†Ø¯ÛŒØ¨Ù„ Ø¨Ø§ Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…ÙØµÙ„ Ú¯ÛŒØ¬Ú¯Ø§Ù‡ÛŒ-ÙÚ©ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'U1': {
    name: 'Upper Incisor (U1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'u1': {
    name: 'Upper Incisor (U1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'upper_incisor': {
    name: 'Upper Incisor (U1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'upper incisor': {
    name: 'Upper Incisor (U1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'L1': {
    name: 'Lower Incisor (L1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'l1': {
    name: 'Lower Incisor (L1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'lower_incisor': {
    name: 'Lower Incisor (L1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'lower incisor': {
    name: 'Lower Incisor (L1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù„Ø¨Ù‡ Ø¨Ø±Ø´ Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ùˆ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´ÛŒÙ† Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'UL': {
    name: 'Upper Lip (UL)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'UL\'': {
    name: 'Soft Upper Lip (UL\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'UL`': {
    name: 'Soft Upper Lip (UL`)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'ULprime': {
    name: 'Soft Upper Lip (UL\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'ULâ€²': {
    name: 'Soft Upper Lip (ULâ€²)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LL': {
    name: 'Lower Lip (LL)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù„Ø¨ Ù¾Ø§ÛŒÛŒÙ† Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LL\'': {
    name: 'Soft Lower Lip (LL\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ù¾Ø§ÛŒÛŒÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LLâ€²': {
    name: 'Soft Lower Lip (LLâ€²)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ù¾Ø§ÛŒÛŒÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LLprime': {
    name: 'Soft Lower Lip (LL\')',
    description: 'Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù‚Ø³Ù…Øª Ù„Ø¨ Ù¾Ø§ÛŒÛŒÙ† Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Sn': {
    name: 'Subnasale (Sn)',
    description: 'Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø³ØªÙˆÙ† Ø¨ÛŒÙ†ÛŒ Ø¨Ø§ ÙÛŒÙ„ØªØ±ÙˆÙ… Ù„Ø¨ Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø§Ø±ØªÙØ§Ø¹ ØµÙˆØ±Øª Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨ÛŒÙ†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pn': {
    name: 'Pronasale (Pn)',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¨ÛŒÙ†ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø¨Ø±Ø¬Ø³ØªÚ¯ÛŒ Ø¨ÛŒÙ†ÛŒ Ùˆ Ø²ÛŒØ¨Ø§ÛŒÛŒ ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pogâ€²': {
    name: 'Soft Pogonion (Pogâ€²)',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'PogSoft': {
    name: 'Soft Pogonion (PogSoft)',
    description: 'Ù‚Ø³Ù…Øª Ù‚Ø¯Ø§Ù…ÛŒâ€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú†Ø§Ù†Ù‡ Ø¯Ø± Ø¨Ø§ÙØª Ù†Ø±Ù…. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'U1A': {
    name: 'Upper Incisor Apex (U1A)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø±Ø£Ø³ (apex) Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'L1A': {
    name: 'Lower Incisor Apex (L1A)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø±Ø£Ø³ (apex) Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'U1T': {
    name: 'Upper Incisor Tip (U1T)',
    description: 'Ù†ÙˆÚ© Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø·ÙˆÙ„ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'L1T': {
    name: 'Lower Incisor Tip (L1T)',
    description: 'Ù†ÙˆÚ© Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø·ÙˆÙ„ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LMT': {
    name: 'Lower Molar Tip (LMT)',
    description: 'Ù†ÙˆÚ© Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ (Occlusal Plane) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Ba': {
    name: 'Basion (Ba)',
    description: 'Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‚Ø¯Ø§Ù…ÛŒ Ø³ÙˆØ±Ø§Ø® Ø¨Ø²Ø±Ú¯ Ù¾Ø³â€ŒØ³Ø±ÛŒ (foramen magnum). Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Pt': {
    name: 'Pterygomaxillary Fissure (Pt)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'pt': {
    name: 'Pterygomaxillary Fissure (Pt)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'PT': {
    name: 'Pterygomaxillary Fissure (Pt)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'pterygomaxillary': {
    name: 'Pterygomaxillary Fissure (Pt)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Ptm': {
    name: 'Pterygomaxillary Point (Ptm)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ù„ÙÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'ptm': {
    name: 'Pterygomaxillary Point (Ptm)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ù„ÙÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'PTM': {
    name: 'Pterygomaxillary Point (Ptm)',
    description: 'Ù†Ù‚Ø·Ù‡ Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø´Ú©Ø§Ù Ù¾ØªØ±ÛŒÚ¯ÙˆÙ…Ø§Ú©Ø³ÛŒÙ„Ø§Ø±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø®Ù„ÙÛŒ Ù…Ø§Ú¯Ø²ÛŒÙ„Ø§ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ù„ÙÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Bo': {
    name: 'Bolton Point (Bo)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø§Ù†Ø­Ù†Ø§ÛŒ Ø±Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ ÙÙˆØ³Ø§ÛŒ Ø±ØªØ±ÙˆÚ©Ù†Ø¯ÛŒÙ„Ø§Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ù¾Ø³â€ŒØ³Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¢Ù†Ø§ØªÙˆÙ…ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'bo': {
    name: 'Bolton Point (Bo)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø§Ù†Ø­Ù†Ø§ÛŒ Ø±Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ ÙÙˆØ³Ø§ÛŒ Ø±ØªØ±ÙˆÚ©Ù†Ø¯ÛŒÙ„Ø§Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ù¾Ø³â€ŒØ³Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¢Ù†Ø§ØªÙˆÙ…ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'BO': {
    name: 'Bolton Point (Bo)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø§Ù†Ø­Ù†Ø§ÛŒ Ø±Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ ÙÙˆØ³Ø§ÛŒ Ø±ØªØ±ÙˆÚ©Ù†Ø¯ÛŒÙ„Ø§Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ù¾Ø³â€ŒØ³Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¢Ù†Ø§ØªÙˆÙ…ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'bolton': {
    name: 'Bolton Point (Bo)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø§Ù†Ø­Ù†Ø§ÛŒ Ø±Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ ÙÙˆØ³Ø§ÛŒ Ø±ØªØ±ÙˆÚ©Ù†Ø¯ÛŒÙ„Ø§Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ù¾Ø³â€ŒØ³Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¢Ù†Ø§ØªÙˆÙ…ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'Bolton': {
    name: 'Bolton Point (Bo)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø¯Ø± Ø§Ù†Ø­Ù†Ø§ÛŒ Ø±Ùˆ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ÛŒ ÙÙˆØ³Ø§ÛŒ Ø±ØªØ±ÙˆÚ©Ù†Ø¯ÛŒÙ„Ø§Ø± Ø§Ø³ØªØ®ÙˆØ§Ù† Ù¾Ø³â€ŒØ³Ø±ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¢Ù†Ø§ØªÙˆÙ…ÛŒÚ© Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø§Ø¹Ø¯Ù‡ Ø¬Ù…Ø¬Ù…Ù‡.'
  },
  'UMT': {
    name: 'Upper Molar Tip (UMT)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'umt': {
    name: 'Upper Molar Tip (UMT)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'upper_molar': {
    name: 'Upper Molar Tip (UMT)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Upper Molar': {
    name: 'Upper Molar Tip (UMT)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'U6': {
    name: 'Upper Molar (U6)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'u6': {
    name: 'Upper Molar (U6)',
    description: 'ØªØ§Ø¬ Ø¯Ù†Ø¯Ø§Ù† Ù…ÙˆÙ„Ø± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ ØªØ¹Ø±ÛŒÙ ØµÙØ­Ù‡ Ø§Ú©Ù„ÙˆØ²Ø§Ù„ Ùˆ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…ÙˆÙ„Ø± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Cm': {
    name: 'Columella (Cm)',
    description: 'Ù‚Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡ Ø¨ÛŒÙ†ÛŒ (Ø³Ù¾ØªÙˆÙ…) Ø§Ø³Øª Ú©Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø³ÙˆØ±Ø§Ø® Ø¨ÛŒÙ†ÛŒ (Nostrils) Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¨ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ Ù„Ø¨ Ø¨Ø§Ù„Ø§ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.'
  },
  'cm': {
    name: 'Columella (Cm)',
    description: 'Ù‚Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡ Ø¨ÛŒÙ†ÛŒ (Ø³Ù¾ØªÙˆÙ…) Ø§Ø³Øª Ú©Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø³ÙˆØ±Ø§Ø® Ø¨ÛŒÙ†ÛŒ (Nostrils) Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¨ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ Ù„Ø¨ Ø¨Ø§Ù„Ø§ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.'
  },
  'CM': {
    name: 'Columella (Cm)',
    description: 'Ù‚Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡ Ø¨ÛŒÙ†ÛŒ (Ø³Ù¾ØªÙˆÙ…) Ø§Ø³Øª Ú©Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø³ÙˆØ±Ø§Ø® Ø¨ÛŒÙ†ÛŒ (Nostrils) Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¨ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ Ù„Ø¨ Ø¨Ø§Ù„Ø§ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.'
  },
  'columella': {
    name: 'Columella (Cm)',
    description: 'Ù‚Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡ Ø¨ÛŒÙ†ÛŒ (Ø³Ù¾ØªÙˆÙ…) Ø§Ø³Øª Ú©Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø³ÙˆØ±Ø§Ø® Ø¨ÛŒÙ†ÛŒ (Nostrils) Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¨ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ Ù„Ø¨ Ø¨Ø§Ù„Ø§ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.'
  },
  'Columella': {
    name: 'Columella (Cm)',
    description: 'Ù‚Ø³Ù…Øª Ù¾Ø§ÛŒÛŒÙ†ÛŒ Ø¯ÛŒÙˆØ§Ø±Ù‡ Ø¨ÛŒÙ†ÛŒ (Ø³Ù¾ØªÙˆÙ…) Ø§Ø³Øª Ú©Ù‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø³ÙˆØ±Ø§Ø® Ø¨ÛŒÙ†ÛŒ (Nostrils) Ù‚Ø±Ø§Ø± Ú¯Ø±ÙØªÙ‡ Ùˆ Ø¨ÛŒÙ†ÛŒ Ø±Ø§ Ø¨Ù‡ Ù„Ø¨ Ø¨Ø§Ù„Ø§ ÙˆØµÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.'
  },
  'Co': {
    name: 'Condylion (Co)',
    description: 'Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ú©Ù†Ø¯ÛŒÙ„ Ù…Ù†Ø¯ÛŒØ¨Ù„. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø·ÙˆÙ„ Ù…Ù†Ø¯ÛŒØ¨Ù„ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…ÙØµÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LIA': {
    name: 'Lower Incisor Apex (LIA)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø±Ø£Ø³ (apex) Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'LIT': {
    name: 'Lower Incisor Tip (LIT)',
    description: 'Ù†ÙˆÚ© Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ù¾Ø§ÛŒÛŒÙ†. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø·ÙˆÙ„ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'UIA': {
    name: 'Upper Incisor Apex (UIA)',
    description: 'Ù†Ù‚Ø·Ù‡ Ø±Ø£Ø³ (apex) Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'UIT': {
    name: 'Upper Incisor Tip (UIT)',
    description: 'Ù†ÙˆÚ© Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± ÙÚ© Ø¨Ø§Ù„Ø§. Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ø·ÙˆÙ„ Ùˆ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù†Ø¯Ø§Ù† Ø§ÛŒÙ†Ø³Ø§ÛŒØ²ÙˆØ± Ø¨Ø§Ù„Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  // Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ C Ùˆ D
  'C': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'c': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Cervical': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'cervical': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'Cervical Point': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'cervical point': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'C point': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'c point': {
    name: 'Cervical Point (C)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú¯Ø±Ø¯Ù†ÛŒ. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ù†Ø§Ø­ÛŒÙ‡ Ú¯Ø±Ø¯Ù† Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ù†Ø±Ù… ØµÙˆØ±Øª Ùˆ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'D': {
    name: 'D Point (D)',
    description: 'Ù†Ù‚Ø·Ù‡ D. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø³ÙØ§Ù„ÙˆÙ…ØªØ±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ Ùˆ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'd': {
    name: 'D Point (D)',
    description: 'Ù†Ù‚Ø·Ù‡ D. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø³ÙØ§Ù„ÙˆÙ…ØªØ±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ Ùˆ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'D point': {
    name: 'D Point (D)',
    description: 'Ù†Ù‚Ø·Ù‡ D. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø³ÙØ§Ù„ÙˆÙ…ØªØ±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ Ùˆ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  'd point': {
    name: 'D Point (D)',
    description: 'Ù†Ù‚Ø·Ù‡ D. Ù†Ù‚Ø·Ù‡ Ù…Ø±Ø¬Ø¹ Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø³ÙØ§Ù„ÙˆÙ…ØªØ±ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ Ùˆ ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.'
  },
  // Ù†Ù‚Ø§Ø· Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† (Calibration Points)
  'p1': {
    name: 'Calibration Point 1 (p1)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ù¾Ø§ÛŒÛŒÙ†ÛŒ. Ø§ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‡Ù…Ø±Ø§Ù‡ Ø¨Ø§ p2 Ø¨Ø±Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ù…Ù‚ÛŒØ§Ø³ Ù¾ÛŒÚ©Ø³Ù„ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯. ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† p1 Ùˆ p2 Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 1 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (10 Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ±) Ø§Ø³Øª.'
  },
  'p2': {
    name: 'Calibration Point 2 (p2)',
    description: 'Ù†Ù‚Ø·Ù‡ Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ø¨Ø§Ù„Ø§ÛŒÛŒ. Ø§ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù‡Ù…Ø±Ø§Ù‡ Ø¨Ø§ p1 Ø¨Ø±Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ Ù…Ù‚ÛŒØ§Ø³ Ù¾ÛŒÚ©Ø³Ù„ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯. ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† p1 Ùˆ p2 Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 1 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (10 Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ±) Ø§Ø³Øª.'
  }
};

// 20 Ø±Ù†Ú¯ Ú©Ø§Ù…Ù„ Ø¨Ø±Ø§ÛŒ Ù¾Ù†Ø¬Ø±Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø±Ù†Ú¯
const ALL_COLORS = [
  // Ø±Ø¯ÛŒÙ 1 - Ø¢Ø¨ÛŒâ€ŒÙ‡Ø§
  '#00D9FF', '#2196F3', '#03A9F4', '#00BCD4',
  // Ø±Ø¯ÛŒÙ 2 - Ù‚Ø±Ù…Ø² Ùˆ ØµÙˆØ±ØªÛŒ
  '#FF3B6D', '#F44336', '#E91E63', '#9C27B0',
  // Ø±Ø¯ÛŒÙ 3 - Ù†Ø§Ø±Ù†Ø¬ÛŒ Ùˆ Ø²Ø±Ø¯
  '#FF8A00', '#FF9800', '#FFC107', '#FFD600',
  // Ø±Ø¯ÛŒÙ 4 - Ø³Ø¨Ø²
  '#00E676', '#4CAF50', '#8BC34A', '#CDDC39',
  // Ø±Ø¯ÛŒÙ 5 - Ø¨Ù†ÙØ´ Ùˆ Ø®Ø§Ú©Ø³ØªØ±ÛŒ
  '#B388FF', '#673AB7', '#607D8B', '#9E9E9E',
];

// ----------------------------------------------------------------------

// Ø±Ù†Ú¯â€ŒØ¨Ù†Ø¯ÛŒ landmarks - Ù‡Ø± Ù„Ù†Ø¯Ù…Ø§Ø±Ú© ÛŒÚ© Ø±Ù†Ú¯ Ù…ØªÙØ§ÙˆØª
const DEFAULT_LANDMARK_COLORS = {
  S: '#f32194',      // Ø¢Ø¨ÛŒ - Sella
  N: '#FF3B6D',      // ØµÙˆØ±ØªÛŒ Ù‚Ø±Ù…Ø² - Nasion
  A: '#03A9F4',      // Ø¢Ø¨ÛŒ Ø±ÙˆØ´Ù† - Point A
  B: '#00BCD4',      // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Point B
  Pog: '#4CAF50',    // Ø³Ø¨Ø² - Pogonion
  Go: '#e116e7',     // Ø³Ø¨Ø² Ø±ÙˆØ´Ù† - Gonion
  Me: '#881aee',     // Ø³Ø¨Ø² Ø²Ø±Ø¯ - Menton
  Or: '#FFC107',     // Ø²Ø±Ø¯ - Orbitale
  Po: '#ff6600',     // Ù†Ø§Ø±Ù†Ø¬ÛŒ - Porion
  ANS: '#02ffb4',    // Ù†Ø§Ø±Ù†Ø¬ÛŒ ØªÛŒØ±Ù‡ - Anterior Nasal Spine
  PNS: '#c1fe07',    // Ù‚Ø±Ù…Ø² - Posterior Nasal Spine
  Gn: '#E91E63',     // ØµÙˆØ±ØªÛŒ - Gnathion
  Ar: '#9C27B0',     // Ø¨Ù†ÙØ´ - Articulare
  G: '#FF6B9D',      // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Glabella
  Glabella: '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Glabella
  
  // Ù†Ù‚Ø§Ø· Ø¯Ù†Ø¯Ø§Ù†ÛŒ
  U1: '#FF3B6D',     // ØµÙˆØ±ØªÛŒ Ù‚Ø±Ù…Ø² - Upper Incisor
  L1: '#d9ff18',     // ØµÙˆØ±ØªÛŒ - Lower Incisor
  UL: '#FF8A00',     // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø¯Ø±Ø®Ø´Ø§Ù† - Upper Lip
  LL: '#FF9800',     // Ù†Ø§Ø±Ù†Ø¬ÛŒ - Lower Lip
  Sn: '#FF3B6D',     // Ø²Ø±Ø¯ - Subnasale
  Pn: '#00E676',     // Ø³Ø¨Ø² Ù†Ø¦ÙˆÙ†ÛŒ - Pronasale
  Cm: '#B388FF',     // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Columella
  cm: '#B388FF',     // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Columella
  CM: '#B388FF',     // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Columella
  columella: '#B388FF', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Columella
  Columella: '#B388FF', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Columella
  'Pog\'': '#342070', // Ø¨Ù†ÙØ´ - Soft Pogonion (Pog')
  'Pogâ€²': '#c9ff2d',  // Ø¨Ù†ÙØ´ - Soft Pogonion (Pogâ€²)
  PogSoft: '#342070', // Ø¨Ù†ÙØ´ - Soft Pogonion
  
  // Ù†Ù‚Ø§Ø· Ø§Ø¶Ø§ÙÛŒ
  LIA: '#FF3B6D',    // Ù‚Ø±Ù…Ø² - Lower Incisor Apex
  LIT: '#38a1a0',    // ØµÙˆØ±ØªÛŒ - Lower Incisor Tip
  UIA: '#ff3ba8',    // ØµÙˆØ±ØªÛŒ Ù‚Ø±Ù…Ø² - Upper Incisor Apex
  UIT: '#FF3B6D',    // Ù†Ø§Ø±Ù†Ø¬ÛŒ ØªÛŒØ±Ù‡ - Upper Incisor Tip
  
  // Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ cldetection2023
  LMT: '#FF6B6B',    // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù† - Lower Molar Tip
  L6: '#FF6B6B',     // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù† - Lower Molar (L6)
  l6: '#FF6B6B',     // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù† - Lower Molar (l6)
  lower_molar: '#FF6B6B', // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù† - Lower Molar
  'Lower Molar': '#FF6B6B', // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù† - Lower Molar
  UMT: '#FF8787',    // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar Tip
  umt: '#FF8787',    // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar Tip
  upper_molar: '#FF8787', // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar
  'Upper Molar': '#FF8787', // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar
  U6: '#FF8787',     // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar (U6)
  u6: '#FF8787',     // Ù‚Ø±Ù…Ø² Ø±ÙˆØ´Ù†â€ŒØªØ± - Upper Molar (u6)
  Co: '#4ECDC4',     // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Condylion
  condylion: '#4ECDC4', // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Condylion
  Ba: '#95E1D3',     // Ø³Ø¨Ø² ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Basion
  basion: '#95E1D3', // Ø³Ø¨Ø² ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Basion
  Pt: '#F38181',     // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Pterygomaxillary fissure
  pt: '#F38181',     // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Pterygomaxillary fissure
  PT: '#F38181',     // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Pterygomaxillary fissure
  pterygomaxillary: '#F38181', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Pterygomaxillary fissure
  Ptm: '#FF8E8E',    // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù†â€ŒØªØ± - Pterygomaxillary Point
  ptm: '#FF8E8E',    // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù†â€ŒØªØ± - Pterygomaxillary Point
  PTM: '#FF8E8E',    // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù†â€ŒØªØ± - Pterygomaxillary Point
  L1A: '#FF3B6D',    // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Lower Incisor Apex (alternative)
  L1T: '#FCBAD3',    // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Lower Incisor Tip (alternative)
  U1A: '#d59066',    // Ø²Ø±Ø¯ Ø±ÙˆØ´Ù† - Upper Incisor Apex (alternative)
  U1T: '#FFD3A5',    // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø±ÙˆØ´Ù† - Upper Incisor Tip (alternative)
  
  // Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ cldetection
  'N\'': '#FF6B9D',  // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Soft Nasion
  'N`': '#FF6B9D',   // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Soft Nasion (alternative)
  Nprime: '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Soft Nasion
  'Me\'': '#C8A2C8', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Soft Menton
  'Me`': '#C8A2C8',  // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Soft Menton (alternative)
  MeSoft: '#C8A2C8', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Soft Menton
  Meprime: '#C8A2C8', // Ø¨Ù†ÙØ´ Ø±ÙˆØ´Ù† - Soft Menton
  Bo: '#FFB74D',     // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø±ÙˆØ´Ù† - Bolton point
  bolton: '#FFB74D', // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø±ÙˆØ´Ù† - Bolton point
  Bolton: '#FFB74D', // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø±ÙˆØ´Ù† - Bolton point
  Co1: '#4ECDC4',    // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ - Condylion 1
  Co2: '#45B7B8',    // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ ØªÛŒØ±Ù‡ - Condylion 2
  Co3: '#3DA3A4',    // ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ ØªÛŒØ±Ù‡â€ŒØªØ± - Condylion 3
  
  // Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ C Ùˆ D (Cervical Point Ùˆ D Point)
  C: '#FF6B9D',      // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  c: '#FF6B9D',      // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  Cervical: '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  cervical: '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  'Cervical Point': '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  'cervical point': '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  'C point': '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  'c point': '#FF6B9D', // ØµÙˆØ±ØªÛŒ Ø±ÙˆØ´Ù† - Cervical Point
  D: '#FF9800',      // Ù†Ø§Ø±Ù†Ø¬ÛŒ - D Point
  d: '#FF9800',      // Ù†Ø§Ø±Ù†Ø¬ÛŒ - D Point
  'D point': '#FF9800', // Ù†Ø§Ø±Ù†Ø¬ÛŒ - D Point
  'd point': '#FF9800', // Ù†Ø§Ø±Ù†Ø¬ÛŒ - D Point
  
  // Ù†Ù‚Ø§Ø· Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† (ÙØ§ØµÙ„Ù‡ 1cm) - Ø±Ù†Ú¯ Ø²Ø±Ø¯ Ø·Ù„Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø±Ø§Ø­Øªâ€ŒØªØ±
  p1: '#ffffff',  // Ù†Ø§Ø±Ù†Ø¬ÛŒ Ø·Ù„Ø§ÛŒÛŒ - Calibration Point p1 (bottom, 1cm apart from p2)
  p2: '#ffffff',  // Ø·Ù„Ø§ÛŒÛŒ - Calibration Point p2 (top, 1cm apart from p1)
  
  // Ù¾ÛŒØ´â€ŒÙØ±Ø¶ - Ø±Ù†Ú¯ Ù…Ø¯Ø±Ù† Ùˆ Ø´ÛŒÚ©
  default: '#0ab0dd', // Ø¢Ø¨ÛŒ Ù†Ø¦ÙˆÙ†ÛŒ Ø±ÙˆØ´Ù† Ùˆ Ù…Ø¯Ø±Ù†
};

// Ø®Ø·ÙˆØ· Ù¾ÛŒØ´â€ŒÙØ±Ø¶
const DEFAULT_LINES = [
  // Ø®Ø·ÙˆØ· Ù…Ù‡Ù… cephalometric
  { start: 'S', end: 'N', label: 'S-N' },
  { start: 'N', end: 'A', label: 'N-A' },
  { start: 'S', end: 'A', label: 'S-A' },
  { start: 'N', end: 'B', label: 'N-B' },
  { start: 'N', end: 'Pog', label: 'N-Pog' },
  { start: 'Go', end: 'Me', label: 'Go-Me (Mandibular Plane)' },
  { start: 'Go', end: 'Gn', label: 'Go-Gn' },
  { start: 'ANS', end: 'PNS', label: 'ANS-PNS' },
  { start: 'Or', end: 'Po', label: 'Or-Po (Frankfort)' },
  { start: 'U1', end: 'L1', label: 'U1-L1' },
  // Ø®Ø·ÙˆØ· Ø§Ø¶Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ FMIA, IMPA, U1-SN, L1-MP
  { start: 'S', end: 'U1', label: 'S-U1 (for U1-SN)' },
  { start: 'L1', end: 'Me', label: 'L1-Me (for IMPA & L1-MP)' },
  { start: 'Or', end: 'L1', label: 'Or-L1 (for FMIA)' },
  { start: 'Po', end: 'L1', label: 'Po-L1 (for FMIA)' },
];

// Object Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ø§Ø´Øª Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ Ø¨Ù‡ Ø®Ø·ÙˆØ· Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² (Ø¨Ø±Ø§ÛŒ Ú©Ø§Ù‡Ø´ Ø´Ø±Ø·â€ŒÙ‡Ø§ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ)
const ANALYSIS_LINE_CONFIG = {
  mcnamara: {
    exclude: [['Go', 'Me'], ['Me', 'Go']],
    include: [['N', 'A'], ['N', 'Pog'], ['S', 'Go'], ['N', 'Me'], ['Go', 'Gn'], ['U1', 'A'], ['L1', 'A']],
  },
  jarabak: {
    exclude: [['Or', 'Po'], ['Po', 'Or'], ['ANS', 'PNS'], ['PNS', 'ANS']],
    include: [['S', 'N'], ['Go', 'Me'], ['Go', 'Gn'], ['S', 'Ar'], ['Ar', 'Go'], ['Co', 'Gn']],
  },
  softTissue: {
    exclude: [
      ['S', 'N'], ['N', 'S'], ['Or', 'Po'], ['Po', 'Or'], ['ANS', 'PNS'], ['PNS', 'ANS'],
      ['N', 'A'], ['A', 'N'], ['N', 'B'], ['B', 'N'], ['N', 'Pog'], ['Pog', 'N'],
      ['S', 'A'], ['A', 'S'], ['S', 'B'], ['B', 'S'], ['Go', 'Me'], ['Me', 'Go'],
      ['Go', 'Gn'], ['Gn', 'Go'], ['Ar', 'Go'], ['Go', 'Ar'], ['S', 'Ar'], ['Ar', 'S'],
      ['S', 'Go'], ['Go', 'S'], ['U1', 'L1'], ['L1', 'U1'], ['U1', 'A'], ['A', 'U1'],
      ['L1', 'A'], ['A', 'L1'], ['S', 'U1'], ['U1', 'S'], ['L1', 'Me'], ['Me', 'L1'],
      ['Or', 'L1'], ['L1', 'Or'], ['Po', 'L1'], ['L1', 'Po'], ['Gn', 'Pt'], ['Pt', 'Gn'],
      ['Ba', 'Pt'], ['Pt', 'Ba'], ['N', 'Me'], ['Me', 'N'], ['Co', 'Gn'], ['Gn', 'Co'],
      ['L1', 'LMT'], ['LMT', 'L1'], ['A', 'B'], ['B', 'A'], ['L1A', 'L1'], ['L1', 'L1A'],
    ],
  },
};

// ØªØ§Ø¨Ø¹ helper Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø®Ø· Ø¨Ø§ÛŒØ¯ Ø±Ø³Ù… Ø´ÙˆØ¯ ÛŒØ§ Ù†Ù‡
const shouldDrawLine = (start, end, analysisType) => {
  const config = ANALYSIS_LINE_CONFIG[analysisType];
  if (!config) return true;
  
  // Ø¨Ø±Ø±Ø³ÛŒ exclude
  if (config.exclude?.some(([s, e]) => 
    (start === s && end === e) || (start === e && end === s)
  )) {
    return false;
  }
  
  // Ø§Ú¯Ø± include ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ØŒ ÙÙ‚Ø· Ø¢Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
  if (config.include) {
    return config.include.some(([s, e]) => 
      (start === s && end === e) || (start === e && end === s)
    );
  }
  
  return true;
};

// Ø®Ø·ÙˆØ· Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹ Ø¢Ù†Ø§Ù„ÛŒØ²
const ANALYSIS_LINES = {
  steiner: [
    { start: 'S', end: 'N', label: 'S-N', extend: true },
    { start: 'N', end: 'A', label: 'N-A' },
    { start: 'N', end: 'B', label: 'N-B' },
    { start: 'ANS', end: 'PNS', label: 'ANS-PNS', extend: true },
  ],
  ricketts: [
    { start: 'Gn', end: 'Pt', label: 'Gn-Pt' },
    { start: 'Ba', end: 'Pt', label: 'Ba-Pt' },
    { start: 'N', end: 'Pog', label: 'N-Pog' },
    { start: 'Go', end: 'Me', label: 'Go-Me' , extend: true },
    { start: 'Or', end: 'Po', label: 'Or-Po' },
    { start: 'ANS', end: 'PNS', label: 'ANS-PNS' },
    { start: 'Pn', end: 'Pog`', label: 'E-line' , extend: true },
    { start: 'L1', end: 'LMT', label: 'Occlusal Plane' },
  ],
  mcnamara: [
    { start: 'N', end: 'A', label: 'N-A' },
    { start: 'N', end: 'Pog', label: 'N-Pog' },
    { start: 'S', end: 'Go', label: 'S-Go' },
    { start: 'N', end: 'Me', label: 'N-Me' },
    { start: 'Go', end: 'Gn', label: 'Go-Gn' },
    { start: 'U1', end: 'A', label: 'U1-A' },
    { start: 'L1', end: 'A', label: 'L1-A' },
  ],
  wits: [
    { start: 'A', end: 'B', label: 'A-B' },
    { start: 'L1', end: 'LMT', label: 'Occlusal Plane' },
  ],
  tweed: [
    { start: 'Or', end: 'Po', label: 'Or-Po (Frankfort)' },
    { start: 'Go', end: 'Me', label: 'Go-Me (Mandibular Plane)' },
    { start: 'L1A', end: 'L1', label: 'L1A-L1' },
  ],
  jarabak: [
    { start: 'S', end: 'N', label: 'S-N' },
    { start: 'Go', end: 'Me', label: 'Go-Me' },
    { start: 'Go', end: 'Gn', label: 'Go-Gn' },
    { start: 'S', end: 'Ar', label: 'S-Ar' },
    { start: 'Ar', end: 'Go', label: 'Ar-Go' },
    { start: 'Co', end: 'Gn', label: 'Co-Gn' },
  ],
  sassouni: [
    { start: 'S', end: 'N', label: 'S-N' },
    { start: 'Me', end: 'Go', label: 'Me-Go' },
    { start: 'S', end: 'Ar', label: 'S-Ar' },
    { start: 'Ar', end: 'Go', label: 'Ar-Go' },
    { start: 'L1', end: 'LMT', label: 'Occlusal Plane' },
    { start: 'ANS', end: 'PNS', label: 'ANS-PNS' },
  ],
  all: DEFAULT_LINES,
};

// ----------------------------------------------------------------------

export function AdvancedCephalometricVisualizer({
  imageUrl,
  landmarks: initialLandmarks,
  imageSize,
  onLandmarksChange,
  showMeasurements = true,
  calibrationPoints = null,
  showCoordinateSystem = false, // Ù†Ù…Ø§ÛŒØ´ Ù…Ø­ÙˆØ± Ù…Ø®ØªØµØ§Øª
  readOnly = false, // Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ù‚Ø§Ø¨Ù„ ÙˆÛŒØ±Ø§ÛŒØ´ Ø§Ø³Øª
  viewMode = 'normal', // View mode: 'normal', 'coordinate', 'hard-tissue-only'
  analysisType = 'all', // Analysis type: 'steiner', 'ricketts', 'mcnamara', 'wits', 'tweed', 'jarabak', 'sassouni', 'all'
  measurements = {}, // Measurements data for displaying angles
  pixelToMmConversion = null, // Conversion factor from pixels to millimeters (null if not available)
}) {
  const canvasRef = useRef(null);
  const imageRef = useRef(null);
  const containerRef = useRef(null);
  // ğŸ”§ FIX: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø±ØªÙØ§Ø¹ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¹Ø±Ø¶ viewport Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² jump
  const getInitialHeight = () => {
    if (typeof window !== 'undefined') {
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¹Ø±Ø¶ viewport Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø±ØªÙØ§Ø¹ Ø§ÙˆÙ„ÛŒÙ‡ (Ø¨Ø§ ÙØ±Ø¶ aspect ratio ØªÙ‚Ø±ÛŒØ¨ÛŒ 1.2:1)
      const viewportWidth = window.innerWidth;
      const estimatedContainerWidth = Math.min(viewportWidth - 100, 1200); // Ø¹Ø±Ø¶ ØªÙ‚Ø±ÛŒØ¨ÛŒ container
      return estimatedContainerWidth * 1.2; // Ø§Ø±ØªÙØ§Ø¹ ØªÙ‚Ø±ÛŒØ¨ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ aspect ratio
    }
    return 600;
  };
  const [containerHeight, setContainerHeight] = useState(getInitialHeight());
  const theme = useTheme();
  
  // State
  const [landmarks, setLandmarks] = useState(initialLandmarks || {});
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [isImageLoaded, setIsImageLoaded] = useState(false);
  const [showCoordinateSystemLocal, setShowCoordinateSystemLocal] = useState(showCoordinateSystem);
  
  // Detect mobile device
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  
  // Visual settings - half size on mobile
  const [pointSize, setPointSize] = useState(4);
  const [lineWidth, setLineWidth] = useState(1);
  
  // Calculate actual sizes based on device and zoom
  // Scale with zoom to maintain quality when zooming
  const basePointSize = isMobile ? pointSize / 2.5 : pointSize; // Ú©ÙˆÚ†Ú©ØªØ± Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
  const baseLineWidth = isMobile ? lineWidth / 1 : lineWidth;
  const actualPointSize = basePointSize * zoom;
  const actualLineWidth = baseLineWidth * zoom;
  const [lineColor, setLineColor] = useState('#FFFFFF');
  const [lineStyle, setLineStyle] = useState('solid'); // 'solid', 'dashed', 'dotted'
  const [showLabels, setShowLabels] = useState(true);
  const [showLines, setShowLines] = useState(true);
  const [useGradientLines, setUseGradientLines] = useState(true); // Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ÙØ¹Ø§Ù„
  const [landmarkColors, setLandmarkColors] = useState(DEFAULT_LANDMARK_COLORS);
  const [showTweedTriangle, setShowTweedTriangle] = useState(true); // Ø¨Ù‡ ØµÙˆØ±Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ ÙØ¹Ø§Ù„
  const [localShowLandmarkNames, setLocalShowLandmarkNames] = useState(true);
  
  // Cache Ø¨Ø±Ø§ÛŒ Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ (Ø¨Ù‡Ø¨ÙˆØ¯ Ø¹Ù…Ù„Ú©Ø±Ø¯)
  const landmarkColorCache = useMemo(() => {
    const cache = new Map();
    const getColorForLandmark = (name) => {
      if (cache.has(name)) return cache.get(name);
      
      if (!name || name === 'default' || name === 'vertex') {
        const color = landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      
      // Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø³ØªÙ‚ÛŒÙ…
      if (landmarkColors[name]) {
        cache.set(name, landmarkColors[name]);
        return landmarkColors[name];
      }
      
      // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
      const variations = [
        name,
        name.toUpperCase(),
        name.toLowerCase(),
        name.charAt(0).toUpperCase() + name.slice(1).toLowerCase(),
        name.replace(/'/g, '\''),
        name.replace(/â€²/g, '\''),
        name.replace(/'/g, 'â€²'),
      ];
      
      for (const variant of variations) {
        if (landmarkColors[variant]) {
          cache.set(name, landmarkColors[variant]);
          return landmarkColors[variant];
        }
      }
      
      // Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ
      if (name === 'G' || name === 'g') {
        const color = landmarkColors.G || landmarkColors.Glabella || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for Pog variations (backtick first, then apostrophe)
      if (name === 'Pog`' || name === 'Pog\'' || name === 'Pogâ€²') {
        const color = landmarkColors['Pog`'] || landmarkColors['Pog\''] || landmarkColors['Pogâ€²'] || landmarkColors.Pog || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for N variations (backtick first, then apostrophe)
      if (name === 'N`' || name === 'N\'' || name === 'Nâ€²') {
        const color = landmarkColors['N`'] || landmarkColors['N\''] || landmarkColors['Nâ€²'] || landmarkColors.N || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for Me variations (backtick first, then apostrophe)
      if (name === 'Me`' || name === 'Me\'' || name === 'Meâ€²') {
        const color = landmarkColors['Me`'] || landmarkColors['Me\''] || landmarkColors['Meâ€²'] || landmarkColors.Me || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for Gn variations (backtick first, then apostrophe)
      if (name === 'Gn`' || name === 'Gn\'' || name === 'Gnâ€²') {
        const color = landmarkColors['Gn`'] || landmarkColors['Gn\''] || landmarkColors['Gnâ€²'] || landmarkColors.Gn || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for UL variations (backtick first, then apostrophe)
      if (name === 'UL`' || name === 'UL\'' || name === 'ULâ€²') {
        const color = landmarkColors['UL`'] || landmarkColors['UL\''] || landmarkColors['ULâ€²'] || landmarkColors.UL || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      // Check for LL variations (backtick first, then apostrophe)
      if (name === 'LL`' || name === 'LL\'' || name === 'LLâ€²') {
        const color = landmarkColors['LL`'] || landmarkColors['LL\''] || landmarkColors['LLâ€²'] || landmarkColors.LL || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      if (name === 'Pt' || name === 'pt' || name === 'PT') {
        const color = landmarkColors.Pt || landmarkColors.pt || landmarkColors.PT || landmarkColors.Pterygoid || landmarkColors.default || '#00D9FF';
        cache.set(name, color);
        return color;
      }
      
      const defaultColor = landmarkColors.default || '#00D9FF';
      cache.set(name, defaultColor);
      return defaultColor;
    };
    
    return { getColorForLandmark, cache };
  }, [landmarkColors]);
  
  // Interaction
  const [draggedLandmark, setDraggedLandmark] = useState(null);
  const [hoveredLandmark, setHoveredLandmark] = useState(null);
  const [hoveredContour, setHoveredContour] = useState(null);
  const [selectedLandmark, setSelectedLandmark] = useState(null);
  const [animatingScale, setAnimatingScale] = useState({});
  const animationFrameRef = useRef(null);
  const rafRef = useRef(null); // Ø¨Ø±Ø§ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ mouse move
  const landmarksRef = useRef(landmarks); // Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¢Ø®Ø±ÛŒÙ† landmarks Ø¯Ø± mouseUp
  const dragStartPosition = useRef(null); // Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ ÙˆØ§Ù‚Ø¹Ø§Ù‹ drag Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
  const hasDragged = useRef(false); // Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ drag ÙˆØ§Ù‚Ø¹ÛŒ
  
  // Add/Delete mode
  const [isAddMode, setIsAddMode] = useState(false);
  const [newLandmarkName, setNewLandmarkName] = useState('');
  
  // Measurements - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² prop Ú©Ù‡ Ø§Ø² parent Ù¾Ø§Ø³ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
  // const [measurements, setMeasurements] = useState({}); // Ø­Ø°Ù Ø´Ø¯ - Ø§Ø² prop Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
  
  // Tracing mode
  const [isTracingMode, setIsTracingMode] = useState(false);
  const [tracingPoints, setTracingPoints] = useState([]);
  const [tracingStructures, setTracingStructures] = useState([]);
  const [currentTracingName, setCurrentTracingName] = useState('');
  
  // Context menu
  const [contextMenu, setContextMenu] = useState(null);
  
  // Line style menu
  const [lineStyleAnchor, setLineStyleAnchor] = useState(null);
  
  // Line color picker popover
  const [lineColorAnchor, setLineColorAnchor] = useState(null);
  
  // Add landmark modal
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [pendingLandmarkCoords, setPendingLandmarkCoords] = useState(null);
  const [newLandmarkNameModal, setNewLandmarkNameModal] = useState('');
  
  // Tooltip overlay (Ù†Ù…Ø§ÛŒØ´ Ø±ÙˆÛŒ canvas)
  const [canvasTooltip, setCanvasTooltip] = useState({ show: false, text: '', x: 0, y: 0 });
  
  // Landmark tooltip snackbar
  const [landmarkSnackbarOpen, setLandmarkSnackbarOpen] = useState(false);
  const [landmarkSnackbarContent, setLandmarkSnackbarContent] = useState(null);
  const [landmarkSnackbarDisplayContent, setLandmarkSnackbarDisplayContent] = useState(null);
  
  // Animated scale for hover effect (smooth transition) - Ø§Ø² ref Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€Œ civilization ØªØ§ infinite loop Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒÙ…
  const animatedScalesRef = useRef({});

  // Sync landmarks with props
  useEffect(() => {
    if (initialLandmarks) {
      setLandmarks(initialLandmarks);
    }
  }, [initialLandmarks]);

  // Sync coordinate system state with prop
  useEffect(() => {
    setShowCoordinateSystemLocal(showCoordinateSystem);
  }, [showCoordinateSystem]);

  // Load image (supports both data URLs and regular URLs)
  useEffect(() => {
    if (!imageUrl) return;

    const img = new Image();
    
    // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ data URL Ù†ÛŒØ§Ø²ÛŒ Ø¨Ù‡ crossOrigin Ù†ÛŒØ³Øª
    if (!imageUrl.startsWith('data:')) {
      img.crossOrigin = 'anonymous';
    }
    
    // Calculate container height based on image aspect ratio
    const updateHeight = () => {
      if (containerRef.current && img && img.complete && img.naturalHeight > 0) {
        const rect = containerRef.current.getBoundingClientRect();
        const containerWidth = rect.width;
        
        // ğŸ”§ FIX: Ø§Ú¯Ø± container Ù‡Ù†ÙˆØ² render Ù†Ø´Ø¯Ù‡ØŒ Ø§Ø² Ø¹Ø±Ø¶ viewport Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
        if (containerWidth === 0 && typeof window !== 'undefined') {
          const viewportWidth = window.innerWidth;
          const estimatedWidth = Math.min(viewportWidth - 100, 1200);
          const scale = estimatedWidth / img.width;
          const scaledHeight = img.height * scale;
          setContainerHeight(scaledHeight);
          return;
        }
        
        if (containerWidth > 0) {
          // Ù…Ø­Ø§Ø³Ø¨Ù‡ scale Ø¨Ø±Ø§ÛŒ fit Ú©Ø±Ø¯Ù† ØªØµÙˆÛŒØ± Ø¯Ø± Ø¹Ø±Ø¶ container
          const scale = containerWidth / img.width;
          // Ø§Ø±ØªÙØ§Ø¹ ÙˆØ§Ù‚Ø¹ÛŒ ØªØµÙˆÛŒØ± Ø¨Ø§ scale
          const scaledHeight = img.height * scale;
          // ØªÙ†Ø¸ÛŒÙ… Ø§Ø±ØªÙØ§Ø¹ container Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ Ø§Ø±ØªÙØ§Ø¹ scaled ØªØµÙˆÛŒØ± (Ø¨Ø¯ÙˆÙ† minimum Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ Ú©Ø§Ù…Ù„)
          setContainerHeight(scaledHeight);
        }
      }
    };
    
    img.onload = () => {
      imageRef.current = img;
      setIsImageLoaded(true);
      
      // ğŸ”§ FIX: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ø±ØªÙØ§Ø¹ Ù‚Ø¨Ù„ Ø§Ø² Ù†Ù…Ø§ÛŒØ´ ØªØµÙˆÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² jump
      // Ø§Ø¨ØªØ¯Ø§ Ø³Ø¹ÛŒ Ú©Ù† Ø§Ø² container Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const containerWidth = rect.width;
        
        if (containerWidth > 0) {
          // Container render Ø´Ø¯Ù‡ - Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø³ØªÙ‚ÛŒÙ…
          const scale = containerWidth / img.width;
          const scaledHeight = img.height * scale;
          setContainerHeight(scaledHeight);
        } else {
          // Container Ù‡Ù†ÙˆØ² render Ù†Ø´Ø¯Ù‡ - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¹Ø±Ø¶ ØªØ®Ù…ÛŒÙ†ÛŒ
          if (typeof window !== 'undefined') {
            const viewportWidth = window.innerWidth;
            const estimatedWidth = Math.min(viewportWidth - 100, 1200);
            const scale = estimatedWidth / img.width;
            const scaledHeight = img.height * scale;
            setContainerHeight(scaledHeight);
          }
        }
      } else {
        // Container ref Ù‡Ù†ÙˆØ² ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¹Ø±Ø¶ ØªØ®Ù…ÛŒÙ†ÛŒ
        if (typeof window !== 'undefined') {
          const viewportWidth = window.innerWidth;
          const estimatedWidth = Math.min(viewportWidth - 100, 1200);
          const scale = estimatedWidth / img.width;
          const scaledHeight = img.height * scale;
          setContainerHeight(scaledHeight);
        }
      }
      
      // Update height again after a short delay to ensure accuracy
      requestAnimationFrame(() => {
        setTimeout(updateHeight, 0);
      });
      
      console.log('[AdvancedCephalometricVisualizer] Image loaded successfully:', `${imageUrl.substring(0, 50)  }...`);
    };
    
    img.onerror = (error) => {
      console.error('[AdvancedCephalometricVisualizer] Error loading image:', error);
      console.error('[AdvancedCephalometricVisualizer] Failed URL:', `${imageUrl.substring(0, 50)  }...`);
      setIsImageLoaded(false);
    };
    
    img.src = imageUrl;
    
    // Add resize listener
    window.addEventListener('resize', updateHeight);
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', updateHeight);
    };
  }, [imageUrl]);

  // Update container height when image is loaded and container is available - use useLayoutEffect to prevent layout shift
  useLayoutEffect(() => {
    if (isImageLoaded && imageRef.current && containerRef.current) {
      const updateHeight = () => {
        if (!containerRef.current || !imageRef.current) return;
        
        const rect = containerRef.current.getBoundingClientRect();
        const containerWidth = rect.width;
        const img = imageRef.current;
        
        // ğŸ”§ FIX: Ø§Ú¯Ø± container Ù‡Ù†ÙˆØ² render Ù†Ø´Ø¯Ù‡ØŒ Ø§Ø² Ø¹Ø±Ø¶ viewport Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
        if (containerWidth === 0 && typeof window !== 'undefined') {
          const viewportWidth = window.innerWidth;
          const estimatedWidth = Math.min(viewportWidth - 100, 1200);
          if (img && img.complete && img.naturalHeight > 0) {
            const scale = estimatedWidth / img.width;
            const scaledHeight = img.height * scale;
            setContainerHeight(scaledHeight);
          }
          return;
        }
        
        if (img && img.complete && img.naturalHeight > 0 && containerWidth > 0) {
          // Ù…Ø­Ø§Ø³Ø¨Ù‡ scale Ø¨Ø±Ø§ÛŒ fit Ú©Ø±Ø¯Ù† ØªØµÙˆÛŒØ± Ø¯Ø± Ø¹Ø±Ø¶ container
          const scale = containerWidth / img.width;
          // Ø§Ø±ØªÙØ§Ø¹ ÙˆØ§Ù‚Ø¹ÛŒ ØªØµÙˆÛŒØ± Ø¨Ø§ scale
          const scaledHeight = img.height * scale;
          // ØªÙ†Ø¸ÛŒÙ… Ø§Ø±ØªÙØ§Ø¹ container Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ Ø§Ø±ØªÙØ§Ø¹ scaled ØªØµÙˆÛŒØ± (Ø¨Ø¯ÙˆÙ† minimum Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ Ú©Ø§Ù…Ù„)
          setContainerHeight(scaledHeight);
        }
      };
      
      // ğŸ”§ FIX: Update height immediately (useLayoutEffect runs before paint)
      // Ø§ÛŒÙ† Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ Ø§Ø±ØªÙØ§Ø¹ Ø§Ø² Ù‡Ù…Ø§Ù† Ø§Ø¨ØªØ¯Ø§ Ø¯Ø±Ø³Øª Ø¨Ø§Ø´Ø¯
      updateHeight();
      
      // Use ResizeObserver for more accurate width tracking
      const resizeObserver = new ResizeObserver(() => {
        updateHeight();
      });
      
      if (containerRef.current) {
        resizeObserver.observe(containerRef.current);
      }
      
      // Also listen to window resize events as fallback
      window.addEventListener('resize', updateHeight);
      
      return () => {
        resizeObserver.disconnect();
        window.removeEventListener('resize', updateHeight);
      };
    }
  }, [isImageLoaded]); // zoom Ù†Ø¨Ø§ÛŒØ¯ Ø§Ø±ØªÙØ§Ø¹ container Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡Ø¯


  // Helper to find landmark by name (case-insensitive and partial match)
  const findLandmarkInLms = useCallback((lms, names) => {
    // Direct match
    for (const name of names) {
      if (lms[name]) return lms[name];
    }
    
    // Case-insensitive match
    const landmarkKeys = Object.keys(lms);
    for (const name of names) {
      const lowerName = name.toLowerCase();
      const found = landmarkKeys.find(key => key.toLowerCase() === lowerName);
      if (found) return lms[found];
    }
    
    // Partial match for common variations
    const partialMatches = {
      'Or': ['or', 'orbit', 'orbitale'],
      'Po': ['po', 'porion'],
      'L1': ['l1', 'lower', 'incisor', 'li', 'lower_incisor'],
      'U1': ['u1', 'upper', 'incisor', 'ui', 'upper_incisor'],
      'Me': ['me', 'menton'],
      'Go': ['go', 'gonion'],
      'S': ['s', 'sella'],
      'N': ['n', 'nasion'],
      'A': ['a', 'point_a', 'point a'],
      'B': ['b', 'point_b', 'point b'],
      'Gn': ['gn', 'gnathion'],
      'Pog': ['pog', 'pogonion'],
      'ANS': ['ans', 'anterior'],
      'PNS': ['pns', 'posterior'],
    };
    
    for (const name of names) {
      if (partialMatches[name]) {
        for (const partial of partialMatches[name]) {
          const found = landmarkKeys.find(key => 
            key.toLowerCase().includes(partial) || partial.includes(key.toLowerCase())
          );
          if (found) return lms[found];
        }
      }
    }
    
    return null;
  }, []);

  // ğŸ”§ FIX: Define helper functions BEFORE calculateMeasurements to avoid TDZ errors
  // Calculate angle between three points
  const calculateAngle = useCallback((p1, vertex, p2) => {
    const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
    const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);
    let angle = (angle2 - angle1) * (180 / Math.PI);
    
    // Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ [0, 360]
    if (angle < 0) angle += 360;
    
    // Ù‡Ù…ÛŒØ´Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ú©ÙˆÚ†Ú©â€ŒØªØ± Ø±Ø§ Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù† (Ø¨ÛŒÙ† 0 ØªØ§ 180)
    if (angle > 180) {
      angle = 360 - angle;
    }
    
    return angle;
  }, []);

  // Calculate line angle relative to horizontal
  const calculateLineAngle = useCallback((p1, p2) => {
    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI);
    return angle;
  }, []);
  
  // Calculate angle between two lines (for FMA, etc.)
  const calculateAngleBetweenLines = useCallback((line1Start, line1End, line2Start, line2End) => {
    // Calculate direction vectors for both lines
    const v1x = line1End.x - line1Start.x;
    const v1y = line1End.y - line1Start.y;
    const v2x = line2End.x - line2Start.x;
    const v2y = line2End.y - line2Start.y;
    
    // Calculate dot product
    const dotProduct = v1x * v2x + v1y * v2y;
    
    // Calculate magnitudes
    const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
    const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
    
    // Avoid division by zero
    if (mag1 === 0 || mag2 === 0) return 0;
    
    // Calculate angle in radians, then convert to degrees
    const cosAngle = dotProduct / (mag1 * mag2);
    // Clamp to [-1, 1] to avoid NaN from Math.acos
    const clampedCos = Math.max(-1, Math.min(1, cosAngle));
    let angle = Math.acos(clampedCos) * (180 / Math.PI);
    
    // Ensure angle is between 0 and 180
    if (angle > 180) angle = 360 - angle;
    
    return angle;
  }, []);

  // Calculate cephalometric measurements
  const calculateMeasurements = useCallback((lms) => {
    const measures = {};
    
    // Helper function to normalize angle to 0-180 range
    const normalizeAngle = (angle) => Math.max(0, Math.min(180, angle));
    
    try {
      // Find common landmarks once at the beginning
      const s = findLandmarkInLms(lms, ['S', 's', 'Sella', 'sella']);
      const n = findLandmarkInLms(lms, ['N', 'n', 'Nasion', 'nasion']);
      const a = findLandmarkInLms(lms, ['A', 'a']);
      const b = findLandmarkInLms(lms, ['B', 'b']);
      const or = findLandmarkInLms(lms, ['Or', 'or', 'OR', 'orbitale', 'Orbitale']);
      const po = findLandmarkInLms(lms, ['Po', 'po', 'PO', 'porion', 'Porion']);
      const go = findLandmarkInLms(lms, ['Go', 'go', 'GO', 'gonion', 'Gonion']);
      const me = findLandmarkInLms(lms, ['Me', 'me', 'ME', 'menton', 'Menton']);
      const gn = findLandmarkInLms(lms, ['Gn', 'gn', 'GN', 'gnathion', 'Gnathion']);
      const u1 = findLandmarkInLms(lms, ['U1', 'u1', 'upper_incisor', 'Upper Incisor']);
      const l1 = findLandmarkInLms(lms, ['L1', 'l1', 'lower_incisor', 'Lower_incisor', 'lower incisor']);
      
      // SNA angle
      if (s && n && a) {
        measures.SNA = calculateAngle(s, n, a);
      }
      
      // SNB angle
      if (s && n && b) {
        measures.SNB = calculateAngle(s, n, b);
      }
      
      // ANB angle
      if (measures.SNA && measures.SNB) {
        measures.ANB = measures.SNA - measures.SNB;
      }
      
      // FMA (Frankfort-Mandibular Angle)
      if (or && po && me && go) {
        measures.FMA = normalizeAngle(calculateAngleBetweenLines(me, go, or, po));
      }
      
      // GoGnSN
      if (s && n && go && gn) {
        const snAngle = calculateLineAngle(s, n);
        const gognAngle = calculateLineAngle(go, gn);
        measures.GoGnSN = Math.abs(snAngle - gognAngle);
      }
      
      // U1-SN (Upper incisor to SN angle)
      // Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· U1-U1A Ùˆ Ø®Ø· S-N
      const u1a = findLandmarkInLms(lms, ['U1A', 'u1a', 'U1a', 'upper_incisor_apex', 'Upper_incisor_apex']);
      if (s && n && u1 && u1a) {
        // Ø®Ø· Ø§ÙˆÙ„: U1-U1A (Incisor line)
        // Ø®Ø· Ø¯ÙˆÙ…: S-N (SN line)
        measures['U1-SN'] = calculateAngleBetweenLines(u1, u1a, s, n);
      } else if (s && n && u1) {
        // Fallback: Ø§Ú¯Ø± U1A Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ø§Ø² Ù†Ù‚Ø·Ù‡ U1 Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        measures['U1-SN'] = calculateAngle(u1, n, s);
      }
      
      // IMPA (Incisor Mandibular Plane Angle)
      // Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± (Go-Me) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ LIA-LIT)
      const lia = findLandmarkInLms(lms, ['LIA', 'lia', 'Lia', 'L1A', 'l1a', 'L1a', 'lower_incisor_apex', 'Lower_incisor_apex', 'lower incisor apex']);
      const lit = findLandmarkInLms(lms, ['LIT', 'lit', 'Lit', 'L1', 'l1', 'lower_incisor_tip', 'Lower_incisor_tip', 'lower incisor tip']);
      
      if (go && me && lia && lit) {
        // Ø®Ø· Ø§ÙˆÙ„: Go-Me (Mandibular Plane)
        // Ø®Ø· Ø¯ÙˆÙ…: LIA-LIT (Incisor line)
        measures.IMPA = normalizeAngle(calculateAngleBetweenLines(me, go, lia, lit));
      } else if (go && me && l1) {
        // Fallback: Ø§Ú¯Ø± LIA Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ø§Ø² L1 Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        // Ø§Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø®Ø·ØŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¯Ùˆ Ù†Ù‚Ø·Ù‡ Ø¯Ø§Ø±ÛŒÙ…
        // Ù¾Ø³ Ø§Ø² Me Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù†Ù‚Ø·Ù‡ Ø¯ÙˆÙ… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… (L1-Me)
        // Ø§Ù…Ø§ Ø§ÛŒÙ† Ø¯Ø±Ø³Øª Ù†ÛŒØ³Øª Ú†ÙˆÙ† Me Ø±ÙˆÛŒ Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± Ø§Ø³Øª
        // Ø¨Ù‡ØªØ± Ø§Ø³Øª Ø§Ø² L1A Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ… Ø§Ú¯Ø± Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯
        const l1a = findLandmarkInLms(lms, ['L1A', 'l1a', 'L1a', 'LIA', 'lia', 'Lia', 'lower_incisor_apex', 'Lower_incisor_apex']);
        if (l1a) {
          // Ø®Ø· Ø§ÙˆÙ„: Go-Me (Mandibular Plane)
          // Ø®Ø· Ø¯ÙˆÙ…: L1A-L1 (Incisor line)
          measures.IMPA = normalizeAngle(calculateAngleBetweenLines(go, me, l1a, l1));
        } else {
          // Ø§Ú¯Ø± L1A Ù‡Ù… Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒÙ… IMPA Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†ÛŒÙ…
          // Ú†ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¯Ùˆ Ù†Ù‚Ø·Ù‡ Ø¨Ø±Ø§ÛŒ Ø®Ø· incisor Ø¯Ø§Ø±ÛŒÙ…
        }
      }
      
      // FMIA (Frankfort-Mandibular Incisor Angle)
      // Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Or-Po) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ LIA-LIT)
      if (or && po && lia && lit) {
        // Ø®Ø· Ø§ÙˆÙ„: Or-Po (Frankfort Horizontal)
        // Ø®Ø· Ø¯ÙˆÙ…: LIA-LIT (Incisor line)
        measures.FMIA = normalizeAngle(calculateAngleBetweenLines(po, or, lia, lit));
      } else if (or && po && l1) {
        // Fallback: Ø§Ú¯Ø± LIA Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ø§Ø² L1 Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        const l1a = findLandmarkInLms(lms, ['L1A', 'l1a', 'L1a', 'LIA', 'lia', 'Lia', 'lower_incisor_apex', 'Lower_incisor_apex']);
        if (l1a) {
          // Ø®Ø· Ø§ÙˆÙ„: Or-Po (Frankfort Horizontal)
          // Ø®Ø· Ø¯ÙˆÙ…: L1A-L1 (Incisor line)
          measures.FMIA = normalizeAngle(calculateAngleBetweenLines(or, po, l1a, l1));
        }
      }
      
      // L1-MP (Lower incisor to Mandibular Plane angle) - same as IMPA
      if (measures.IMPA) {
        measures['L1-MP'] = measures.IMPA;
      } else if (go && me && l1) {
        measures['L1-MP'] = normalizeAngle(calculateAngle(l1, me, go));
      }
      
      // Interincisal Angle
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² u1a Ú©Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø§Ø³Øª
      const l1a = findLandmarkInLms(lms, ['L1A', 'l1a', 'L1a', 'lower_incisor_apex', 'Lower_incisor_apex']);
      if (u1 && u1a && l1 && l1a) {
        measures.InterincisalAngle = calculateAngleBetweenLines(u1, u1a, l1, l1a);
      }
      
      // Ricketts Analysis - Facial Axis
      const ba = findLandmarkInLms(lms, ['Ba', 'ba', 'BA', 'basion', 'Basion']);
      const pt = findLandmarkInLms(lms, ['Pt', 'pt', 'PT', 'pterygoid', 'Pterygoid']);
      if (ba && pt && gn) {
        measures['Facial Axis'] = calculateAngle(gn, pt, ba);
      }
      
      // Ricketts Analysis - Facial Depth
      const pog = findLandmarkInLms(lms, ['Pog', 'pog', 'POG', 'pogonion', 'Pogonion']);
      if (n && pog && or && po) {
        measures['Facial Depth'] = calculateAngleBetweenLines(n, pog, or, po);
      }
      
      // Ricketts Analysis - Occlusal Plane Angle
      // Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ Occlusal Plane: Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÛŒÙ† LMT Ùˆ UMT
      const lmt = findLandmarkInLms(lms, ['LMT', 'lmt', 'lower_molar', 'Lower Molar', 'L6', 'l6']);
      const umt = findLandmarkInLms(lms, ['UMT', 'umt', 'upper_molar', 'Upper Molar', 'U6', 'u6']);
      if (l1 && lmt && s && n) {
        // Ø§Ú¯Ø± UMT Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯ØŒ Ø§Ø² Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        if (umt) {
          const occlusalEndPoint = {
            x: (lmt.x + umt.x) / 2,
            y: (lmt.y + umt.y) / 2
          };
          measures['Occlusal Plane Angle'] = calculateAngleBetweenLines(l1, occlusalEndPoint, s, n);
        } else {
          // Fallback: Ø§Ú¯Ø± UMT Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ Ø§Ø² LMT Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
          measures['Occlusal Plane Angle'] = calculateAngleBetweenLines(l1, lmt, s, n);
        }
      }
      
      // Ricketts Analysis - Cranial Deflection
      if (ba && n && s) {
        const cranialDeflectionAngle = calculateAngle(ba, n, s);
        measures['Cranial Deflection'] = typeof cranialDeflectionAngle === 'number' 
          ? Math.round(cranialDeflectionAngle * 10) / 10 
          : cranialDeflectionAngle;
      }
      
    } catch (err) {
      console.error('Error calculating measurements:', err);
    }
    
    return measures;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [findLandmarkInLms, calculateAngle, calculateLineAngle, calculateAngleBetweenLines]);

  // ğŸ”§ FIX: Use useMemo instead of useEffect + setState to prevent infinite loops
  // This calculates measurements only when landmarks change, without causing re-renders
  // calculateMeasurements is stable (useCallback with stable dependencies), so we can safely use it
  const calculatedMeasurements = useMemo(() => {
    if (Object.keys(landmarks).length >= 3) {
      return calculateMeasurements(landmarks);
    }
    return {};
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [landmarks]); // Only depend on landmarks - calculateMeasurements is stable

  // ğŸ”§ FIX: Update measurements state only when calculatedMeasurements actually changes
  // Use a ref to track previous value and avoid unnecessary updates during drag
  // useEffect Ø¨Ø±Ø§ÛŒ setMeasurements Ø­Ø°Ù Ø´Ø¯ - measurements Ø§Ø² prop Ù…ÛŒâ€ŒØ¢ÛŒØ¯
  // const prevMeasurementsRef = useRef({});
  // useEffect(() => {
  //   const measurementsChanged = JSON.stringify(calculatedMeasurements) !== JSON.stringify(prevMeasurementsRef.current);
  //   if (measurementsChanged) {
  //     setMeasurements(calculatedMeasurements);
  //     prevMeasurementsRef.current = calculatedMeasurements;
  //   }
  // }, [calculatedMeasurements]);

  // ğŸ”§ FIX: Helper functions (calculateAngle, calculateLineAngle, calculateAngleBetweenLines) 
  // are now defined above (before calculateMeasurements) to avoid TDZ errors

  // Get landmark position on canvas
  const getLandmarkCanvasPosition = useCallback((lm) => {
    const canvas = canvasRef.current;
    const image = imageRef.current;
    if (!canvas || !image) return null;

    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return null;

    // ğŸ”§ FIX: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² display size (Ù†Ù‡ canvas.width/height Ú©Ù‡ Ø´Ø§Ù…Ù„ DPR Ø§Ø³Øª)
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = rect.width;
    const displayHeight = rect.height;

    const scale = Math.min(
      displayWidth / image.width,
      displayHeight / image.height
    ) * zoom;

    const scaledWidth = image.width * scale;
    const scaledHeight = image.height * scale;
    const x = (displayWidth - scaledWidth) / 2 + pan.x;
    const y = (displayHeight - scaledHeight) / 2 + pan.y;

    return {
      x: x + (lm.x * scale),
      y: y + (lm.y * scale),
      scale
    };
  }, [zoom, pan]);

  // Get image coordinates from canvas position
  const getImageCoordinates = (canvasX, canvasY) => {
    const canvas = canvasRef.current;
    const image = imageRef.current;
    if (!canvas || !image) return null;

    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return null;

    // ğŸ”§ FIX: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² display size (Ù†Ù‡ canvas.width/height Ú©Ù‡ Ø´Ø§Ù…Ù„ DPR Ø§Ø³Øª)
    const displayWidth = rect.width;
    const displayHeight = rect.height;

    const scale = Math.min(
      displayWidth / image.width,
      displayHeight / image.height
    ) * zoom;

    const scaledWidth = image.width * scale;
    const scaledHeight = image.height * scale;
    const x = (displayWidth - scaledWidth) / 2 + pan.x;
    const y = (displayHeight - scaledHeight) / 2 + pan.y;

    return {
      x: (canvasX - x) / scale,
      y: (canvasY - y) / scale
    };
  };

  // Helper function to normalize landmark name for LANDMARK_DESCRIPTIONS lookup
  const normalizeLandmarkNameForDescription = (landmarkName) => {
    if (!landmarkName) return null;
    
    // First, check if the exact name exists
    if (LANDMARK_DESCRIPTIONS[landmarkName]) {
      return landmarkName;
    }
    
    // Normalize variations of N' and Me'
    const normalized = landmarkName.trim();
    
    // Check for N variations (N` is the correct form, check backtick first)
    if (normalized === 'N`' || normalized === 'N\'' || normalized === 'Nprime' || 
        normalized === 'N` ' || normalized === 'N\' ' || normalized === 'Nprime ' ||
        normalized.toLowerCase() === 'n`' || normalized.toLowerCase() === 'n\'' || 
        normalized.toLowerCase() === 'nprime' || normalized.toLowerCase() === 'n`' ||
        normalized.toLowerCase() === 'n\'') {
      // Try backtick first (correct form), then apostrophe, then other variations
      if (LANDMARK_DESCRIPTIONS['N`']) return 'N`';
      if (LANDMARK_DESCRIPTIONS['N\'']) return 'N\'';
      if (LANDMARK_DESCRIPTIONS.Nprime) return 'Nprime';
    }
    
    // Check for Me variations (handle all forms: Me`, Me', Meâ€², MeSoft, Meprime)
    if (normalized === 'Me`' || normalized === 'Me\'' || normalized === 'Meâ€²' || normalized === 'MeSoft' || 
        normalized === 'Meprime' || normalized === 'Me` ' || normalized === 'Me\' ' || normalized === 'Meâ€² ' ||
        normalized.toLowerCase() === 'me`' || normalized.toLowerCase() === 'me\'' || normalized.toLowerCase() === 'meâ€²' ||
        normalized.toLowerCase() === 'mesoft' || normalized.toLowerCase() === 'meprime' ||
        normalized.toLowerCase() === 'me`' || normalized.toLowerCase() === 'me\'') {
      // Try all variations in order: backtick, apostrophe, prime, then other variations
      if (LANDMARK_DESCRIPTIONS['Me`']) return 'Me`';
      if (LANDMARK_DESCRIPTIONS['Me\'']) return 'Me\'';
      if (LANDMARK_DESCRIPTIONS['Meâ€²']) return 'Meâ€²';
      if (LANDMARK_DESCRIPTIONS.MeSoft) return 'MeSoft';
      if (LANDMARK_DESCRIPTIONS.Meprime) return 'Meprime';
    }
    
    // Check for Pog variations (handle all forms: Pog`, Pog', Pogâ€², Pogprime)
    if (normalized === 'Pog`' || normalized === 'Pog\'' || normalized === 'Pogâ€²' || normalized === 'Pogprime' ||
        normalized.toLowerCase() === 'pog`' || normalized.toLowerCase() === 'pog\'' || normalized.toLowerCase() === 'pogâ€²' ||
        normalized.toLowerCase() === 'pogprime') {
      // Try all variations in order: backtick, apostrophe, prime, then other variations
      if (LANDMARK_DESCRIPTIONS['Pog`']) return 'Pog`';
      if (LANDMARK_DESCRIPTIONS['Pog\'']) return 'Pog\'';
      if (LANDMARK_DESCRIPTIONS['Pogâ€²']) return 'Pogâ€²';
      if (LANDMARK_DESCRIPTIONS.Pogprime) return 'Pogprime';
    }
    
    // Check for Gn variations (handle all forms: Gn`, Gn', Gnâ€², Gnprime)
    if (normalized === 'Gn`' || normalized === 'Gn\'' || normalized === 'Gnâ€²' || normalized === 'Gnprime' ||
        normalized.toLowerCase() === 'gn`' || normalized.toLowerCase() === 'gn\'' || normalized.toLowerCase() === 'gnâ€²' ||
        normalized.toLowerCase() === 'gnprime') {
      // Try all variations in order: backtick, apostrophe, prime
      if (LANDMARK_DESCRIPTIONS['Gn`']) return 'Gn`';
      if (LANDMARK_DESCRIPTIONS['Gn\'']) return 'Gn\'';
      if (LANDMARK_DESCRIPTIONS['Gnâ€²']) return 'Gnâ€²';
    }
    
    // Check for UL variations (handle all forms: UL`, UL', ULâ€², ULprime)
    if (normalized === 'UL`' || normalized === 'UL\'' || normalized === 'ULâ€²' || normalized === 'ULprime' ||
        normalized.toLowerCase() === 'ul`' || normalized.toLowerCase() === 'ul\'' || normalized.toLowerCase() === 'ulâ€²' ||
        normalized.toLowerCase() === 'ulprime') {
      // Try all variations in order: backtick, apostrophe, prime, then other variations
      if (LANDMARK_DESCRIPTIONS['UL`']) return 'UL`';
      if (LANDMARK_DESCRIPTIONS['UL\'']) return 'UL\'';
      if (LANDMARK_DESCRIPTIONS['ULâ€²']) return 'ULâ€²';
      if (LANDMARK_DESCRIPTIONS.ULprime) return 'ULprime';
    }
    
    // Check for LL variations (handle all forms: LL`, LL', LLâ€², LLprime)
    if (normalized === 'LL`' || normalized === 'LL\'' || normalized === 'LLâ€²' || normalized === 'LLprime' ||
        normalized.toLowerCase() === 'll`' || normalized.toLowerCase() === 'll\'' || normalized.toLowerCase() === 'llâ€²' ||
        normalized.toLowerCase() === 'llprime') {
      // Try all variations in order: backtick, apostrophe, prime, then other variations
      if (LANDMARK_DESCRIPTIONS['LL`']) return 'LL`';
      if (LANDMARK_DESCRIPTIONS['LL\'']) return 'LL\'';
      if (LANDMARK_DESCRIPTIONS['LLâ€²']) return 'LLâ€²';
      if (LANDMARK_DESCRIPTIONS.LLprime) return 'LLprime';
    }
    
    // Return original name if no match found
    return landmarkName;
  };

  // Find landmark at position
  const findLandmarkAtPosition = (canvasX, canvasY) => {
    for (const [name, coords] of Object.entries(landmarks)) {
      const pos = getLandmarkCanvasPosition(coords);
      if (!pos) continue;

      const distance = Math.sqrt(
        (pos.x - canvasX)**2 + (pos.y - canvasY)**2
      );

      if (distance <= actualPointSize + 5) {
        return name;
      }
    }
    return null;
  };


  // Draw canvas
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const image = imageRef.current;
    
    // Return early if no canvas or image (but still allow coordinate system to show)
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const rect = containerRef.current?.getBoundingClientRect();
    
    if (!rect) return;
    
    // ØªØ¹Ø±ÛŒÙ Ù…Ø´ØªØ±Ú© canvasRect Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± ØªÙ…Ø§Ù… ØªÙˆØ§Ø¨Ø¹
    const canvasRect = rect;
    const canvasHeight = canvasRect.height || canvas.height;
    const canvasWidth = canvasRect.width || canvas.width;
    
    // Helper functions for drawing (defined inside drawCanvas to access ctx, zoom, etc.)
    
    // Map Ø¨Ø±Ø§ÛŒ track Ú©Ø±Ø¯Ù† ØªØ¹Ø¯Ø§Ø¯ label Ù‡Ø§ÛŒ Ù‡Ø± vertex (Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overlap)
    // Ø§ÛŒÙ† Map Ø¯Ø± Ù‡Ø± render reset Ù…ÛŒâ€ŒØ´ÙˆØ¯
    const vertexLabelCounts = new Map();
    const getVertexKey = (vertex) => {
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø®ØªØµØ§Øª rounded Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ vertex Ù‡Ø§ÛŒ Ù…Ø´Ø§Ø¨Ù‡
      const threshold = 5; // threshold Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ vertex Ù‡Ø§ÛŒ Ù…Ø´Ø§Ø¨Ù‡ (Ø¯Ø± pixels)
      const roundedX = Math.round(vertex.x / threshold) * threshold;
      const roundedY = Math.round(vertex.y / threshold) * threshold;
      return `${roundedX},${roundedY}`;
    };
    
    // Helper functions for text styling
    const setTextStyle = (fontSize, textColor = '#FFD700') => {
      ctx.font = `bold ${fontSize * zoom}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = textColor;
    };
    
    // Ø³ÛŒØ³ØªÙ… Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù‡Ù…â€ŒÙ¾ÙˆØ´Ø§Ù†ÛŒ label Ù‡Ø§
    const drawTextWithBackground = (text, x, y, fontSize, textColor = '#FFD700') => {
      setTextStyle(fontSize, textColor);
      // Shadow/border Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø¨Ù‡ØªØ± - Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      const baseLabelLineWidth = isMobile ? 1 : 2;
      ctx.lineWidth = baseLabelLineWidth * zoom;
      ctx.strokeText(text, x, y);
      ctx.fillText(text, x, y);
    };
    
    const drawRotatedTextWithBackground = (text, x, y, angle, fontSize, textColor = '#FFD700') => {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      setTextStyle(fontSize, textColor);
      // Shadow/border Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø¨Ù‡ØªØ± - Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      const baseLabelLineWidth = isMobile ? 1 : 2;
      ctx.lineWidth = baseLabelLineWidth * zoom;
      ctx.strokeText(text, 0, 0);
      ctx.fillText(text, 0, 0);
      ctx.restore();
    };
    
    const drawLine = (startPos, endPos, color, lineWidth, dashPattern = []) => {
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.setLineDash(dashPattern);
      ctx.beginPath();
      ctx.moveTo(startPos.x, startPos.y);
      ctx.lineTo(endPos.x, endPos.y);
      ctx.stroke();
      ctx.setLineDash([]);
    };
    
    const drawAngle = (p1, vertex, p2, value, label, color, fontSize, radius, landmark1Name = null, landmark2Name = null, drawDashedExtensions = true) => {
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§ Ù†Ø³Ø¨Øª Ø¨Ù‡ vertex
      let angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
      let angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);
      
      // Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ [0, 2Ï€]
      if (angle1 < 0) angle1 += 2 * Math.PI;
      if (angle2 < 0) angle2 += 2 * Math.PI;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªÙØ§ÙˆØª Ø²Ø§ÙˆÛŒÙ‡ (Ù‡Ù…ÛŒØ´Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ú©ÙˆÚ†Ú©â€ŒØªØ±)
      // Ø§ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & Burstone (Facial Convexity) Ù…Ù‡Ù… Ø§Ø³Øª
      let angleDiff = angle2 - angle1;
      if (angleDiff < 0) angleDiff += 2 * Math.PI;
      
      // Ù‡Ù…ÛŒØ´Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ú©ÙˆÚ†Ú©â€ŒØªØ± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù† (Ø¨ÛŒÙ† 0 ØªØ§ Ï€)
      // Ø§Ú¯Ø± angleDiff > Ï€ØŒ Ø§Ø² Ø·Ø±Ù Ø¯ÛŒÚ¯Ø± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      if (angleDiff > Math.PI) {
        angleDiff = 2 * Math.PI - angleDiff;
        // Ù…Ø¹Ú©ÙˆØ³ Ú©Ø±Ø¯Ù† ØªØ±ØªÛŒØ¨ Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©â€ŒØªØ±
        const temp = angle1;
        angle1 = angle2;
        angle2 = temp;
        // Ø¨Ø¹Ø¯ Ø§Ø² Ù…Ø¹Ú©ÙˆØ³ØŒ Ø§Ú¯Ø± angle2 < angle1 Ø´Ø¯ØŒ Ø¨Ø§ÛŒØ¯ 2Ï€ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒÙ…
        if (angle2 < angle1) {
          angle2 += 2 * Math.PI;
        }
      } else {
        // Ø§Ú¯Ø± angle2 < angle1 Ø¨Ø§Ø´Ø¯ØŒ Ø¨Ø§ÛŒØ¯ 2Ï€ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒÙ…
        if (angle2 < angle1) {
          angle2 += 2 * Math.PI;
        }
      }
      
      // Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø¨Ø§ gradient Ø±Ù†Ú¯ Ù†Ù‚Ø§Ø· Ùˆ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø¯Ùˆ Ø·Ø±Ù (Ù…Ø´Ø§Ø¨Ù‡ steiner)
      const rect = containerRef.current?.getBoundingClientRect();
      const displayWidth = rect?.width || canvas.width;
      const displayHeight = rect?.height || canvas.height;
      const baseExtend = Math.max(displayWidth, displayHeight) + 100;
      const scaledExtend = baseExtend * zoom;
      
      const getLineColorForPoints = (startName, endName, startPos, endPos) => {
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² cache Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¹Ù…Ù„Ú©Ø±Ø¯
        const startColor = landmarkColorCache.getColorForLandmark(startName);
        const endColor = landmarkColorCache.getColorForLandmark(endName);
        
        if (useGradientLines && startPos && endPos) {
          const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
          gradient.addColorStop(0, startColor);
          gradient.addColorStop(1, endColor);
          return gradient;
        }
        return startColor;
      };
      
      // Ø±Ø³Ù… Ø®Ø· p1-vertex: Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ solidØŒ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Ú†ÛŒÙ†
      const line1Dx = vertex.x - p1.x;
      const line1Dy = vertex.y - p1.y;
      const line1Length = Math.sqrt(line1Dx * line1Dx + line1Dy * line1Dy);
      if (line1Length > 0) {
        const line1DirX = line1Dx / line1Length;
        const line1DirY = line1Dy / line1Length;
        const line1ExtendedStart = {
          x: p1.x - line1DirX * scaledExtend,
          y: p1.y - line1DirY * scaledExtend
        };
        const line1ExtendedEnd = {
          x: vertex.x + line1DirX * scaledExtend,
          y: vertex.y + line1DirY * scaledExtend
        };
        
        // Ø±Ù†Ú¯ gradient Ø§Ø² Ù†Ù‚Ø§Ø·
        const line1Color = getLineColorForPoints(landmark1Name || 'default', 'vertex', p1, vertex);
        
        // Ø±Ø³Ù… Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ (solid)
        ctx.strokeStyle = line1Color;
        ctx.lineWidth = actualLineWidth;
        ctx.setLineDash([]); // solid
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(vertex.x, vertex.y);
        ctx.stroke();
        
        // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² p1 (Ø®Ø· Ú†ÛŒÙ†) - ÙÙ‚Ø· Ø§Ú¯Ø± drawDashedExtensions true Ø¨Ø§Ø´Ø¯
        if (drawDashedExtensions) {
          ctx.strokeStyle = line1Color;
          ctx.lineWidth = actualLineWidth;
          ctx.setLineDash([5 * zoom, 5 * zoom]); // Ø®Ø· Ú†ÛŒÙ†
          ctx.beginPath();
          ctx.moveTo(line1ExtendedStart.x, line1ExtendedStart.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
          
          // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø¨Ù‡ vertex (Ø®Ø· Ú†ÛŒÙ†)
          ctx.beginPath();
          ctx.moveTo(vertex.x, vertex.y);
          ctx.lineTo(line1ExtendedEnd.x, line1ExtendedEnd.y);
          ctx.stroke();
        }
      }
      
      // Ø±Ø³Ù… Ø®Ø· vertex-p2: Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ solidØŒ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Ú†ÛŒÙ†
      const line2Dx = p2.x - vertex.x;
      const line2Dy = p2.y - vertex.y;
      const line2Length = Math.sqrt(line2Dx * line2Dx + line2Dy * line2Dy);
      if (line2Length > 0) {
        const line2DirX = line2Dx / line2Length;
        const line2DirY = line2Dy / line2Length;
        const line2ExtendedStart = {
          x: vertex.x - line2DirX * scaledExtend,
          y: vertex.y - line2DirY * scaledExtend
        };
        const line2ExtendedEnd = {
          x: p2.x + line2DirX * scaledExtend,
          y: p2.y + line2DirY * scaledExtend
        };
        
        // Ø±Ù†Ú¯ gradient Ø§Ø² Ù†Ù‚Ø§Ø·
        const line2Color = getLineColorForPoints('vertex', landmark2Name || 'default', vertex, p2);
        
        // Ø±Ø³Ù… Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ (solid)
        ctx.strokeStyle = line2Color;
        ctx.lineWidth = actualLineWidth;
        ctx.setLineDash([]); // solid
        ctx.beginPath();
        ctx.moveTo(vertex.x, vertex.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² vertex (Ø®Ø· Ú†ÛŒÙ†) - ÙÙ‚Ø· Ø§Ú¯Ø± drawDashedExtensions true Ø¨Ø§Ø´Ø¯
        if (drawDashedExtensions) {
          ctx.strokeStyle = line2Color;
          ctx.lineWidth = actualLineWidth;
          ctx.setLineDash([5 * zoom, 5 * zoom]); // Ø®Ø· Ú†ÛŒÙ†
          ctx.beginPath();
          ctx.moveTo(line2ExtendedStart.x, line2ExtendedStart.y);
          ctx.lineTo(vertex.x, vertex.y);
          ctx.stroke();
          
          // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø¨Ù‡ p2 (Ø®Ø· Ú†ÛŒÙ†)
          ctx.beginPath();
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(line2ExtendedEnd.x, line2ExtendedEnd.y);
          ctx.stroke();
        }
      }
      
      // Ø±Ø³Ù… Ú©Ù…Ø§Ù† Ø²Ø§ÙˆÛŒÙ‡ Ø¨Ù‡ Ø±Ù†Ú¯ Ø²Ø±Ø¯ (Ù…Ø´Ø§Ø¨Ù‡ steiner)
      ctx.strokeStyle = '#FFD700'; // Ø²Ø±Ø¯
      ctx.lineWidth = actualLineWidth;
      ctx.setLineDash([]); // Ø®Ø· ØµØ§Ù Ø¨Ø±Ø§ÛŒ Ú©Ù…Ø§Ù†
      ctx.beginPath();
      ctx.arc(vertex.x, vertex.y, radius, angle1, angle2);
      ctx.stroke();
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ label (Ø¨Ø§Ù„Ø§ÛŒ Ø±Ø£Ø³) Ø¨Ø§ offset Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overlap
      const baseOffset = (isMobile ? 12 : 18) * zoom;
      const labelSpacing = (isMobile ? 20 : 25) * zoom; // ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† label Ù‡Ø§
      
      // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
      if (analysisType !== 'general' && analysisType !== 'all') {
        const vertexKey = getVertexKey(vertex);
        const labelIndex = vertexLabelCounts.get(vertexKey) || 0;
        vertexLabelCounts.set(vertexKey, labelIndex + 1);
        
        // Ù…Ø­Ø§Ø³Ø¨Ù‡ offset Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ¹Ø¯Ø§Ø¯ label Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
        const verticalOffset = baseOffset + (labelIndex * labelSpacing);
        
        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† label Ø¯Ø± Ø¬Ù‡Øª Ù…Ù†Ø§Ø³Ø¨
        const midAngle = (angle1 + angle2) / 2;
        const labelRadius = radius + verticalOffset;
        const labelX = vertex.x + Math.cos(midAngle - Math.PI / 2) * labelRadius;
        const labelY = vertex.y + Math.sin(midAngle - Math.PI / 2) * labelRadius;
        
        const labelText = value !== undefined ? `${label}: ${typeof value === 'number' ? value.toFixed(1) : value}Â°` : label;
        
        drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
      }
    };
    
    const drawDistance = (startPos, endPos, value, label, color, fontSize) => {
      // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
      if (analysisType === 'general' || analysisType === 'all') {
        return;
      }
      const midX = (startPos.x + endPos.x) / 2;
      const midY = (startPos.y + endPos.y) / 2;
      const labelText = value !== undefined ? `${label}: ${typeof value === 'number' ? value.toFixed(1) : value}mm` : label;
      drawTextWithBackground(labelText, midX, midY, fontSize, color);
    };
    
    const drawAngleBetweenLines = (line1Start, line1End, line2Start, line2End, value, label, color, fontSize, radius, landmark1StartName = null, landmark1EndName = null, landmark2StartName = null, landmark2EndName = null, drawDashedExtensions = true) => {
      // Find intersection point
      const x1 = line1Start.x; const y1 = line1Start.y;
      const x2 = line1End.x; const y2 = line1End.y;
      const x3 = line2Start.x; const y3 = line2Start.y;
      const x4 = line2End.x; const y4 = line2End.y;
      
      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < 1e-10) return; // Lines are parallel
      
      const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
      const intersectionX = x1 + t * (x2 - x1);
      const intersectionY = y1 + t * (y2 - y1);
      
      // Extend lines from both sides
      const rect = containerRef.current?.getBoundingClientRect();
      const displayWidth = rect?.width || canvas.width;
      const displayHeight = rect?.height || canvas.height;
      const baseExtend = Math.max(displayWidth, displayHeight) + 100;
      const scaledExtend = baseExtend * zoom;
      
      // Helper function for gradient lines
      const getLineColorForPoints = (startName, endName, startPos, endPos) => {
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² cache Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¹Ù…Ù„Ú©Ø±Ø¯
        const startColor = landmarkColorCache.getColorForLandmark(startName);
        const endColor = landmarkColorCache.getColorForLandmark(endName);
        
        if (useGradientLines && startPos && endPos) {
          const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
          gradient.addColorStop(0, startColor);
          gradient.addColorStop(1, endColor);
          return gradient;
        }
        return startColor;
      };
      
      // Ø±Ø³Ù… Ø®Ø· 1: Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ solidØŒ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Ú†ÛŒÙ†
      const line1Dx = line1End.x - line1Start.x;
      const line1Dy = line1End.y - line1Start.y;
      const line1Length = Math.sqrt(line1Dx * line1Dx + line1Dy * line1Dy);
      if (line1Length > 0) {
        const line1DirX = line1Dx / line1Length;
        const line1DirY = line1Dy / line1Length;
        const line1ExtendedStart = {
          x: intersectionX - line1DirX * scaledExtend,
          y: intersectionY - line1DirY * scaledExtend
        };
        const line1ExtendedEnd = {
          x: intersectionX + line1DirX * scaledExtend,
          y: intersectionY + line1DirY * scaledExtend
        };
        
        // Ø±Ù†Ú¯ gradient Ø§Ø² Ù†Ù‚Ø§Ø·
        const line1Color = getLineColorForPoints(landmark1StartName || 'default', landmark1EndName || 'default', line1Start, line1End);
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø¨ÛŒÙ† line1Start Ùˆ line1End Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        const line1ToIntersection = Math.sqrt((intersectionX - line1Start.x) ** 2 + (intersectionY - line1Start.y) ** 2);
        const line1ToEnd = Math.sqrt((line1End.x - line1Start.x) ** 2 + (line1End.y - line1Start.y) ** 2);
        const intersectionToEnd = Math.sqrt((line1End.x - intersectionX) ** 2 + (line1End.y - intersectionY) ** 2);
        const isIntersectionOnLine1 = Math.abs(line1ToIntersection + intersectionToEnd - line1ToEnd) < 1; // ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹ Ø±ÙˆÛŒ Ø®Ø· Ø§Ø³Øª
        
        // Ø±Ø³Ù… Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ (solid) - Ø§Ø² line1Start ØªØ§ line1End (Ú©Ø§Ù…Ù„)
        ctx.strokeStyle = line1Color;
        ctx.lineWidth = actualLineWidth;
        ctx.setLineDash([]); // solid
        ctx.beginPath();
        ctx.moveTo(line1Start.x, line1Start.y);
        ctx.lineTo(line1End.x, line1End.y);
        ctx.stroke();
        
        // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line1Start (Ø®Ø· Ú†ÛŒÙ†) - ÙÙ‚Ø· Ø§Ú¯Ø± drawDashedExtensions true Ø¨Ø§Ø´Ø¯
        if (drawDashedExtensions) {
          ctx.strokeStyle = line1Color;
          ctx.lineWidth = actualLineWidth;
          ctx.setLineDash([5 * zoom, 5 * zoom]); // Ø®Ø· Ú†ÛŒÙ†
          ctx.beginPath();
          ctx.moveTo(line1ExtendedStart.x, line1ExtendedStart.y);
          ctx.lineTo(line1Start.x, line1Start.y);
          ctx.stroke();
          
          // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line1End ØªØ§ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ (Ø®Ø· Ú†ÛŒÙ†) - Ø§Ú¯Ø± ØªÙ‚Ø§Ø·Ø¹ Ø®Ø§Ø±Ø¬ Ø§Ø² Ø®Ø· Ø¨Ø§Ø´Ø¯
          if (!isIntersectionOnLine1) {
          ctx.beginPath();
            ctx.moveTo(line1End.x, line1End.y);
            ctx.lineTo(intersectionX, intersectionY);
            ctx.stroke();
          } else {
            // Ø§Ú¯Ø± ØªÙ‚Ø§Ø·Ø¹ Ø±ÙˆÛŒ Ø®Ø· Ø§Ø³ØªØŒ ÙÙ‚Ø· Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line1End Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
            ctx.beginPath();
            ctx.moveTo(line1End.x, line1End.y);
          ctx.lineTo(line1ExtendedEnd.x, line1ExtendedEnd.y);
          ctx.stroke();
          }
        }
      }
      
      // Ø±Ø³Ù… Ø®Ø· 2: Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ solidØŒ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Ú†ÛŒÙ†
      const line2Dx = line2End.x - line2Start.x;
      const line2Dy = line2End.y - line2Start.y;
      const line2Length = Math.sqrt(line2Dx * line2Dx + line2Dy * line2Dy);
      if (line2Length > 0) {
        const line2DirX = line2Dx / line2Length;
        const line2DirY = line2Dy / line2Length;
        const line2ExtendedStart = {
          x: intersectionX - line2DirX * scaledExtend,
          y: intersectionY - line2DirY * scaledExtend
        };
        const line2ExtendedEnd = {
          x: intersectionX + line2DirX * scaledExtend,
          y: intersectionY + line2DirY * scaledExtend
        };
        
        // Ø±Ù†Ú¯ gradient Ø§Ø² Ù†Ù‚Ø§Ø·
        const line2Color = getLineColorForPoints(landmark2StartName || 'default', landmark2EndName || 'default', line2Start, line2End);
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø¨ÛŒÙ† line2Start Ùˆ line2End Ø§Ø³Øª ÛŒØ§ Ù†Ù‡
        const line2ToIntersection = Math.sqrt((intersectionX - line2Start.x) ** 2 + (intersectionY - line2Start.y) ** 2);
        const line2ToEnd = Math.sqrt((line2End.x - line2Start.x) ** 2 + (line2End.y - line2Start.y) ** 2);
        const intersectionToEnd2 = Math.sqrt((line2End.x - intersectionX) ** 2 + (line2End.y - intersectionY) ** 2);
        const isIntersectionOnLine2 = Math.abs(line2ToIntersection + intersectionToEnd2 - line2ToEnd) < 1; // ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹ Ø±ÙˆÛŒ Ø®Ø· Ø§Ø³Øª
        
        // Ø±Ø³Ù… Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ (solid) - Ø§Ø² line2Start ØªØ§ line2End (Ú©Ø§Ù…Ù„)
        ctx.strokeStyle = line2Color;
        ctx.lineWidth = actualLineWidth;
        ctx.setLineDash([]); // solid
        ctx.beginPath();
        ctx.moveTo(line2Start.x, line2Start.y);
        ctx.lineTo(line2End.x, line2End.y);
        ctx.stroke();
        
        // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line2Start (Ø®Ø· Ú†ÛŒÙ†) - ÙÙ‚Ø· Ø§Ú¯Ø± drawDashedExtensions true Ø¨Ø§Ø´Ø¯
        if (drawDashedExtensions) {
          ctx.strokeStyle = line2Color;
          ctx.lineWidth = actualLineWidth;
          ctx.setLineDash([5 * zoom, 5 * zoom]); // Ø®Ø· Ú†ÛŒÙ†
          ctx.beginPath();
          ctx.moveTo(line2ExtendedStart.x, line2ExtendedStart.y);
          ctx.lineTo(line2Start.x, line2Start.y);
          ctx.stroke();
          
          // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line2End ØªØ§ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ (Ø®Ø· Ú†ÛŒÙ†) - Ø§Ú¯Ø± ØªÙ‚Ø§Ø·Ø¹ Ø®Ø§Ø±Ø¬ Ø§Ø² Ø®Ø· Ø¨Ø§Ø´Ø¯
          if (!isIntersectionOnLine2) {
          ctx.beginPath();
            ctx.moveTo(line2End.x, line2End.y);
            ctx.lineTo(intersectionX, intersectionY);
            ctx.stroke();
          } else {
            // Ø§Ú¯Ø± ØªÙ‚Ø§Ø·Ø¹ Ø±ÙˆÛŒ Ø®Ø· Ø§Ø³ØªØŒ ÙÙ‚Ø· Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² line2End Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
            ctx.beginPath();
            ctx.moveTo(line2End.x, line2End.y);
          ctx.lineTo(line2ExtendedEnd.x, line2ExtendedEnd.y);
          ctx.stroke();
          }
        }
      }
      
      // Draw angle arc in yellow (like steiner)
      let angle1 = Math.atan2(line1End.y - intersectionY, line1End.x - intersectionX);
      let angle2 = Math.atan2(line2End.y - intersectionY, line2End.x - intersectionX);
      let angleDiff = angle2 - angle1;
      if (angleDiff < 0) angleDiff += 2 * Math.PI;
      if (angleDiff > Math.PI) {
        const temp = angle1;
        angle1 = angle2;
        angle2 = temp;
        angleDiff = 2 * Math.PI - angleDiff;
      }
      if (angle2 < angle1) {
        angle2 += 2 * Math.PI;
        angleDiff = angle2 - angle1;
      }
      
      ctx.strokeStyle = '#FFD700'; // Ø²Ø±Ø¯ (Ù…Ø´Ø§Ø¨Ù‡ steiner)
      ctx.lineWidth = actualLineWidth;
      ctx.setLineDash([]); // Ø®Ø· ØµØ§Ù Ø¨Ø±Ø§ÛŒ Ú©Ù…Ø§Ù†
      ctx.beginPath();
      ctx.arc(intersectionX, intersectionY, radius, angle1, angle2);
      ctx.stroke();
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ label (Ø¨Ø§Ù„Ø§ÛŒ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹) Ø¨Ø§ offset Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overlap
      const baseOffset = (isMobile ? 12 : 18) * zoom;
      const labelSpacing = (isMobile ? 20 : 25) * zoom; // ÙØ§ØµÙ„Ù‡ Ø¨ÛŒÙ† label Ù‡Ø§
      
      // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
      if (analysisType !== 'general' && analysisType !== 'all') {
        const intersectionVertex = { x: intersectionX, y: intersectionY };
        const vertexKey = getVertexKey(intersectionVertex);
        const labelIndex = vertexLabelCounts.get(vertexKey) || 0;
        vertexLabelCounts.set(vertexKey, labelIndex + 1);
        
        // Ù…Ø­Ø§Ø³Ø¨Ù‡ offset Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ¹Ø¯Ø§Ø¯ label Ù‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
        const verticalOffset = baseOffset + (labelIndex * labelSpacing);
        
        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† label Ø¯Ø± Ø¬Ù‡Øª Ù…Ù†Ø§Ø³Ø¨
        const midAngle = (angle1 + angle2) / 2;
        const labelRadius = radius + verticalOffset;
        const labelX = intersectionX + Math.cos(midAngle - Math.PI / 2) * labelRadius;
        const labelY = intersectionY + Math.sin(midAngle - Math.PI / 2) * labelRadius;
        
        const labelText = value !== undefined ? `${label}: ${typeof value === 'number' ? value.toFixed(1) : value}Â°` : label;
        
        drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
      }
    };
    
    const drawPerpendicularLine = (point, lineStart, lineEnd, color, lineWidth) => {
      const dx = lineEnd.x - lineStart.x;
      const dy = lineEnd.y - lineStart.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length === 0) return;
      
      const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
      const intersectionX = lineStart.x + t * dx;
      const intersectionY = lineStart.y + t * dy;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.setLineDash([3 * zoom, 3 * zoom]);
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      ctx.lineTo(intersectionX, intersectionY);
      ctx.stroke();
      ctx.setLineDash([]);
    };
    
    const drawDistanceToLine = (point, lineStart, lineEnd, value, label, color, fontSize) => {
      // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
      if (analysisType === 'general' || analysisType === 'all') {
        return;
      }
      const dx = lineEnd.x - lineStart.x;
      const dy = lineEnd.y - lineStart.y;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length === 0) return;
      
      const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (length * length);
      const intersectionX = lineStart.x + t * dx;
      const intersectionY = lineStart.y + t * dy;
      
      const midX = (point.x + intersectionX) / 2;
      const midY = (point.y + intersectionY) / 2;
      const labelText = value !== undefined ? `${label}: ${typeof value === 'number' ? value.toFixed(1) : value}mm` : label;
      drawTextWithBackground(labelText, midX, midY, fontSize, color);
    };
    
    // ØªØ§Ø¨Ø¹ Ù…Ø´ØªØ±Ú© Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… Ø®Ø· Ø¨Ø§ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø¯Ùˆ Ø·Ø±Ù
    const drawLineWithExtensions = (startPos, endPos, startColor, endColor, lineWidth = actualLineWidth, drawExtensions = true, label = null, value = null) => {
      if (!startPos || !endPos) return;
      
      const dx = endPos.x - startPos.x;
      const dy = endPos.y - startPos.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len === 0) return;
      
      const dirX = dx / len;
      const dirY = dy / len;
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªØ¯Ø§Ø¯
      let scaledExtend = 0;
      if (drawExtensions) {
        const rect = containerRef.current?.getBoundingClientRect();
        const baseExtend = Math.max(rect?.width || canvas.width, rect?.height || canvas.height) + 100;
        scaledExtend = baseExtend * zoom;
      }
      
      // ØªØ¹ÛŒÛŒÙ† Ø±Ù†Ú¯ (gradient ÛŒØ§ solid)
      if (useGradientLines && startColor && endColor) {
        const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        ctx.strokeStyle = gradient;
      } else {
        ctx.strokeStyle = startColor || endColor || landmarkColors.default || '#00D9FF';
      }
      
      ctx.lineWidth = lineWidth;
      ctx.setLineDash([]);
      
      // Ø±Ø³Ù… Ø®Ø· Ø§ØµÙ„ÛŒ
      ctx.beginPath();
      ctx.moveTo(startPos.x, startPos.y);
      ctx.lineTo(endPos.x, endPos.y);
      ctx.stroke();
      
      // Ø±Ø³Ù… Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø¯Ùˆ Ø·Ø±Ù (Ø®Ø· Ú†ÛŒÙ†)
      if (drawExtensions && scaledExtend > 0) {
        ctx.setLineDash([5 * zoom, 5 * zoom]);
        ctx.beginPath();
        ctx.moveTo(startPos.x - dirX * scaledExtend, startPos.y - dirY * scaledExtend);
        ctx.lineTo(startPos.x, startPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(endPos.x, endPos.y);
        ctx.lineTo(endPos.x + dirX * scaledExtend, endPos.y + dirY * scaledExtend);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Ø§Ú¯Ø± label Ùˆ value ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ØŒ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
      if (label && value !== null && value !== undefined && !isNaN(value)) {
        const midX = (startPos.x + endPos.x) / 2;
        const midY = (startPos.y + endPos.y) / 2;
        const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x);
        const fontSize = isMobile ? 7 : 10;
        const displayValue = typeof value === 'number' ? value.toFixed(1) : value;
        const valueUnit = label.includes('Â°') ? '' : 'mm';
        drawRotatedTextWithBackground(
          `${label}: ${displayValue}${valueUnit}`,
          midX, midY, angle, fontSize, '#FFD700'
        );
      }
    };

    // ğŸ”§ FIX: Handle Device Pixel Ratio (DPR) for high-quality rendering on mobile/retina displays
    // Ø§ÛŒÙ† Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ Ú©ÛŒÙÛŒØª Ù†Ù…Ø§ÛŒØ´ Ø¯Ø± Ú¯ÙˆØ´ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ùˆ Ù†Ù…Ø§ÛŒØ´Ú¯Ø±Ù‡Ø§ÛŒ Ø¨Ø§ DPR Ø¨Ø§Ù„Ø§ (2x, 3x) Ø¨Ù‡ØªØ± Ø´ÙˆØ¯
    // Ø§ÙØ²Ø§ÛŒØ´ DPR Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ú©ÛŒÙÛŒØª Ù†Ø§Ù… Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ØŒ Ø¯Ø§ÛŒØ±Ù‡â€ŒÙ‡Ø§ Ùˆ Ø®Ø·ÙˆØ·
    const baseDpr = window.devicePixelRatio || 1;
    const dpr = isMobile ? baseDpr * 2 : baseDpr; // Ø§ÙØ²Ø§ÛŒØ´ 2 Ø¨Ø±Ø§Ø¨Ø±ÛŒ DPR Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
    const displayWidth = rect.width;
    const displayHeight = rect.height;

    // Set actual canvas size in memory (scaled by DPR)
    canvas.width = displayWidth * dpr;
    canvas.height = displayHeight * dpr;

    // Set display size (CSS pixels)
    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;

    // Scale context to match DPR for crisp rendering
    ctx.scale(dpr, dpr);

    // Enable high-quality image smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high'; // 'low' | 'medium' | 'high'

    // Clear canvas (using display size coordinates after scaling)
    ctx.clearRect(0, 0, displayWidth, displayHeight);

    // Calculate image position and scale only if we have an image
    // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² displayWidth Ùˆ displayHeight (Ù†Ù‡ canvas.width/height Ú©Ù‡ Ø´Ø§Ù…Ù„ DPR Ø§Ø³Øª)
    let scale; let scaledWidth; let scaledHeight; let x; let y;
    
    // Determine if image should be shown based on viewMode
    const shouldShowImage = image && isImageLoaded && viewMode !== 'coordinate';
    
    if (shouldShowImage) {
      scale = Math.min(
        displayWidth / image.width,
        displayHeight / image.height
      ) * zoom;
      scaledWidth = image.width * scale;
      scaledHeight = image.height * scale;
      x = (displayWidth - scaledWidth) / 2 + pan.x;
      y = (displayHeight - scaledHeight) / 2 + pan.y;

      // Apply image filters based on viewMode
      ctx.filter = 'none';

      // Draw the image
      ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
      
      // Reset filter after drawing
      ctx.filter = 'none';
    }

    // Draw coordinate system if enabled or in coordinate mode
    if (showCoordinateSystemLocal || viewMode === 'coordinate') {
      // Get theme-aware colors for coordinate system
      const isDarkMode = theme.palette.mode === 'dark';
      
      // Colors adapt to theme - brighter in dark mode for visibility
      const centerCrossColor = isDarkMode ? '#ff6b6b' : '#ff0000'; // Brighter red in dark mode
      const gridColor = isDarkMode ? '#4a5568' : '#f0f0f0'; // Darker gray in dark mode
      
      // Draw center cross (using display size coordinates) - scale with zoom
      ctx.strokeStyle = centerCrossColor;
      const baseCenterCrossLineWidth = isMobile ? 1 : 2;
      ctx.lineWidth = baseCenterCrossLineWidth * zoom;
      ctx.beginPath();
      ctx.moveTo(displayWidth / 2, 0);
      ctx.lineTo(displayWidth / 2, displayHeight);
      ctx.moveTo(0, displayHeight / 2);
      ctx.lineTo(displayWidth, displayHeight / 2);
      ctx.stroke();

      // Draw background grid for reference - scale with zoom
      ctx.strokeStyle = gridColor;
      const baseGridLineWidth = isMobile ? 0.5 : 1;
      ctx.lineWidth = baseGridLineWidth * zoom;
      const gridSize = 20;
      for (let gridX = 0; gridX < displayWidth; gridX += gridSize) {
        ctx.beginPath();
        ctx.moveTo(gridX, 0);
        ctx.lineTo(gridX, displayHeight);
        ctx.stroke();
      }
      for (let gridY = 0; gridY < displayHeight; gridY += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, gridY);
        ctx.lineTo(displayWidth, gridY);
        ctx.stroke();
      }
    }

    // Always draw landmarks and lines when they exist, regardless of coordinate system mode
    if (Object.keys(landmarks).length > 0) {
      // Draw lines
      if (showLines) {
        ctx.lineWidth = actualLineWidth;
        
        // ØªÙ†Ø¸ÛŒÙ… Ù†ÙˆØ¹ Ø®Ø· - scale dash pattern with zoom
        if (lineStyle === 'dashed') {
          ctx.setLineDash([8 * zoom, 4 * zoom]); // Ø®Ø· Ú†ÛŒÙ† - scale with zoom
        } else if (lineStyle === 'dotted') {
          ctx.setLineDash([2 * zoom, 3 * zoom]); // Ù†Ù‚Ø·Ù‡ Ú†ÛŒÙ† - scale with zoom
        } else {
          ctx.setLineDash([]); // solid
        }

        // Helper function to find landmark by name (case-insensitive and partial match)
        const findLandmark = (name) => {
          // Direct match
          if (landmarks[name]) return landmarks[name];
          
          // Case-insensitive match
          const lowerName = name.toLowerCase();
          const found = Object.keys(landmarks).find(key => key.toLowerCase() === lowerName);
          if (found) return landmarks[found];
          
          // Partial match for common variations
          const partialMatches = {
            'Or': ['or', 'orbit', 'orbitale'],
            'Po': ['po', 'porion'],
            'L1': ['l1', 'lower', 'incisor', 'li', 'lower_incisor'],
            'U1': ['u1', 'upper', 'incisor', 'ui', 'upper_incisor'],
            'Me': ['me', 'menton'],
            'Go': ['go', 'gonion'],
            'S': ['s', 'sella'],
            'N': ['n', 'nasion'],
            'A': ['a', 'point_a', 'point a'],
            'B': ['b', 'point_b', 'point b'],
            'Gn': ['gn', 'gnathion'],
            'Pog': ['pog', 'pogonion'],
            'ANS': ['ans', 'anterior'],
            'PNS': ['pns', 'posterior'],
            'Pn': ['pn', 'prn', 'pronasale'],
            'Pogâ€²': ['pogâ€²', 'pog\'', 'pog`', 'pogsoft', 'soft pogonion', 'pogonion soft', 'pog prime'],
            'LMT': ['lmt', 'LMT', 'lower_molar', 'Lower Molar', 'L6', 'l6'],
          };
          
          if (partialMatches[name]) {
            for (const partial of partialMatches[name]) {
              const found = Object.keys(landmarks).find(key =>
                key.toLowerCase().includes(partial.toLowerCase()) || partial.toLowerCase().includes(key.toLowerCase())
              );
              if (found) return landmarks[found];
            }
          }
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ Ø­Ø°Ù Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ Ø®Ø§Øµ (Ù…Ø«Ù„ ' Ùˆ ` Ùˆ â€²)
          const cleanName = name.replace(/['"`â€²]/g, '').toLowerCase();
          const cleanMatch = Object.keys(landmarks).find(key => 
            key.replace(/['"`â€²]/g, '').toLowerCase() === cleanName
          );
          if (cleanMatch) return landmarks[cleanMatch];
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ escape Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ Ø®Ø§Øµ
          const escapedName = name.replace(/'/g, '\\\'').replace(/`/g, '\\`').replace(/â€²/g, '\\â€²');
          const directMatch = Object.keys(landmarks).find(key => 
            key === name || key === escapedName || key.toLowerCase() === name.toLowerCase() || key.toLowerCase() === escapedName.toLowerCase()
          );
          if (directMatch) return landmarks[directMatch];
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ prime (â€²) Ø¨Ù‡ Ø¬Ø§ÛŒ apostrophe (')
          if (name.includes('\'')) {
            const primeName = name.replace(/'/g, 'â€²');
            const primeMatch = Object.keys(landmarks).find(key => 
              key === primeName || key.toLowerCase() === primeName.toLowerCase()
            );
            if (primeMatch) return landmarks[primeMatch];
          }
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ apostrophe (') Ø¨Ù‡ Ø¬Ø§ÛŒ prime (â€²)
          if (name.includes('â€²')) {
            const apostropheName = name.replace(/â€²/g, '\'');
            const apostropheMatch = Object.keys(landmarks).find(key => 
              key === apostropheName || key.toLowerCase() === apostropheName.toLowerCase()
            );
            if (apostropheMatch) return landmarks[apostropheMatch];
          }
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ backtick Ø¨Ù‡ Ø¬Ø§ÛŒ apostrophe
          if (name.includes('\'')) {
            const backtickName = name.replace(/'/g, '`');
            const backtickMatch = Object.keys(landmarks).find(key => 
              key === backtickName || key.toLowerCase() === backtickName.toLowerCase()
            );
            if (backtickMatch) return landmarks[backtickMatch];
          }
          
          // Ø¬Ø³ØªØ¬ÙˆÛŒ Ø¨Ø§ apostrophe Ø¨Ù‡ Ø¬Ø§ÛŒ backtick
          if (name.includes('`')) {
            const apostropheName = name.replace(/`/g, '\'');
            const apostropheMatch = Object.keys(landmarks).find(key => 
              key === apostropheName || key.toLowerCase() === apostropheName.toLowerCase()
            );
            if (apostropheMatch) return landmarks[apostropheMatch];
          }
          
          return null;
        };
        
        // Helper function to find landmark by trying multiple name variations
        const findLandmarkVariations = (variations) => {
          for (const name of variations) {
            const lm = findLandmark(name);
            if (lm) return lm;
          }
          return null;
        };
        
        // Helper function to get landmark using LANDMARK_VARIATIONS object
        const getLandmarkByName = (name) => {
          // First try the exact name
          let variations = LANDMARK_VARIATIONS[name];
          if (variations) {
            const result = findLandmarkVariations(variations);
            if (result) return result;
          }
          
          // If not found and name contains apostrophe, try with backtick
          if (name.includes('\'')) {
            const backtickName = name.replace(/'/g, '`');
            variations = LANDMARK_VARIATIONS[backtickName];
            if (variations) {
              const result = findLandmarkVariations(variations);
              if (result) return result;
            }
          }
          
          // If not found and name contains backtick, try with apostrophe
          if (name.includes('`')) {
            const apostropheName = name.replace(/`/g, '\'');
            variations = LANDMARK_VARIATIONS[apostropheName];
            if (variations) {
              const result = findLandmarkVariations(variations);
              if (result) return result;
            }
          }
          
          return null;
        };
        
        // ØªØ§Ø¨Ø¹ Ù…Ø´ØªØ±Ú© Ø¨Ø±Ø§ÛŒ ØªØ¨Ø¯ÛŒÙ„ ÙØ§ØµÙ„Ù‡ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ±
        const convertDistanceToMm = (pixelDistance, measurementKey, alternativeKeys = []) => {
          // Ø§ÙˆÙ„ Ø§Ø² currentMeasurements Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†
          if (currentMeasurements && currentMeasurements[measurementKey] !== undefined && currentMeasurements[measurementKey] !== null) {
            return parseFloat(currentMeasurements[measurementKey]);
          }
          
          // Ø³Ù¾Ø³ Ø§Ø² alternative keys
          for (const key of alternativeKeys) {
            if (currentMeasurements && currentMeasurements[key] !== undefined && currentMeasurements[key] !== null) {
              return parseFloat(currentMeasurements[key]);
            }
          }
          
          // Ø¯Ø± Ù†Ù‡Ø§ÛŒØª Ø§Ø² pixelToMmConversion
          if (pixelToMmConversion && pixelToMmConversion > 0) {
            return pixelDistance * pixelToMmConversion;
          }
          
          return null;
        };

        // Ø§Ù†ØªØ®Ø§Ø¨ Ø®Ø·ÙˆØ· Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹ Ø¢Ù†Ø§Ù„ÛŒØ²
        const linesToDraw = analysisType && ANALYSIS_LINES[analysisType] 
          ? ANALYSIS_LINES[analysisType] 
          : DEFAULT_LINES;

        // Ø®Ø·ÙˆØ· Ù¾Ø§ÛŒÙ‡ Ú©Ù‡ Ù‡Ù…ÛŒØ´Ù‡ Ø¨Ø§ÛŒØ¯ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆÙ†Ø¯ (Or-Po, ANS-PNS, S-N)
        // ANS-PNS Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² Ricketts Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨Ø§ S-N)
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² McNamara: Or-PoØŒ ANS-PNS Ùˆ S-N Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Wits: Or-PoØŒ ANS-PNS Ùˆ S-N Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Tweed: S-N Ùˆ ANS-PNS Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² BjÃ¶rk: Or-Po Ùˆ ANS-PNS Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Jarabak: Or-Po Ùˆ ANS-PNS Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Steiner: Or-Po Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯
        // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… (Legan & Burstone, Arnett & McLaughlin, Holdaway, Soft Tissue Angular): Or-PoØŒ ANS-PNS Ùˆ S-N Ø­Ø°Ù Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯
        const isSoftTissueAnalysis = analysisType === 'leganBurstone' || analysisType === 'arnettMcLaughlin' || analysisType === 'holdaway' || analysisType === 'softTissueAngular';
        const baseLines = [
          ...(analysisType !== 'mcnamara' && analysisType !== 'wits' && analysisType !== 'jarabak' && analysisType !== 'sassouni' && analysisType !== 'steiner' && !isSoftTissueAnalysis ? [{ start: 'Or', end: 'Po', label: 'Or-Po (Frankfort)' }] : []),
          ...(analysisType !== 'mcnamara' && analysisType !== 'wits' && analysisType !== 'tweed' && analysisType !== 'jarabak' && analysisType !== 'steiner' && !isSoftTissueAnalysis ? [{ start: 'ANS', end: 'PNS', label: 'ANS-PNS' }] : []),
          ...(analysisType !== 'mcnamara' && analysisType !== 'wits' && analysisType !== 'tweed' && analysisType !== 'steiner' && !isSoftTissueAnalysis ? [{ start: 'S', end: 'N', label: 'S-N' }] : []),
        ];

        // ØªØ±Ú©ÛŒØ¨ Ø®Ø·ÙˆØ· Ù¾Ø§ÛŒÙ‡ Ø¨Ø§ Ø®Ø·ÙˆØ· Ø¢Ù†Ø§Ù„ÛŒØ² (Ø­Ø°Ù ØªÚ©Ø±Ø§Ø±ÛŒâ€ŒÙ‡Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Set Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¹Ù…Ù„Ú©Ø±Ø¯)
        const getLineKey = (start, end) => (start < end ? `${start}-${end}` : `${end}-${start}`);
        
        const drawnLinesSet = new Set();
        const allLinesToDraw = [];
        
        // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø®Ø·ÙˆØ· Ù¾Ø§ÛŒÙ‡
        baseLines.forEach((line) => {
          const lineKey = getLineKey(line.start, line.end);
          if (!drawnLinesSet.has(lineKey)) {
            drawnLinesSet.add(lineKey);
            allLinesToDraw.push(line);
          }
        });
        
        // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø®Ø·ÙˆØ· Ø¢Ù†Ø§Ù„ÛŒØ²
        linesToDraw.forEach((line) => {
          const lineKey = getLineKey(line.start, line.end);
          if (!drawnLinesSet.has(lineKey)) {
            drawnLinesSet.add(lineKey);
            allLinesToDraw.push(line);
          }
        });

        allLinesToDraw.forEach(({ start, end, label, extend }) => {
          // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Object Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ø§Ø´Øª Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ Ø¨Ù‡ Ø®Ø·ÙˆØ· (Ú©Ø§Ù‡Ø´ Ø´Ø±Ø·â€ŒÙ‡Ø§ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ)
          if (analysisType === 'mcnamara' || analysisType === 'jarabak' || analysisType === 'general') {
            if (!shouldDrawLine(start, end, analysisType)) {
              return; // Ø§ÛŒÙ† Ø®Ø· Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
            }
          }
          
          // Ø­Ø°Ù Ø®Ø·ÙˆØ· Ø§Ø¶Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… (Legan & Burstone, Arnett & McLaughlin, Holdaway, Soft Tissue Angular)
          // Ø®Ø·ÙˆØ· S-N, Or-Po, ANS-PNS Ùˆ Ø³Ø§ÛŒØ± Ø®Ø·ÙˆØ· hard tissue Ø¨Ø§ÛŒØ¯ Ø­Ø°Ù Ø´ÙˆÙ†Ø¯
          if (isSoftTissueAnalysis) {
            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Set Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ø³Ø±ÛŒØ¹â€ŒØªØ± Ø®Ø·ÙˆØ· hard tissue
            const hardTissueLinesSet = new Set([
              'S-N', 'N-S', 'Or-Po', 'Po-Or', 'ANS-PNS', 'PNS-ANS',
              'N-A', 'A-N', 'N-B', 'B-N', 'N-Pog', 'Pog-N',
              'S-A', 'A-S', 'S-B', 'B-S', 'Go-Me', 'Me-Go',
              'Go-Gn', 'Gn-Go', 'Ar-Go', 'Go-Ar', 'S-Ar', 'Ar-S',
              'S-Go', 'Go-S', 'U1-L1', 'L1-U1', 'U1-A', 'A-U1',
              'L1-A', 'A-L1', 'S-U1', 'U1-S', 'L1-Me', 'Me-L1',
              'Or-L1', 'L1-Or', 'Po-L1', 'L1-Po', 'Gn-Pt', 'Pt-Gn',
              'Ba-Pt', 'Pt-Ba', 'N-Me', 'Me-N', 'Co-Gn', 'Gn-Co',
              'L1-LMT', 'LMT-L1', 'A-B', 'B-A', 'L1A-L1', 'L1-L1A',
            ]);
            
            const lineKey = getLineKey(start, end);
            if (hardTissueLinesSet.has(lineKey)) {
              return; // Ø§ÛŒÙ† Ø®Ø· Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
            }
          }
          
          const startLandmark = findLandmark(start);
          const endLandmark = findLandmark(end);
          
          // Skip if landmarks are missing
          if (!startLandmark || !endLandmark) {
            return;
          }
          
          if (startLandmark && endLandmark) {
            const startPos = getLandmarkCanvasPosition(startLandmark);
            let endPos = getLandmarkCanvasPosition(endLandmark);

            // Ø¨Ø±Ø§ÛŒ Occlusal Plane: Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ Ø¨Ø§ÛŒØ¯ Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÛŒÙ† LMT Ùˆ UMT Ø¨Ø§Ø´Ø¯
            if (label === 'Occlusal Plane' && start === 'L1' && end === 'LMT') {
              const umtLandmark = findLandmark('UMT') || findLandmark('umt') || findLandmark('upper_molar') || findLandmark('Upper Molar') || findLandmark('U6') || findLandmark('u6');
              if (umtLandmark) {
                const umtPos = getLandmarkCanvasPosition(umtLandmark);
                if (umtPos && endPos) {
                  endPos = {
                    x: (endPos.x + umtPos.x) / 2,
                    y: (endPos.y + umtPos.y) / 2
                  };
                }
              }
            }

            if (startPos && endPos) {
              // Ø§Ú¯Ø± gradient ÙØ¹Ø§Ù„ Ø§Ø³ØªØŒ Ø§Ø² Ø±Ù†Ú¯ Ù†Ù‚Ø§Ø· Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
              if (useGradientLines) {
                const startColor = landmarkColors[start] || landmarkColors.default || '#00D9FF';
                const endColor = landmarkColors[end] || landmarkColors.default || '#00D9FF';
                
                // Ø§ÛŒØ¬Ø§Ø¯ gradient
                const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
              } else {
                ctx.strokeStyle = lineColor;
              }
              
              // ØªØ±Ø³ÛŒÙ… Ø®Ø· Ø§ØµÙ„ÛŒ
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]);
              ctx.beginPath();
              ctx.moveTo(startPos.x, startPos.y);
              ctx.lineTo(endPos.x, endPos.y);
              ctx.stroke();
              
              // Ø§Ú¯Ø± extend ÙØ¹Ø§Ù„ Ø§Ø³ØªØŒ Ø®Ø· Ø±Ø§ Ø§Ø² Ø¯Ùˆ Ø·Ø±Ù Ø§Ù…ØªØ¯Ø§Ø¯ Ø¨Ø¯Ù‡
              if (extend) {
                const rect = containerRef.current?.getBoundingClientRect();
                const displayWidth = rect?.width || canvas.width;
                const displayHeight = rect?.height || canvas.height;
                const baseExtend = Math.max(displayWidth, displayHeight) + 100;
                const scaledExtend = baseExtend * zoom;
                
                const dx = endPos.x - startPos.x;
                const dy = endPos.y - startPos.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length > 0) {
                  const dirX = dx / length;
                  const dirY = dy / length;
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù start
                  const extendedStart = {
                    x: startPos.x - dirX * scaledExtend,
                    y: startPos.y - dirY * scaledExtend
                  };
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù end
                  const extendedEnd = {
                    x: endPos.x + dirX * scaledExtend,
                    y: endPos.y + dirY * scaledExtend
                  };
                  
                  // ØªØ±Ø³ÛŒÙ… Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ· (Ø®Ø· Ú†ÛŒÙ†)
                  ctx.lineWidth = actualLineWidth;
                  ctx.setLineDash([5 * zoom, 5 * zoom]);
                  ctx.strokeStyle = useGradientLines ? 
                    (landmarkColors[start] || landmarkColors.default || '#00D9FF') : 
                    lineColor;
                  ctx.beginPath();
                  ctx.moveTo(extendedStart.x, extendedStart.y);
                  ctx.lineTo(startPos.x, startPos.y);
                  ctx.stroke();
                  
                  ctx.strokeStyle = useGradientLines ? 
                    (landmarkColors[end] || landmarkColors.default || '#00D9FF') : 
                    lineColor;
                  ctx.beginPath();
                  ctx.moveTo(endPos.x, endPos.y);
                  ctx.lineTo(extendedEnd.x, extendedEnd.y);
                  ctx.stroke();
                  
                  ctx.setLineDash([]);
                }
              }
            }
          }
          // ğŸ”§ FIX: Ø­Ø°Ù Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ warning Ø¨Ø±Ø§ÛŒ missing landmarks
        });
        
        // Helper function to get line color based on landmark colors
        const getLineColor = (startLandmarkName, endLandmarkName, startPos, endPos) => {
          const startColor = landmarkColors[startLandmarkName] || landmarkColors.default || '#00D9FF';
          const endColor = landmarkColors[endLandmarkName] || landmarkColors.default || '#00D9FF';
          
          if (useGradientLines && startPos && endPos) {
            const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, endColor);
            return gradient;
          }
          return startColor;
        };

        // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Ricketts Ùˆ McNamara
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² calculatedMeasurements (Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ Ø¯Ø± Ø¯Ø§Ø®Ù„ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øª) ÛŒØ§ prop measurements
        const currentMeasurements = Object.keys(calculatedMeasurements).length > 0 ? calculatedMeasurements : (measurements || {});
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² McNamara - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† N-A Ùˆ A-Pog (Ø¯Ø± Ù†Ù‚Ø·Ù‡ A) Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø·ÙˆÙ„ S-Go Ùˆ N-Me
        if (showMeasurements && (analysisType === 'mcnamara' || analysisType === 'general')) {
          // Ù†Ù…Ø§ÛŒØ´ Ø·ÙˆÙ„ S-Go Ùˆ N-Me
          const sLandmarkMcNamara = getLandmarkByName('S');
          const goLandmarkMcNamara = getLandmarkByName('Go');
          const nLandmarkMcNamara = getLandmarkByName('N');
          const meLandmarkMcNamara = getLandmarkByName('Me');
          
          // Ù†Ù…Ø§ÛŒØ´ Ø·ÙˆÙ„ S-Go (Ú†Ø±Ø®Ø´ Ø´Ø¯Ù‡ Ø¨Ù‡ Ù…ÙˆØ§Ø²Ø§Øª Ø®Ø·)
          if (sLandmarkMcNamara && goLandmarkMcNamara) {
            const sPos = getLandmarkCanvasPosition(sLandmarkMcNamara);
            const goPos = getLandmarkCanvasPosition(goLandmarkMcNamara);
            
            if (sPos && goPos) {
              const sGoDistancePixels = Math.sqrt((goPos.x - sPos.x) ** 2 + (goPos.y - sPos.y) ** 2);
              const midPointSGo = {
                x: (sPos.x + goPos.x) / 2,
                y: (sPos.y + goPos.y) / 2
              };
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø®Ø· S-Go
              const sGoAngle = Math.atan2(goPos.y - sPos.y, goPos.x - sPos.x);
              
              // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ±
              const sGoDistanceMm = convertDistanceToMm(sGoDistancePixels, 'S-Go', ['Posterior Facial Height (S-Go)']);
              
              const fontSize = isMobile ? 7 : 10;
              if (sGoDistanceMm !== null && !isNaN(sGoDistanceMm)) {
                const distanceText = `S-Go: ${typeof sGoDistanceMm === 'number' ? sGoDistanceMm.toFixed(1) : sGoDistanceMm}mm`;
              drawRotatedTextWithBackground(distanceText, midPointSGo.x, midPointSGo.y, sGoAngle, fontSize, '#FFD700');
              }
            }
          }
          
          // Ù†Ù…Ø§ÛŒØ´ Ø·ÙˆÙ„ N-Me (Ú†Ø±Ø®Ø´ Ø´Ø¯Ù‡ Ø¨Ù‡ Ù…ÙˆØ§Ø²Ø§Øª Ø®Ø·)
          if (nLandmarkMcNamara && meLandmarkMcNamara) {
            const nPos = getLandmarkCanvasPosition(nLandmarkMcNamara);
            const mePos = getLandmarkCanvasPosition(meLandmarkMcNamara);
            
            if (nPos && mePos) {
              const nMeDistancePixels = Math.sqrt((mePos.x - nPos.x) ** 2 + (mePos.y - nPos.y) ** 2);
              const midPointNMe = {
                x: (nPos.x + mePos.x) / 2,
                y: (nPos.y + mePos.y) / 2
              };
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø®Ø· N-Me
              const nMeAngle = Math.atan2(mePos.y - nPos.y, mePos.x - nPos.x);
              
              // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù…ÛŒÙ„ÛŒâ€ŒÙ…ØªØ±
              const nMeDistanceMm = convertDistanceToMm(nMeDistancePixels, 'N-Me', ['Anterior Facial Height (N-Me)']);
              
              const fontSize = isMobile ? 7 : 10;
              if (nMeDistanceMm !== null && !isNaN(nMeDistanceMm)) {
                const distanceText = `N-Me: ${typeof nMeDistanceMm === 'number' ? nMeDistanceMm.toFixed(1) : nMeDistanceMm}mm`;
              drawRotatedTextWithBackground(distanceText, midPointNMe.x, midPointNMe.y, nMeAngle, fontSize, '#FFD700');
              }
            }
          }
          
          // Ø²Ø§ÙˆÛŒÙ‡ Skeletal Convexity (N-A-Pog) - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø·ÙˆØ· N-A Ùˆ A-Pog (Ø¯Ø± Ù†Ù‚Ø·Ù‡ A)
          const aLandmarkMcNamara = getLandmarkByName('A');
          const pogLandmarkMcNamara = getLandmarkByName('Pog');
          
          if (aLandmarkMcNamara && nLandmarkMcNamara && pogLandmarkMcNamara) {
            const aPos = getLandmarkCanvasPosition(aLandmarkMcNamara);
            const nPos = getLandmarkCanvasPosition(nLandmarkMcNamara);
            const pogPos = getLandmarkCanvasPosition(pogLandmarkMcNamara);
            
            if (aPos && nPos && pogPos) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngle Ø¨Ø±Ø§ÛŒ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ø± ÛŒÚ© vertex (Ù†Ù‚Ø·Ù‡ A)
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              let angleValue = currentMeasurements && (currentMeasurements['Skeletal Convexity'] || currentMeasurements['N-A-Pog'])
                ? parseFloat(currentMeasurements['Skeletal Convexity'] || currentMeasurements['N-A-Pog']) 
                : undefined;
              
              // Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø²Ø§ÙˆÛŒÙ‡ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
              if (angleValue === undefined || angleValue === null || isNaN(angleValue)) {
                const calculatedAngle = calculateAngleBetweenLines(nPos, aPos, pogPos, aPos);
                if (calculatedAngle !== null && !isNaN(calculatedAngle)) {
                  angleValue = calculatedAngle;
                }
              }
              
              // vertex: A, p1: N, p2: Pog
              if (angleValue !== undefined && angleValue !== null && !isNaN(angleValue)) {
                drawAngle(nPos, aPos, pogPos, angleValue, 'Skeletal Convexity', '#FFD700', fontSize, radius, 'N', 'Pog');
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Wits - Occlusal Plane Ùˆ Ø¹Ù…ÙˆØ¯Ù‡Ø§ÛŒ A Ùˆ B
        if (showMeasurements && (analysisType === 'wits' || analysisType === 'general')) {
          const l1LandmarkWits = getLandmarkByName('L1');
          const lmtLandmarkWits = getLandmarkByName('LMT');
          const umtLandmarkWits = getLandmarkByName('UMT');
          const aLandmarkWits = getLandmarkByName('A');
          const bLandmarkWits = getLandmarkByName('B');
          
          if (l1LandmarkWits && lmtLandmarkWits && aLandmarkWits && bLandmarkWits) {
            const l1Pos = getLandmarkCanvasPosition(l1LandmarkWits);
            const lmtPos = getLandmarkCanvasPosition(lmtLandmarkWits);
            const umtPos = umtLandmarkWits ? getLandmarkCanvasPosition(umtLandmarkWits) : null;
            const aPos = getLandmarkCanvasPosition(aLandmarkWits);
            const bPos = getLandmarkCanvasPosition(bLandmarkWits);
            
            if (l1Pos && lmtPos && aPos && bPos) {
              // Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ Occlusal Plane: Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÛŒÙ† LMT Ùˆ UMT
              const occlusalEndPos = umtPos ? {
                x: (lmtPos.x + umtPos.x) / 2,
                y: (lmtPos.y + umtPos.y) / 2
              } : lmtPos;
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªØ¯Ø§Ø¯ Occlusal Plane
              const rect = containerRef.current?.getBoundingClientRect();
              const displayWidth = rect?.width || canvas.width;
              const displayHeight = rect?.height || canvas.height;
              const baseExtend = Math.max(displayWidth, displayHeight) + 100;
              const scaledExtend = baseExtend * zoom;
              
              const occlusalDx = occlusalEndPos.x - l1Pos.x;
              const occlusalDy = occlusalEndPos.y - l1Pos.y;
              const occlusalLength = Math.sqrt(occlusalDx * occlusalDx + occlusalDy * occlusalDy);
              
              if (occlusalLength > 0) {
                const occlusalDirX = occlusalDx / occlusalLength;
                const occlusalDirY = occlusalDy / occlusalLength;
                
                // Ø§Ù…ØªØ¯Ø§Ø¯ Occlusal Plane
                const occlusalExtendedStart = {
                  x: l1Pos.x - occlusalDirX * scaledExtend,
                  y: l1Pos.y - occlusalDirY * scaledExtend
                };
                const occlusalExtendedEnd = {
                  x: occlusalEndPos.x + occlusalDirX * scaledExtend,
                  y: occlusalEndPos.y + occlusalDirY * scaledExtend
                };
                
                // ØªØ±Ø³ÛŒÙ… Occlusal Plane Ø§ØµÙ„ÛŒ
                ctx.lineWidth = actualLineWidth * 1.5;
                ctx.setLineDash([]);
                ctx.strokeStyle = getLineColor('L1', 'LMT', l1Pos, occlusalEndPos);
                ctx.beginPath();
                ctx.moveTo(l1Pos.x, l1Pos.y);
                ctx.lineTo(occlusalEndPos.x, occlusalEndPos.y);
                ctx.stroke();
                
                // ØªØ±Ø³ÛŒÙ… Ø§Ù…ØªØ¯Ø§Ø¯ Occlusal Plane (Ø®Ø· Ú†ÛŒÙ†)
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([5 * zoom, 5 * zoom]);
                ctx.strokeStyle = getLineColor('L1', 'LMT', occlusalExtendedStart, occlusalExtendedEnd);
                ctx.beginPath();
                ctx.moveTo(occlusalExtendedStart.x, occlusalExtendedStart.y);
                ctx.lineTo(occlusalExtendedEnd.x, occlusalExtendedEnd.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¹Ù…ÙˆØ¯ Ø§Ø² A Ø¨Ù‡ Occlusal Plane
                // Ø¨Ø±Ø¯Ø§Ø± Ø¹Ù…ÙˆØ¯ Ø¨Ø± Occlusal Plane
                const perpDirX = -occlusalDirY;
                const perpDirY = occlusalDirX;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø¹Ù…ÙˆØ¯ Ø§Ø² A Ø¨Ø§ Occlusal Plane (AO)
                const getPerpendicularIntersection = (point, lineStart, lineDirX, lineDirY) => {
                  // Ù…Ø¹Ø§Ø¯Ù„Ù‡ Ø®Ø· Occlusal Plane: (lineStart + t * lineDir)
                  // Ù…Ø¹Ø§Ø¯Ù„Ù‡ Ø¹Ù…ÙˆØ¯ Ø§Ø² point: (point + s * perpDir)
                  // Ø­Ù„ Ø³ÛŒØ³ØªÙ… Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† t
                  const dx = point.x - lineStart.x;
                  const dy = point.y - lineStart.y;
                  const t = (dx * lineDirX + dy * lineDirY) / (lineDirX * lineDirX + lineDirY * lineDirY);
                  
                  return {
                    x: lineStart.x + t * lineDirX,
                    y: lineStart.y + t * lineDirY
                  };
                };
                
                // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² l1Pos Ø¨Ù‡ Ø¬Ø§ÛŒ occlusalExtendedStart Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ ØµØ­ÛŒØ­ (Ù…Ø´Ø§Ø¨Ù‡ Ø¬Ø¯ÙˆÙ„)
                const aoPoint = getPerpendicularIntersection(aPos, l1Pos, occlusalDirX, occlusalDirY);
                const boPoint = getPerpendicularIntersection(bPos, l1Pos, occlusalDirX, occlusalDirY);
                
                // ØªØ±Ø³ÛŒÙ… Ø¹Ù…ÙˆØ¯ Ø§Ø² A Ø¨Ù‡ Occlusal Plane (A â†’ AO) - solid
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([]); // solid line
                ctx.strokeStyle = '#00FF00'; // Ø³Ø¨Ø² Ø¨Ø±Ø§ÛŒ Ø¹Ù…ÙˆØ¯Ù‡Ø§
                ctx.beginPath();
                ctx.moveTo(aPos.x, aPos.y);
                ctx.lineTo(aoPoint.x, aoPoint.y);
                ctx.stroke();
                
                // ØªØ±Ø³ÛŒÙ… Ø¹Ù…ÙˆØ¯ Ø§Ø² B Ø¨Ù‡ Occlusal Plane (B â†’ BO) - solid
                ctx.beginPath();
                ctx.moveTo(bPos.x, bPos.y);
                ctx.lineTo(boPoint.x, boPoint.y);
                ctx.stroke();
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ù†Ù…Ø§ÛŒØ´ ÙØ§ØµÙ„Ù‡ AO-BO (Wits)
                // Wits Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ØµÙˆØ±Øª ÙØ§ØµÙ„Ù‡ Ø§ÙÙ‚ÛŒ Ø¨ÛŒÙ† AO Ùˆ BO Ø±ÙˆÛŒ Occlusal Plane Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´ÙˆØ¯
                // Ù†Ù‡ ÙØ§ØµÙ„Ù‡ Ù…Ø³ØªÙ‚ÛŒÙ…! Ø¨Ø§ÛŒØ¯ ÙØ§ØµÙ„Ù‡ Ø¯Ø± Ø±Ø§Ø³ØªØ§ÛŒ Occlusal Plane Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†ÛŒÙ…
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ ÙØ§ØµÙ„Ù‡ Ø§ÙÙ‚ÛŒ: projection Ø±ÙˆÛŒ Ø¨Ø±Ø¯Ø§Ø± Occlusal Plane
                // Ø¹Ù„Ø§Ù…Øª: Ø§Ú¯Ø± AO Ø¬Ù„ÙˆØªØ± Ø§Ø² BO Ø¨Ø§Ø´Ø¯ (Ø¯Ø± Ø±Ø§Ø³ØªØ§ÛŒ Occlusal Plane)ØŒ Ù…Ù‚Ø¯Ø§Ø± Ù…Ø«Ø¨Øª (Ú©Ù„Ø§Ø³ II)
                // Ø§Ú¯Ø± BO Ø¬Ù„ÙˆØªØ± Ø§Ø² AO Ø¨Ø§Ø´Ø¯ØŒ Ù…Ù‚Ø¯Ø§Ø± Ù…Ù†ÙÛŒ (Ú©Ù„Ø§Ø³ III)
                const aoBoDx = boPoint.x - aoPoint.x;
                const aoBoDy = boPoint.y - aoPoint.y;
                // Projection Ø±ÙˆÛŒ Ø¨Ø±Ø¯Ø§Ø± Occlusal Plane (occlusalDirX, occlusalDirY)
                // Ø¨Ø¯ÙˆÙ† Math.abs Ø¨Ø±Ø§ÛŒ Ø­ÙØ¸ Ø¹Ù„Ø§Ù…Øª
                const aoBoDistancePixels = aoBoDx * occlusalDirX + aoBoDy * occlusalDirY;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ conversion factor Ø§Ø² p1/p2 (Ù…Ø´Ø§Ø¨Ù‡ Ø¬Ø¯ÙˆÙ„)
                let conversionFactor = pixelToMmConversion || 0.11;
                const p1Landmark = getLandmarkByName('p1') || getLandmarkByName('P1');
                const p2Landmark = getLandmarkByName('p2') || getLandmarkByName('P2');
                if (p1Landmark && p2Landmark) {
                  const p1Pos = getLandmarkCanvasPosition(p1Landmark);
                  const p2Pos = getLandmarkCanvasPosition(p2Landmark);
                  if (p1Pos && p2Pos) {
                    const dx = Math.abs(p2Pos.x - p1Pos.x);
                    const dy = Math.abs(p2Pos.y - p1Pos.y);
                    const distancePixels = Math.sqrt(dx * dx + dy * dy);
                    if (distancePixels > 0) {
                      conversionFactor = 10.0 / distancePixels; // ÙØ§ØµÙ„Ù‡ p1-p2 Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 10mm Ø§Ø³Øª
                    }
                  }
                }
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ Ø­ÙØ¸ Ø¹Ù„Ø§Ù…Øª (Ù…Ø´Ø§Ø¨Ù‡ Ø¬Ø¯ÙˆÙ„)
                const aoBoDistanceMm = Math.abs(aoBoDistancePixels) * conversionFactor;
                const signedAoBoDistanceMm = aoBoDistanceMm * (aoBoDistancePixels >= 0 ? 1 : -1);
                
                // Ø°Ø®ÛŒØ±Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø§ Ø¹Ù„Ø§Ù…Øª Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± measurements
                if (measurements && typeof measurements === 'object') {
                  measurements['AO-BO'] = signedAoBoDistanceMm;
                }
                // Ù…Ù‚Ø¯Ø§Ø± Wits Ø¯Ø± canvas Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
              }
            }
          }
        }
        
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Steiner - Ù†Ù…Ø§ÛŒØ´ Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§ÛŒ SNA Ùˆ SNB Ø¨Ø§ Ú©Ù…Ø§Ù†
        if (showMeasurements && (analysisType === 'steiner' || analysisType === 'all' || analysisType === 'general')) {
          const sLandmarkSteiner = getLandmarkByName('S');
          const nLandmarkSteiner = getLandmarkByName('N');
          const aLandmarkSteiner = getLandmarkByName('A');
          const bLandmarkSteiner = getLandmarkByName('B');
          
          if (sLandmarkSteiner && nLandmarkSteiner && aLandmarkSteiner && bLandmarkSteiner) {
            const sPos = getLandmarkCanvasPosition(sLandmarkSteiner);
            const nPos = getLandmarkCanvasPosition(nLandmarkSteiner);
            const aPos = getLandmarkCanvasPosition(aLandmarkSteiner);
            const bPos = getLandmarkCanvasPosition(bLandmarkSteiner);
            
            if (sPos && nPos && aPos && bPos) {
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ SNA (Ø¯Ø± Ù†Ù‚Ø·Ù‡ N)
              const snaAngle = calculateAngle(sPos, nPos, aPos);
              let snaAngle1 = Math.atan2(sPos.y - nPos.y, sPos.x - nPos.x);
              let snaAngle2 = Math.atan2(aPos.y - nPos.y, aPos.x - nPos.x);
              
              // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©ØªØ±
              let angleDiff = snaAngle2 - snaAngle1;
              if (angleDiff < 0) angleDiff += 2 * Math.PI;
              if (angleDiff > Math.PI) {
                const temp = snaAngle1;
                snaAngle1 = snaAngle2;
                snaAngle2 = temp;
              }
              if (snaAngle2 < snaAngle1) {
                snaAngle2 += 2 * Math.PI;
              }
              
              // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† SNA
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]);
              ctx.beginPath();
              ctx.arc(nPos.x, nPos.y, radius, snaAngle1, snaAngle2);
              ctx.stroke();
              
              // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ SNA Ø¨Ø§ collision detection Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡
              const isNPosInLowerHalf = nPos.y > canvasHeight / 2;
              
              // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
              const snaBaseOffset = (isMobile ? 12 : 18) * zoom;
              const snaLabelX = nPos.x;
              const snaLabelY = nPos.y - (radius + snaBaseOffset);
              
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
                const snaValue = currentMeasurements?.SNA || snaAngle;
                const snaLabelText = `SNA: ${typeof snaValue === 'number' ? snaValue.toFixed(1) : snaValue}Â°`;
                drawTextWithBackground(snaLabelText, snaLabelX, snaLabelY, fontSize, '#FFD700');
              }
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ SNB (Ø¯Ø± Ù†Ù‚Ø·Ù‡ N)
              const snbAngle = calculateAngle(sPos, nPos, bPos);
              let snbAngle1 = Math.atan2(sPos.y - nPos.y, sPos.x - nPos.x);
              let snbAngle2 = Math.atan2(bPos.y - nPos.y, bPos.x - nPos.x);
              
              // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©ØªØ±
              let snbAngleDiff = snbAngle2 - snbAngle1;
              if (snbAngleDiff < 0) snbAngleDiff += 2 * Math.PI;
              if (snbAngleDiff > Math.PI) {
                const temp = snbAngle1;
                snbAngle1 = snbAngle2;
                snbAngle2 = temp;
              }
              if (snbAngle2 < snbAngle1) {
                snbAngle2 += 2 * Math.PI;
              }
              
              // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† SNB (Ø¨Ø§ ÙØ§ØµÙ„Ù‡ Ú©Ù…ÛŒ Ø§Ø² Ú©Ù…Ø§Ù† SNA)
              const snbRadius = radius + (isMobile ? 7 : 15) * zoom; // Ú©Ù…ÛŒ Ø¨Ø²Ø±Ú¯ØªØ± Ø¨Ø±Ø§ÛŒ ØªÙÚ©ÛŒÚ©
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]);
              ctx.beginPath();
              ctx.arc(nPos.x, nPos.y, snbRadius, snbAngle1, snbAngle2);
              ctx.stroke();
              
              // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ SNB Ø¨Ø§ collision detection Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡
              const isNPosInLowerHalfSNB = nPos.y > canvasHeight / 2;
              
              // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
              const snbBaseOffset = (isMobile ? 12 : 18) * zoom;
              const snbLabelX = nPos.x;
              const snbLabelY = nPos.y - (snbRadius + snbBaseOffset);
              
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
                const snbValue = currentMeasurements?.SNB || snbAngle;
                const snbLabelText = `SNB: ${typeof snbValue === 'number' ? snbValue.toFixed(1) : snbValue}Â°`;
                drawTextWithBackground(snbLabelText, snbLabelX, snbLabelY, fontSize, '#FFD700');
              }
              
            }
          }
          
          // ØªØ±Ø³ÛŒÙ… Ø®Ø· U1 Ùˆ Ø²Ø§ÙˆÛŒÙ‡ U1-SN (Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· U1-U1A Ùˆ Ø®Ø· S-N)
          const u1LandmarkSteiner = getLandmarkByName('U1');
          const u1aLandmarkSteiner = getLandmarkByName('U1A');
          
          if (u1LandmarkSteiner && u1aLandmarkSteiner && sLandmarkSteiner && nLandmarkSteiner) {
            const u1Pos = getLandmarkCanvasPosition(u1LandmarkSteiner);
            const u1aPos = getLandmarkCanvasPosition(u1aLandmarkSteiner);
            const sPosU1 = getLandmarkCanvasPosition(sLandmarkSteiner);
            const nPosU1 = getLandmarkCanvasPosition(nLandmarkSteiner);
            
            if (u1Pos && u1aPos && sPosU1 && nPosU1 && currentMeasurements['U1-SN']) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª (Ù…Ø´Ø§Ø¨Ù‡ L1-MP)
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              drawAngleBetweenLines(u1Pos, u1aPos, nPosU1, sPosU1, currentMeasurements['U1-SN'], 'U1-SN', '#FFD700', fontSize, radius, 'U1', 'U1A', 'S', 'N');
            }
          }
          
          // ØªØ±Ø³ÛŒÙ… Ø®Ø· L1 Ùˆ Ø²Ø§ÙˆÛŒÙ‡ L1-MP
          const l1LandmarkSteiner = getLandmarkByName('L1');
          const l1aLandmarkSteiner = getLandmarkByName('L1A');
          const goLandmarkSteiner = getLandmarkByName('Go');
          const meLandmarkSteiner = getLandmarkByName('Me');
          
          if (l1LandmarkSteiner && l1aLandmarkSteiner && goLandmarkSteiner && meLandmarkSteiner) {
            const l1Pos = getLandmarkCanvasPosition(l1LandmarkSteiner);
            const l1aPos = getLandmarkCanvasPosition(l1aLandmarkSteiner);
            const goPos = getLandmarkCanvasPosition(goLandmarkSteiner);
            const mePos = getLandmarkCanvasPosition(meLandmarkSteiner);
            
            if (l1Pos && l1aPos && goPos && mePos && currentMeasurements['L1-MP']) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              drawAngleBetweenLines(l1Pos, l1aPos, mePos, goPos, currentMeasurements['L1-MP'], 'L1-MP', '#FFD700', fontSize, radius, 'L1', 'L1A', 'Go', 'Me');
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Jarabak - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Go-Me Ùˆ S-N Ùˆ Ø±Ø³Ù… 7 Ø¶Ù„Ø¹ÛŒ
        if (showMeasurements && (analysisType === 'jarabak' || analysisType === 'general')) {
          const sLandmarkJarabak = getLandmarkByName('S');
          const nLandmarkJarabak = getLandmarkByName('N');
          const goLandmarkJarabak = getLandmarkByName('Go');
          const meLandmarkJarabak = getLandmarkByName('Me');
          const ansLandmarkJarabak = getLandmarkByName('ANS');
          const arLandmarkJarabak = getLandmarkByName('Ar');
          
          // Ø±Ø³Ù… 7 Ø¶Ù„Ø¹ÛŒ Jarabak: S -> N -> ANS -> Me -> Go -> Ar -> S
          // ØªØ¹Ø±ÛŒÙ Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù†Ù‚Ø§Ø· Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ú†Ù†Ø¯Ø¶Ù„Ø¹ÛŒ Ùˆ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¨Ø¹Ø¯ÛŒ
          let sPos;
          let nPos;
          let ansPos;
          let mePos;
          let goPos;
          let arPos;
          
          if (sLandmarkJarabak && nLandmarkJarabak && ansLandmarkJarabak && meLandmarkJarabak && goLandmarkJarabak && arLandmarkJarabak) {
            sPos = getLandmarkCanvasPosition(sLandmarkJarabak);
            nPos = getLandmarkCanvasPosition(nLandmarkJarabak);
            ansPos = getLandmarkCanvasPosition(ansLandmarkJarabak);
            mePos = getLandmarkCanvasPosition(meLandmarkJarabak);
            goPos = getLandmarkCanvasPosition(goLandmarkJarabak);
            arPos = getLandmarkCanvasPosition(arLandmarkJarabak);
            
            if (sPos && nPos && ansPos && mePos && goPos && arPos) {
              // ØªØ±Ø³ÛŒÙ… 7 Ø¶Ù„Ø¹ÛŒ Jarabak - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ù…Ø´ØªØ±Ú©
              const lineWidth = actualLineWidth * 1.5;
              
              // Ø®Ø· S-N
              const sColor = landmarkColors.S || landmarkColors.default || '#00D9FF';
              const nColor = landmarkColors.N || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(sPos, nPos, sColor, nColor, lineWidth, false);
              
              // Ø®Ø· N-ANS
              const ansColor = landmarkColors.ANS || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(nPos, ansPos, nColor, ansColor, lineWidth, false);
              
              // Ø®Ø· ANS-Me
              const meColor = landmarkColors.Me || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(ansPos, mePos, ansColor, meColor, lineWidth, false);
              
              // Ø®Ø· Me-Go
              const goColor = landmarkColors.Go || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(mePos, goPos, meColor, goColor, lineWidth, false);
              
              // Ø®Ø· Go-Ar
              const arColor = landmarkColors.Ar || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(goPos, arPos, goColor, arColor, lineWidth, false);
              
              // Ø®Ø· Ar-S
              drawLineWithExtensions(arPos, sPos, arColor, sColor, lineWidth, false);
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø²ÙˆØ§ÛŒØ§ÛŒ 7 Ø¶Ù„Ø¹ÛŒ Jarabak
              // Ø±Ø¦ÙˆØ³: S -> N -> ANS -> Me -> Go -> Ar -> S
              const vertices = [
                { pos: sPos, name: 'S' },
                { pos: nPos, name: 'N' },
                { pos: ansPos, name: 'ANS' },
                { pos: mePos, name: 'Me' },
                { pos: goPos, name: 'Go' },
                { pos: arPos, name: 'Ar' },
              ];
              
              const fontSize = isMobile ? 7 : 11;
              const radius = (isMobile ? 12 : 25) * zoom;
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ø±Ø³Ù… Ú©Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø±Ø£Ø³
              for (let i = 0; i < vertices.length; i++) {
                const prevIdx = (i - 1 + vertices.length) % vertices.length;
                const currIdx = i;
                const nextIdx = (i + 1) % vertices.length;
                
                const prev = vertices[prevIdx].pos;
                const curr = vertices[currIdx].pos;
                const next = vertices[nextIdx].pos;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ø± Ø±Ø£Ø³ ÙØ¹Ù„ÛŒ
                const angle = calculateAngle(prev, curr, next);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ù…Ø§Ù†
                let angle1 = Math.atan2(prev.y - curr.y, prev.x - curr.x);
                let angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                
                // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©ØªØ±
                let angleDiff = angle2 - angle1;
                if (angleDiff < 0) angleDiff += 2 * Math.PI;
                if (angleDiff > Math.PI) {
                  const temp = angle1;
                  angle1 = angle2;
                  angle2 = temp;
                }
                if (angle2 < angle1) {
                  angle2 += 2 * Math.PI;
                }
                
                // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù†
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(curr.x, curr.y, radius, angle1, angle2);
                ctx.stroke();
                
                // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
                const baseOffset = (isMobile ? 12 : 18) * zoom;
                const labelX = curr.x;
                const labelY = curr.y - (radius + baseOffset);
                
                // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
                if (analysisType !== 'general' && analysisType !== 'all') {
                const angleValue = currentMeasurements?.[`Jarabak-${vertices[currIdx].name}`] || angle;
                const labelText = `${vertices[currIdx].name}: ${typeof angleValue === 'number' ? angleValue.toFixed(1) : angleValue}Â°`;
                
                drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
                }
              }
            }
          }
          
          // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Go-Me Ùˆ S-N (Ø§Ú¯Ø± Ù†Ù‚Ø§Ø· Ù„Ø§Ø²Ù… Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ù†Ø¯)
          if (sLandmarkJarabak && nLandmarkJarabak && goLandmarkJarabak && meLandmarkJarabak) {
            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø§Ú¯Ø± Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ù†Ø¯ØŒ Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
            if (!sPos) sPos = getLandmarkCanvasPosition(sLandmarkJarabak);
            if (!nPos) nPos = getLandmarkCanvasPosition(nLandmarkJarabak);
            if (!goPos) goPos = getLandmarkCanvasPosition(goLandmarkJarabak);
            if (!mePos) mePos = getLandmarkCanvasPosition(meLandmarkJarabak);
            
            if (sPos && nPos && goPos && mePos) {
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ·
              const rect = containerRef.current?.getBoundingClientRect();
              const displayWidth = rect?.width || canvas.width;
              const displayHeight = rect?.height || canvas.height;
              const baseExtend = Math.max(displayWidth, displayHeight) + 100;
              const scaledExtend = baseExtend * zoom;
              
              // ØªØ§Ø¨Ø¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø³Ù‡ Ù†Ù‚Ø·Ù‡
              const calculateAngle = (point1, vertex, point2) => {
                const v1x = point1.x - vertex.x;
                const v1y = point1.y - vertex.y;
                const v2x = point2.x - vertex.x;
                const v2y = point2.y - vertex.y;
                
                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                
                if (mag1 === 0 || mag2 === 0) return 0;
                
                const cosAngle = dot / (mag1 * mag2);
                const clampedCos = Math.max(-1, Math.min(1, cosAngle));
                const angle = Math.acos(clampedCos) * (180 / Math.PI);
                
                return angle;
              };
              
              // ØªØ±Ø³ÛŒÙ… Ø®Ø·ÙˆØ· Ø§ØµÙ„ÛŒ
              ctx.lineWidth = actualLineWidth * 1.5;
              ctx.setLineDash([]);
              
              // Ø®Ø· S-N
              ctx.strokeStyle = getLineColor('S', 'N', sPos, nPos);
              ctx.beginPath();
              ctx.moveTo(sPos.x, sPos.y);
              ctx.lineTo(nPos.x, nPos.y);
              ctx.stroke();
              
              // Ø®Ø· Go-Me
              ctx.strokeStyle = getLineColor('Go', 'Me', goPos, mePos);
              ctx.beginPath();
              ctx.moveTo(goPos.x, goPos.y);
              ctx.lineTo(mePos.x, mePos.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ·
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([5 * zoom, 5 * zoom]);
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· S-N Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              const sNDx = nPos.x - sPos.x;
              const sNDy = nPos.y - sPos.y;
              const sNLength = Math.sqrt(sNDx * sNDx + sNDy * sNDy);
              const sNDirX = sNDx / sNLength;
              const sNDirY = sNDy / sNLength;
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù N
              const sNExtendedN = {
                x: nPos.x + sNDirX * scaledExtend,
                y: nPos.y + sNDirY * scaledExtend
              };
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù S
              const sNExtendedS = {
                x: sPos.x - sNDirX * scaledExtend,
                y: sPos.y - sNDirY * scaledExtend
              };
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù N - Ø±Ù†Ú¯ Ø§Ø² N Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ù…Ø«Ù„ Ricketts)
              ctx.strokeStyle = getLineColor('N', 'S', nPos, sNExtendedN);
              ctx.beginPath();
              ctx.moveTo(nPos.x, nPos.y);
              ctx.lineTo(sNExtendedN.x, sNExtendedN.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù S - Ø±Ù†Ú¯ Ø§Ø² S Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
              ctx.strokeStyle = getLineColor('S', 'N', sPos, sNExtendedS);
              ctx.beginPath();
              ctx.moveTo(sPos.x, sPos.y);
              ctx.lineTo(sNExtendedS.x, sNExtendedS.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Go-Me Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              const goMeDx = mePos.x - goPos.x;
              const goMeDy = mePos.y - goPos.y;
              const goMeLength = Math.sqrt(goMeDx * goMeDx + goMeDy * goMeDy);
              const goMeDirX = goMeDx / goMeLength;
              const goMeDirY = goMeDy / goMeLength;
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù Me
              const goMeExtendedMe = {
                x: mePos.x + goMeDirX * scaledExtend,
                y: mePos.y + goMeDirY * scaledExtend
              };
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù Go
              const goMeExtendedGo = {
                x: goPos.x - goMeDirX * scaledExtend,
                y: goPos.y - goMeDirY * scaledExtend
              };
              
              ctx.strokeStyle = getLineColor('Go', 'Me', mePos, goMeExtendedMe);
              ctx.beginPath();
              ctx.moveTo(mePos.x, mePos.y);
              ctx.lineTo(goMeExtendedMe.x, goMeExtendedMe.y);
              ctx.stroke();
              
              ctx.strokeStyle = getLineColor('Go', 'Me', goPos, goMeExtendedGo);
              ctx.beginPath();
              ctx.moveTo(goPos.x, goPos.y);
              ctx.lineTo(goMeExtendedGo.x, goMeExtendedGo.y);
              ctx.stroke();
              
              ctx.setLineDash([]);
              
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Go-Me Ùˆ S-N (Ø¯Ø± Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹)
              // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹
              const getLineIntersection = (p1, p2, p3, p4) => {
                const x1 = p1.x;
                const y1 = p1.y;
                const x2 = p2.x;
                const y2 = p2.y;
                const x3 = p3.x;
                const y3 = p3.y;
                const x4 = p4.x;
                const y4 = p4.y;
                
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 0.001) return null;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                  return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                  };
                }
                
                // Ø§Ú¯Ø± Ø®Ø·ÙˆØ· Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø®ÙˆØ¯Ø´Ø§Ù† ØªÙ‚Ø§Ø·Ø¹ Ù†Ø¯Ø§Ø±Ù†Ø¯ØŒ Ø§Ø² Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
                const intersectionX = x1 + t * (x2 - x1);
                const intersectionY = y1 + t * (y2 - y1);
                return { x: intersectionX, y: intersectionY };
              };
              
              // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªÙ‚Ø§Ø·Ø¹ Ø¨ÛŒÙ† Ø§Ù…ØªØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø®Ø·ÙˆØ·
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ù…ØªØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªÙ‚Ø§Ø·Ø¹
              const intersection = getLineIntersection(sNExtendedS, sNExtendedN, goMeExtendedGo, goMeExtendedMe);
              
              if (intersection) {
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡
                // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¬Ù‡Øª Ø®Ø·ÙˆØ· Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡
                const goMeAngle = Math.atan2(goMeExtendedMe.y - intersection.y, goMeExtendedMe.x - intersection.x);
                const sNAngle = Math.atan2(sNExtendedN.y - intersection.y, sNExtendedN.x - intersection.x);
                
                let angleDiff = Math.abs(goMeAngle - sNAngle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                const angleDegrees = angleDiff * (180 / Math.PI);
                
                // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ø²Ø§ÙˆÛŒÙ‡
                const fontSize = isMobile ? 7 : 12;
                const radius = (isMobile ? 10 : 30) * zoom;
                
                // ØªØ¹ÛŒÛŒÙ† Ø¬Ù‡Øª ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù†
                let startAngle = sNAngle;
                let endAngle = goMeAngle;
                
                // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©ØªØ±
                let angleDiff1 = endAngle - startAngle;
                if (angleDiff1 < 0) angleDiff1 += 2 * Math.PI;
                let angleDiff2 = startAngle - endAngle;
                if (angleDiff2 < 0) angleDiff2 += 2 * Math.PI;
                
                if (angleDiff2 < angleDiff1) {
                  const temp = startAngle;
                  startAngle = endAngle;
                  endAngle = temp;
                }
                
                if (endAngle < startAngle) {
                  endAngle += 2 * Math.PI;
                }
                
                const finalDiff = endAngle - startAngle;
                if (finalDiff > Math.PI) {
                  const newEndAngle = endAngle - 2 * Math.PI;
                  if (newEndAngle < startAngle) {
                    startAngle -= 2 * Math.PI;
                  } else {
                    endAngle = newEndAngle;
                  }
                }
                
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([]); // solid arc
                ctx.beginPath();
                ctx.arc(intersection.x, intersection.y, radius, startAngle, endAngle);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ø¯Ø±Ø³Øª Ø¨Ø§Ù„Ø§ÛŒ Ù†Ù‚Ø·Ù‡ Ù…Ø±Ú©Ø²ÛŒ (vertex)
                // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
                if (analysisType !== 'general' && analysisType !== 'all') {
                  const labelX = intersection.x;
                  const labelY = intersection.y - (radius + (isMobile ? 18 : 25) * zoom);
                  
                  const labelText = `GoMe-SN: ${typeof angleDegrees === 'number' ? angleDegrees.toFixed(1) : angleDegrees}Â°`;
                  drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
                }
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Sassouni - Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
        if (showMeasurements && analysisType === 'sassouni') {
          const sLandmarkSassouni = getLandmarkByName('S');
          const nLandmarkSassouni = getLandmarkByName('N');
          const gnLandmarkSassouni = getLandmarkByName('Gn');
          const meLandmarkSassouni = getLandmarkByName('Me');
          const goLandmarkSassouni = getLandmarkByName('Go');
          const arLandmarkSassouni = getLandmarkByName('Ar');
          const coLandmarkSassouni = getLandmarkByName('Co') || getLandmarkByName('co') || getLandmarkByName('CO') || getLandmarkByName('condyle') || getLandmarkByName('Condyle');
          const ansLandmarkSassouni = getLandmarkByName('ANS');
          const pnsLandmarkSassouni = getLandmarkByName('PNS');
          const l1LandmarkSassouni = getLandmarkByName('L1');
          const lmtLandmarkSassouni = getLandmarkByName('LMT');
          const umtLandmarkSassouni = getLandmarkByName('UMT');
          
          if (sLandmarkSassouni && nLandmarkSassouni && meLandmarkSassouni && goLandmarkSassouni && arLandmarkSassouni) {
            const sPos = getLandmarkCanvasPosition(sLandmarkSassouni);
            const nPos = getLandmarkCanvasPosition(nLandmarkSassouni);
            const gnPos = gnLandmarkSassouni ? getLandmarkCanvasPosition(gnLandmarkSassouni) : null;
            const mePos = getLandmarkCanvasPosition(meLandmarkSassouni);
            const goPos = getLandmarkCanvasPosition(goLandmarkSassouni);
            const arPos = getLandmarkCanvasPosition(arLandmarkSassouni);
            const coPos = coLandmarkSassouni ? getLandmarkCanvasPosition(coLandmarkSassouni) : null;
            const ansPos = ansLandmarkSassouni ? getLandmarkCanvasPosition(ansLandmarkSassouni) : null;
            const pnsPos = pnsLandmarkSassouni ? getLandmarkCanvasPosition(pnsLandmarkSassouni) : null;
            const l1Pos = l1LandmarkSassouni ? getLandmarkCanvasPosition(l1LandmarkSassouni) : null;
            const lmtPos = lmtLandmarkSassouni ? getLandmarkCanvasPosition(lmtLandmarkSassouni) : null;
            const umtPos = umtLandmarkSassouni ? getLandmarkCanvasPosition(umtLandmarkSassouni) : null;
            
            if (sPos && nPos && mePos && goPos && arPos) {
              // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ·
              const rect = containerRef.current?.getBoundingClientRect();
              const displayWidth = rect?.width || canvas.width;
              const displayHeight = rect?.height || canvas.height;
              const baseExtend = Math.max(displayWidth, displayHeight) + 100;
              const scaledExtend = baseExtend * zoom;
              
              // ØªØ§Ø¨Ø¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø³Ù‡ Ù†Ù‚Ø·Ù‡
              const calculateAngle = (point1, vertex, point2) => {
                const v1x = point1.x - vertex.x;
                const v1y = point1.y - vertex.y;
                const v2x = point2.x - vertex.x;
                const v2y = point2.y - vertex.y;
                
                const dot = v1x * v2x + v1y * v2y;
                const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                
                if (mag1 === 0 || mag2 === 0) return 0;
                
                const cosAngle = dot / (mag1 * mag2);
                const clampedCos = Math.max(-1, Math.min(1, cosAngle));
                const angle = Math.acos(clampedCos) * (180 / Math.PI);
                
                return angle;
              };
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ· S-NØŒ Me-GoØŒ Occlusal Plane Ùˆ ANS-PNS (Ø®Ø·ÙˆØ· Ø§ØµÙ„ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ ANALYSIS_LINES Ø±Ø³Ù… Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯)
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([5 * zoom, 5 * zoom]);
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· S-N Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              const sNDx = nPos.x - sPos.x;
              const sNDy = nPos.y - sPos.y;
              const sNLength = Math.sqrt(sNDx * sNDx + sNDy * sNDy);
              const sNDirX = sNDx / sNLength;
              const sNDirY = sNDy / sNLength;
              const sNExtendedN = {
                x: nPos.x + sNDirX * scaledExtend,
                y: nPos.y + sNDirY * scaledExtend
              };
              const sNExtendedS = {
                x: sPos.x - sNDirX * scaledExtend,
                y: sPos.y - sNDirY * scaledExtend
              };
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù N - Ø±Ù†Ú¯ Ø§Ø² N Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ù…Ø«Ù„ Ricketts)
              ctx.strokeStyle = getLineColor('N', 'S', nPos, sNExtendedN);
              ctx.beginPath();
              ctx.moveTo(nPos.x, nPos.y);
              ctx.lineTo(sNExtendedN.x, sNExtendedN.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù S - Ø±Ù†Ú¯ Ø§Ø² S Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
              ctx.strokeStyle = getLineColor('S', 'N', sPos, sNExtendedS);
              ctx.beginPath();
              ctx.moveTo(sPos.x, sPos.y);
              ctx.lineTo(sNExtendedS.x, sNExtendedS.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Me-Go Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              const meGoDx = goPos.x - mePos.x;
              const meGoDy = goPos.y - mePos.y;
              const meGoLength = Math.sqrt(meGoDx * meGoDx + meGoDy * meGoDy);
              const meGoDirX = meGoDx / meGoLength;
              const meGoDirY = meGoDy / meGoLength;
              const meGoExtendedGo = {
                x: goPos.x + meGoDirX * scaledExtend,
                y: goPos.y + meGoDirY * scaledExtend
              };
              const meGoExtendedMe = {
                x: mePos.x - meGoDirX * scaledExtend,
                y: mePos.y - meGoDirY * scaledExtend
              };
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù Go - Ø±Ù†Ú¯ Ø§Ø² Go Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
              ctx.strokeStyle = getLineColor('Go', 'Me', goPos, meGoExtendedGo);
              ctx.beginPath();
              ctx.moveTo(goPos.x, goPos.y);
              ctx.lineTo(meGoExtendedGo.x, meGoExtendedGo.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù Me - Ø±Ù†Ú¯ Ø§Ø² Me Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
              ctx.strokeStyle = getLineColor('Me', 'Go', mePos, meGoExtendedMe);
              ctx.beginPath();
              ctx.moveTo(mePos.x, mePos.y);
              ctx.lineTo(meGoExtendedMe.x, meGoExtendedMe.y);
              ctx.stroke();
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· Occlusal Plane (L1-Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ LMT Ùˆ UMT) Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              if (l1Pos && lmtPos) {
                // Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ Occlusal Plane: Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÛŒÙ† LMT Ùˆ UMT
                const occlusalEndPos = umtPos ? {
                  x: (lmtPos.x + umtPos.x) / 2,
                  y: (lmtPos.y + umtPos.y) / 2
                } : lmtPos;
                
                const occlusalDx = occlusalEndPos.x - l1Pos.x;
                const occlusalDy = occlusalEndPos.y - l1Pos.y;
                const occlusalLength = Math.sqrt(occlusalDx * occlusalDx + occlusalDy * occlusalDy);
                if (occlusalLength > 0) {
                  const occlusalDirX = occlusalDx / occlusalLength;
                  const occlusalDirY = occlusalDy / occlusalLength;
                  const occlusalExtendedEnd = {
                    x: occlusalEndPos.x + occlusalDirX * scaledExtend,
                    y: occlusalEndPos.y + occlusalDirY * scaledExtend
                  };
                  const occlusalExtendedL1 = {
                    x: l1Pos.x - occlusalDirX * scaledExtend,
                    y: l1Pos.y - occlusalDirY * scaledExtend
                  };
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ - Ø±Ù†Ú¯ Ø§Ø² LMT Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                  ctx.strokeStyle = getLineColor('LMT', 'L1', occlusalEndPos, occlusalExtendedEnd);
                  ctx.beginPath();
                  ctx.moveTo(occlusalEndPos.x, occlusalEndPos.y);
                  ctx.lineTo(occlusalExtendedEnd.x, occlusalExtendedEnd.y);
                  ctx.stroke();
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù L1 - Ø±Ù†Ú¯ Ø§Ø² L1 Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                  ctx.strokeStyle = getLineColor('L1', 'LMT', l1Pos, occlusalExtendedL1);
                  ctx.beginPath();
                  ctx.moveTo(l1Pos.x, l1Pos.y);
                  ctx.lineTo(occlusalExtendedL1.x, occlusalExtendedL1.y);
                  ctx.stroke();
                }
              }
              
              // Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø· ANS-PNS Ø§Ø² Ù‡Ø± Ø¯Ùˆ Ø·Ø±Ù
              if (ansPos && pnsPos) {
                const ansPnsDx = pnsPos.x - ansPos.x;
                const ansPnsDy = pnsPos.y - ansPos.y;
                const ansPnsLength = Math.sqrt(ansPnsDx * ansPnsDx + ansPnsDy * ansPnsDy);
                if (ansPnsLength > 0) {
                  const ansPnsDirX = ansPnsDx / ansPnsLength;
                  const ansPnsDirY = ansPnsDy / ansPnsLength;
                  const ansPnsExtendedPNS = {
                    x: pnsPos.x + ansPnsDirX * scaledExtend,
                    y: pnsPos.y + ansPnsDirY * scaledExtend
                  };
                  const ansPnsExtendedANS = {
                    x: ansPos.x - ansPnsDirX * scaledExtend,
                    y: ansPos.y - ansPnsDirY * scaledExtend
                  };
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù PNS - Ø±Ù†Ú¯ Ø§Ø² PNS Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                  ctx.strokeStyle = getLineColor('PNS', 'ANS', pnsPos, ansPnsExtendedPNS);
                  ctx.beginPath();
                  ctx.moveTo(pnsPos.x, pnsPos.y);
                  ctx.lineTo(ansPnsExtendedPNS.x, ansPnsExtendedPNS.y);
                  ctx.stroke();
                  
                  // Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø·Ø±Ù ANS - Ø±Ù†Ú¯ Ø§Ø² ANS Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯
                  ctx.strokeStyle = getLineColor('ANS', 'PNS', ansPos, ansPnsExtendedANS);
                  ctx.beginPath();
                  ctx.moveTo(ansPos.x, ansPos.y);
                  ctx.lineTo(ansPnsExtendedANS.x, ansPnsExtendedANS.y);
                  ctx.stroke();
                }
              }
              
              ctx.setLineDash([]);
              
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              
              // 1. Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† S-N Ùˆ Me-Go (Ø¯Ø± Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹)
              const getLineIntersection = (p1, p2, p3, p4) => {
                const x1 = p1.x;
                const y1 = p1.y;
                const x2 = p2.x;
                const y2 = p2.y;
                const x3 = p3.x;
                const y3 = p3.y;
                const x4 = p4.x;
                const y4 = p4.y;
                
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < 0.001) return null;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                  return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                  };
                }
                
                const intersectionX = x1 + t * (x2 - x1);
                const intersectionY = y1 + t * (y2 - y1);
                return { x: intersectionX, y: intersectionY };
              };
              
              // Ú©Ù…Ø§Ù† Ø¨ÛŒÙ† Go-Me Ùˆ S-N (Ù…Ø´Ø§Ø¨Ù‡ Jarabak)
              const intersection = getLineIntersection(sNExtendedS, sNExtendedN, meGoExtendedGo, meGoExtendedMe);
              
              if (intersection) {
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡
                // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¬Ù‡Øª Ø®Ø·ÙˆØ· Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡
                const goMeAngle = Math.atan2(meGoExtendedMe.y - intersection.y, meGoExtendedMe.x - intersection.x);
                const sNAngle = Math.atan2(sNExtendedN.y - intersection.y, sNExtendedN.x - intersection.x);
                
                let angleDiff = Math.abs(goMeAngle - sNAngle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                const angleDegrees = angleDiff * (180 / Math.PI);
                
                // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ø²Ø§ÙˆÛŒÙ‡
                const fontSize = isMobile ? 7 : 12;
                const radius = (isMobile ? 10 : 30) * zoom;
                
                // ØªØ¹ÛŒÛŒÙ† Ø¬Ù‡Øª ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù†
                let startAngle = sNAngle;
                let endAngle = goMeAngle;
                
                // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ú©ÙˆÚ†Ú©ØªØ±
                let angleDiff1 = endAngle - startAngle;
                if (angleDiff1 < 0) angleDiff1 += 2 * Math.PI;
                let angleDiff2 = startAngle - endAngle;
                if (angleDiff2 < 0) angleDiff2 += 2 * Math.PI;
                
                if (angleDiff2 < angleDiff1) {
                  const temp = startAngle;
                  startAngle = endAngle;
                  endAngle = temp;
                }
                
                if (endAngle < startAngle) {
                  endAngle += 2 * Math.PI;
                }
                
                const finalDiff = endAngle - startAngle;
                if (finalDiff > Math.PI) {
                  const newEndAngle = endAngle - 2 * Math.PI;
                  if (newEndAngle < startAngle) {
                    startAngle -= 2 * Math.PI;
                  } else {
                    endAngle = newEndAngle;
                  }
                }
                
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([]); // solid arc
                ctx.beginPath();
                ctx.arc(intersection.x, intersection.y, radius, startAngle, endAngle);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ø¯Ø±Ø³Øª Ø¨Ø§Ù„Ø§ÛŒ Ù†Ù‚Ø·Ù‡ Ù…Ø±Ú©Ø²ÛŒ (vertex)
                // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
                if (analysisType !== 'general' && analysisType !== 'all') {
                  const labelX = intersection.x;
                  const labelY = intersection.y - (radius + (isMobile ? 18 : 25) * zoom);
                  
                  const labelText = `GoMe-SN: ${typeof angleDegrees === 'number' ? angleDegrees.toFixed(1) : angleDegrees}Â°`;
                  drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
                }
              }
              
              // 2. Ø²Ø§ÙˆÛŒÙ‡ Gn-S-N Ø­Ø°Ù Ø´Ø¯Ù‡
              
              // 3. Ø²Ø§ÙˆÛŒÙ‡ N-S-Ar (Ø¯Ø± Ù†Ù‚Ø·Ù‡ S)
              const nSArAngle = calculateAngle(nPos, sPos, arPos);
              let nSArAngle1 = Math.atan2(nPos.y - sPos.y, nPos.x - sPos.x);
              let nSArAngle2 = Math.atan2(arPos.y - sPos.y, arPos.x - sPos.x);
              
              let nSArAngleDiff = nSArAngle2 - nSArAngle1;
              if (nSArAngleDiff < 0) nSArAngleDiff += 2 * Math.PI;
              
              if (nSArAngleDiff > Math.PI) {
                const temp = nSArAngle1;
                nSArAngle1 = nSArAngle2;
                nSArAngle2 = temp;
                if (nSArAngle2 < nSArAngle1) {
                  nSArAngle2 += 2 * Math.PI;
                }
                const checkDiff = nSArAngle2 - nSArAngle1;
                if (checkDiff > Math.PI) {
                  const newEndAngle = nSArAngle2 - 2 * Math.PI;
                  if (newEndAngle < nSArAngle1) {
                    nSArAngle1 -= 2 * Math.PI;
                  } else {
                    nSArAngle2 = newEndAngle;
                  }
                }
              } else {
                if (nSArAngle2 < nSArAngle1) {
                  nSArAngle2 += 2 * Math.PI;
                }
              }
              
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid arc
              ctx.beginPath();
              ctx.arc(sPos.x, sPos.y, radius, nSArAngle1, nSArAngle2);
              ctx.stroke();
              ctx.setLineDash([]);
              
              // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ø¨Ø§ collision detection Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡
              const isSPosInLowerHalf = sPos.y > canvasHeight / 2;
              
              // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
              const nSArBaseOffset = (isMobile ? 12 : 18) * zoom;
              const nSArLabelX = sPos.x;
              const nSArLabelY = sPos.y - (radius + nSArBaseOffset);
              
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
              const nSArLabelText = `S: ${typeof nSArAngle === 'number' ? nSArAngle.toFixed(1) : nSArAngle}Â°`;
              drawTextWithBackground(nSArLabelText, nSArLabelX, nSArLabelY, fontSize, '#FFD700');
              }
              
              // 4. Ø²Ø§ÙˆÛŒÙ‡ S-Ar-Go (Ø¯Ø± Ù†Ù‚Ø·Ù‡ Ar)
              const sArGoAngle = calculateAngle(sPos, arPos, goPos);
              let sArGoAngle1 = Math.atan2(sPos.y - arPos.y, sPos.x - arPos.x);
              let sArGoAngle2 = Math.atan2(goPos.y - arPos.y, goPos.x - arPos.x);
              
              let sArGoAngleDiff = sArGoAngle2 - sArGoAngle1;
              if (sArGoAngleDiff < 0) sArGoAngleDiff += 2 * Math.PI;
              
              if (sArGoAngleDiff > Math.PI) {
                const temp = sArGoAngle1;
                sArGoAngle1 = sArGoAngle2;
                sArGoAngle2 = temp;
                if (sArGoAngle2 < sArGoAngle1) {
                  sArGoAngle2 += 2 * Math.PI;
                }
                const checkDiff = sArGoAngle2 - sArGoAngle1;
                if (checkDiff > Math.PI) {
                  const newEndAngle = sArGoAngle2 - 2 * Math.PI;
                  if (newEndAngle < sArGoAngle1) {
                    sArGoAngle1 -= 2 * Math.PI;
                  } else {
                    sArGoAngle2 = newEndAngle;
                  }
                }
              } else {
                if (sArGoAngle2 < sArGoAngle1) {
                  sArGoAngle2 += 2 * Math.PI;
                }
              }
              
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid arc
              ctx.beginPath();
              ctx.arc(arPos.x, arPos.y, radius, sArGoAngle1, sArGoAngle2);
              ctx.stroke();
              ctx.setLineDash([]);
              
              // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ø¨Ø§ collision detection Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡
              const isArPosInLowerHalf = arPos.y > canvasHeight / 2;
              
              // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
              const sArGoBaseOffset = (isMobile ? 12 : 18) * zoom;
              const sArGoLabelX = arPos.x;
              const sArGoLabelY = arPos.y - (radius + sArGoBaseOffset);
              
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
              const sArGoLabelText = `Ar: ${typeof sArGoAngle === 'number' ? sArGoAngle.toFixed(1) : sArGoAngle}Â°`;
              drawTextWithBackground(sArGoLabelText, sArGoLabelX, sArGoLabelY, fontSize, '#FFD700');
              }
              
              // 5. Ø²Ø§ÙˆÛŒÙ‡ Ar-Go-Me (Ø¯Ø± Ù†Ù‚Ø·Ù‡ Go)
              const arGoMeAngle = calculateAngle(arPos, goPos, mePos);
              let arGoMeAngle1 = Math.atan2(arPos.y - goPos.y, arPos.x - goPos.x);
              let arGoMeAngle2 = Math.atan2(mePos.y - goPos.y, mePos.x - goPos.x);
              
              let arGoMeAngleDiff = arGoMeAngle2 - arGoMeAngle1;
              if (arGoMeAngleDiff < 0) arGoMeAngleDiff += 2 * Math.PI;
              
              if (arGoMeAngleDiff > Math.PI) {
                const temp = arGoMeAngle1;
                arGoMeAngle1 = arGoMeAngle2;
                arGoMeAngle2 = temp;
                if (arGoMeAngle2 < arGoMeAngle1) {
                  arGoMeAngle2 += 2 * Math.PI;
                }
                const checkDiff = arGoMeAngle2 - arGoMeAngle1;
                if (checkDiff > Math.PI) {
                  const newEndAngle = arGoMeAngle2 - 2 * Math.PI;
                  if (newEndAngle < arGoMeAngle1) {
                    arGoMeAngle1 -= 2 * Math.PI;
                  } else {
                    arGoMeAngle2 = newEndAngle;
                  }
                }
              } else {
                if (arGoMeAngle2 < arGoMeAngle1) {
                  arGoMeAngle2 += 2 * Math.PI;
                }
              }
              
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid arc
              ctx.beginPath();
              ctx.arc(goPos.x, goPos.y, radius, arGoMeAngle1, arGoMeAngle2);
              ctx.stroke();
              ctx.setLineDash([]);
              
              // Ù†Ù…Ø§ÛŒØ´ Ø¨Ø±Ú†Ø³Ø¨ Ø¨Ø§ collision detection Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡
              const isGoPosInLowerHalf = goPos.y > canvasHeight / 2;
              
              // Ú©Ø§Ù‡Ø´ ÙØ§ØµÙ„Ù‡ Ø§Ø² Ø±Ø£Ø³
              const arGoMeBaseOffset = (isMobile ? 12 : 18) * zoom;
              const arGoMeLabelX = goPos.x;
              const arGoMeLabelY = goPos.y - (radius + arGoMeBaseOffset);
              
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
              const arGoMeLabelText = `Go: ${typeof arGoMeAngle === 'number' ? arGoMeAngle.toFixed(1) : arGoMeAngle}Â°`;
              drawTextWithBackground(arGoMeLabelText, arGoMeLabelX, arGoMeLabelY, fontSize, '#FFD700');
              }
              
              // 6. Sagittal Differentiation Angle - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Go-Co Ùˆ N-S
              if (coPos && goPos && sPos && nPos) {
                const currentMeasurements = Object.keys(calculatedMeasurements).length > 0 ? calculatedMeasurements : (measurements || {});
                let sagittalDiffAngle = currentMeasurements && currentMeasurements['Sagittal Differentiation Angle'] 
                  ? parseFloat(currentMeasurements['Sagittal Differentiation Angle']) 
                  : undefined;
                
                // ØªØ§Ø¨Ø¹ Ù…Ø­Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø®Ø·
                const calculateAngleBetweenLinesLocal = (line1Start, line1End, line2Start, line2End) => {
                  const v1x = line1End.x - line1Start.x;
                  const v1y = line1End.y - line1Start.y;
                  const v2x = line2End.x - line2Start.x;
                  const v2y = line2End.y - line2Start.y;
                  
                  const dotProduct = v1x * v2x + v1y * v2y;
                  const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
                  const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
                  
                  if (mag1 === 0 || mag2 === 0) return 0;
                  
                  const cosAngle = dotProduct / (mag1 * mag2);
                  const clampedCos = Math.max(-1, Math.min(1, cosAngle));
                  const angleRad = Math.acos(clampedCos);
                  const angleDeg = angleRad * (180 / Math.PI);
                  
                  return angleDeg > 90 ? 180 - angleDeg : angleDeg;
                };
                
                // Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø²Ø§ÙˆÛŒÙ‡ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
                if (sagittalDiffAngle === undefined || sagittalDiffAngle === null || isNaN(sagittalDiffAngle)) {
                  const calculatedAngle = calculateAngleBetweenLinesLocal(goPos, coPos, nPos, sPos);
                  if (calculatedAngle !== null && !isNaN(calculatedAngle)) {
                    sagittalDiffAngle = calculatedAngle;
                  }
                }
                
                if (sagittalDiffAngle !== undefined && sagittalDiffAngle !== null && !isNaN(sagittalDiffAngle)) {
                  // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡
                  drawAngleBetweenLines(
                    goPos, coPos,  // Ø®Ø· Ø§ÙˆÙ„: Go-Co
                    nPos, sPos,    // Ø®Ø· Ø¯ÙˆÙ…: N-S
                    sagittalDiffAngle,
                    'Sagittal Differentiation',
                    '#FFD700',
                    fontSize,
                    radius,
                    'Go', 'Co', 'N', 'S',
                    true
                  );
                }
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Legan & Burstone (Soft Tissue) - Ø®Ø·ÙˆØ· Ùˆ Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù…
        // Ù…Ø·Ø§Ø¨Ù‚ Ø¨Ø§ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù…Ø¯Ù„ CLdetection2023
        if (showMeasurements && (analysisType === 'leganBurstone' || analysisType === 'all')) {
          const gLandmark = getLandmarkByName('G');
          const snLandmark = getLandmarkByName('Sn');
          const pgPrimeLandmark = getLandmarkByName('Pog\'');
          const cmLandmark = getLandmarkByName('Cm');
          const lsLandmark = getLandmarkByName('UL');
          const liLandmark = getLandmarkByName('LL');
          
          if (gLandmark && snLandmark && pgPrimeLandmark) {
            const gPos = getLandmarkCanvasPosition(gLandmark);
            const snPos = getLandmarkCanvasPosition(snLandmark);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmark);
            
            if (gPos && snPos && pgPrimePos) {
              // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Glabella-Sn-Pog' (Facial Convexity) - Ù…Ø´Ø§Ø¨Ù‡ steiner
              // drawAngle Ø®ÙˆØ¯Ø´ Ø®Ø·ÙˆØ· Ø±Ø§ Ø¨Ø§ gradient Ùˆ Ø®Ø· Ú†ÛŒÙ† Ø±Ø³Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              let facialConvexityValue = currentMeasurements?.['Glabella-Sn-Pog\' (Facial Convexity)'];
              // Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªØŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
              if (facialConvexityValue === undefined || facialConvexityValue === null) {
                facialConvexityValue = calculateAngle(gPos, snPos, pgPrimePos);
              }
              // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & BurstoneØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
              drawAngle(gPos, snPos, pgPrimePos, facialConvexityValue, 'Glabella-Sn-Pog\'', '#FFD700', fontSize, radius, 'G', 'Pog\'', false);
              
              // Ø±Ø³Ù… Nasolabial Angle (Cm-Sn-UL)
              if (cmLandmark && lsLandmark) {
                const cmPos = getLandmarkCanvasPosition(cmLandmark);
                const lsPos = getLandmarkCanvasPosition(lsLandmark);
                
                if (cmPos && lsPos) {
                  // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Nasolabial - Ù…Ø´Ø§Ø¨Ù‡ steiner
                  // drawAngle Ø®ÙˆØ¯Ø´ Ø®Ø·ÙˆØ· Ø±Ø§ Ø¨Ø§ gradient Ùˆ Ø®Ø· Ú†ÛŒÙ† Ø±Ø³Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯
                  let nasolabialValue = currentMeasurements?.NasolabialAngle;
                  // Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªØŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
                  if (nasolabialValue === undefined || nasolabialValue === null) {
                    nasolabialValue = calculateAngle(cmPos, snPos, lsPos);
                  }
                  const nasoRadius = radius * 0.8;
                  // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & BurstoneØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
                  drawAngle(cmPos, snPos, lsPos, nasolabialValue, 'Nasolabial', '#FFD700', fontSize, nasoRadius, 'Cm', 'UL', false);
                }
              }
              
              // Ø±Ø³Ù… Z-Angle (Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Or-Po Ùˆ Pog'-UL)
              const orLandmarkZ = getLandmarkByName('Or');
              const poLandmarkZ = getLandmarkByName('Po');
              if (orLandmarkZ && poLandmarkZ && pgPrimeLandmark && lsLandmark) {
                const orPos = getLandmarkCanvasPosition(orLandmarkZ);
                const poPos = getLandmarkCanvasPosition(poLandmarkZ);
                const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmark);
                const lsPos = getLandmarkCanvasPosition(lsLandmark);
                
                if (orPos && poPos && pgPrimePos && lsPos) {
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Z
                  let zAngleValue = currentMeasurements?.['Z-Angle'];
                  if (zAngleValue === undefined || zAngleValue === null) {
                    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø®Ø·
                    const calculatedAngle = calculateAngleBetweenLines(orPos, poPos, pgPrimePos, lsPos);
                    // ğŸ”§ FIX: Ù…Ù‚Ø¯Ø§Ø± Z-Angle Ø¨Ø§ÛŒØ¯ Ø§Ø² 180 Ú©Ù… Ø´ÙˆØ¯
                    zAngleValue = 180 - calculatedAngle;
                  }
                  
                  // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø®Ø· Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines
                  // Ø®Ø·ÙˆØ· Or-Po Ùˆ UL-Pog' Ø¨Ø§ÛŒØ¯ ØªØ§ Ù…Ø­Ù„ ØªØ´Ú©ÛŒÙ„ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®ÙˆØ¯ Ø§Ù…ØªØ¯Ø§Ø¯ ÛŒØ§Ø¨Ù†Ø¯
                  drawAngleBetweenLines(
                    orPos, poPos,  // Ø®Ø· Ø§ÙˆÙ„: Or-Po (Frankfort Horizontal)
                    pgPrimePos, lsPos,  // Ø®Ø· Ø¯ÙˆÙ…: Pog'-UL
                    zAngleValue,
                    'Z-Angle',
                    '#FFD700',
                    fontSize,
                    radius,
                    'Or', 'Po', 'Pog\'', 'UL',
                    true  // Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ú©Ù† ØªØ§ Ù…Ø­Ù„ ØªØ´Ú©ÛŒÙ„ Ø²Ø§ÙˆÛŒÙ‡
                  );
                }
              }
              
              // Ø±Ø³Ù… Total Soft-Tissue Convexity (Pog'-Prn-G)
              const prnLandmarkTotal = getLandmarkByName('Pn');
              if (pgPrimeLandmark && prnLandmarkTotal && gLandmark) {
                const pgPrimePosTotal = getLandmarkCanvasPosition(pgPrimeLandmark);
                const prnPosTotal = getLandmarkCanvasPosition(prnLandmarkTotal);
                const gPosTotal = getLandmarkCanvasPosition(gLandmark);
                
                if (pgPrimePosTotal && prnPosTotal && gPosTotal) {
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Total Soft-Tissue Convexity
                  let totalConvexityValue = currentMeasurements?.['Total Soft-Tissue Convexity'];
                  if (totalConvexityValue === undefined || totalConvexityValue === null) {
                    totalConvexityValue = calculateAngle(pgPrimePosTotal, prnPosTotal, gPosTotal);
                  }
                  
                  // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Pog'-Prn-G - Ù…Ø´Ø§Ø¨Ù‡ steiner
                  // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & BurstoneØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
                  drawAngle(pgPrimePosTotal, prnPosTotal, gPosTotal, totalConvexityValue, 'Total Convexity', '#FFD700', fontSize, radius, 'Pog\'', 'G', false);
 }
              }
              
              // Ø±Ø³Ù… Lower Face Throat Angle (Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Snâ€“Gn' Ùˆ Gn'â€“C)
              const gnPrimeLandmarkThroat = getLandmarkByName('Gn\'');
              const cLandmarkThroat = getLandmarkByName('C');
              if (snLandmark && gnPrimeLandmarkThroat && cLandmarkThroat) {
                const snPosThroat = getLandmarkCanvasPosition(snLandmark);
                const gnPrimePosThroat = getLandmarkCanvasPosition(gnPrimeLandmarkThroat);
                const cPosThroat = getLandmarkCanvasPosition(cLandmarkThroat);
                
                if (snPosThroat && gnPrimePosThroat && cPosThroat) {
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Lower Face Throat Angle
                  let lowerFaceThroatValue = currentMeasurements?.['Lower Face Throat Angle'];
                  if (lowerFaceThroatValue === undefined || lowerFaceThroatValue === null) {
                    lowerFaceThroatValue = calculateAngle(snPosThroat, gnPrimePosThroat, cPosThroat);
                  }
                  
                  // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Snâ€“Gn'â€“C - Ù…Ø´Ø§Ø¨Ù‡ steiner
                  // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & BurstoneØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
                  drawAngle(snPosThroat, gnPrimePosThroat, cPosThroat, lowerFaceThroatValue, 'Lower Face Throat', '#FFD700', fontSize, radius, 'Sn', 'C', false);
                }
              }
              
              // Ø±Ø³Ù… Facial Contour Angle (Nâ€²âˆ’Prnâˆ’Pogâ€²)
              const nPrimeLandmarkContour = getLandmarkByName('N\'') || getLandmarkByName('N');
              const prnLandmarkContour = getLandmarkByName('Pn');
              if (nPrimeLandmarkContour && prnLandmarkContour && pgPrimeLandmark) {
                const nPrimePosContour = getLandmarkCanvasPosition(nPrimeLandmarkContour);
                const prnPosContour = getLandmarkCanvasPosition(prnLandmarkContour);
                const pgPrimePosContour = getLandmarkCanvasPosition(pgPrimeLandmark);
                
                if (nPrimePosContour && prnPosContour && pgPrimePosContour) {
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Facial Contour Angle
                  let facialContourValue = currentMeasurements?.['Facial Contour Angle'];
                  if (facialContourValue === undefined || facialContourValue === null) {
                    facialContourValue = calculateAngle(nPrimePosContour, prnPosContour, pgPrimePosContour);
                  }
                  
                  // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Nâ€²âˆ’Prnâˆ’Pogâ€² - Ù…Ø´Ø§Ø¨Ù‡ steiner
                  // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Legan & BurstoneØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
                  drawAngle(nPrimePosContour, prnPosContour, pgPrimePosContour, facialContourValue, 'Facial Contour', '#FFD700', fontSize, radius, 'N\'', 'Pog\'', false);
                }
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Holdaway (Soft Tissue)
        if (analysisType === 'holdaway' || analysisType === 'all') {
          const currentMeasurements = Object.keys(calculatedMeasurements).length > 0 ? calculatedMeasurements : (measurements || {});
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
          
          // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ (Ù…Ø´Ø§Ø¨Ù‡ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø¯ÛŒÚ¯Ø±)
          const sLandmark = getLandmarkByName('S');
          const nLandmark = getLandmarkByName('N');
          const nPrimeLandmark = getLandmarkByName('N\'');
          const pogLandmark = getLandmarkByName('Pog');
          const pgPrimeLandmark = getLandmarkByName('Pog\'');
          const ulLandmark = getLandmarkByName('UL');
          const ulPrimeLandmark = getLandmarkByName('UL\'');
          const llPrimeLandmark = getLandmarkByName('LL\'');
          const llLandmark = getLandmarkByName('LL');
          const orLandmark = getLandmarkByName('Or');
          const poLandmark = getLandmarkByName('Po');
          
          // H-line: UL ØªØ§ Pog' (Ø¨Ø§ gradient Ø±Ù†Ú¯ Ùˆ Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ø² Ø¯Ùˆ Ø·Ø±Ù)
          let ulPos;
          let pgPrimePos;
          if (ulLandmark && pgPrimeLandmark) {
            ulPos = getLandmarkCanvasPosition(ulLandmark);
            pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmark);
            if (ulPos && pgPrimePos) {
              const ulColor = landmarkColors.UL || landmarkColors['UL\''] || landmarkColors['UL`'] || landmarkColors['ULâ€²'] || landmarkColors.Ls || landmarkColors.default || '#00D9FF';
              const pogPrimeColor = landmarkColors['Pog`'] || landmarkColors['Pog\''] || landmarkColors['Pogâ€²'] || landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(ulPos, pgPrimePos, ulColor, pogPrimeColor);
              
              // Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† UL-Pog' Ùˆ S-N
              if (sLandmark && nLandmark) {
                const sPos = getLandmarkCanvasPosition(sLandmark);
                const nPos = getLandmarkCanvasPosition(nLandmark);
                if (sPos && nPos) {
                  // Ø±Ø³Ù… Ø®Ø· S-N (Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´)
                  const sColor = landmarkColors.S || landmarkColors.default || '#00D9FF';
                  const nColor = landmarkColors.N || landmarkColors.default || '#00D9FF';
                  drawLineWithExtensions(sPos, nPos, sColor, nColor, actualLineWidth, false);
                  
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† UL-Pog' Ùˆ S-N
                  const ulPogPrimeSnAngle = calculateAngleBetweenLines(ulPos, pgPrimePos, sPos, nPos);
                  if (ulPogPrimeSnAngle !== null && !isNaN(ulPogPrimeSnAngle)) {
                    drawAngleBetweenLines(ulPos, pgPrimePos, sPos, nPos, ulPogPrimeSnAngle, 'UL-Pog\'-SN', '#FFD700', fontSize, radius, 'UL', 'Pog\'', 'S', 'N', true);
                  }
                }
              }
              
              // Upper Lip to H-line
              if (ulPrimeLandmark) {
                const ulPrimePos = getLandmarkCanvasPosition(ulPrimeLandmark);
                if (ulPrimePos) {
                  const ulColor = landmarkColors['UL\''] || landmarkColors.UL || landmarkColors.default || '#00D9FF';
                  drawPerpendicularLine(ulPrimePos, pgPrimePos, ulPos, ulColor, actualLineWidth);
                  if (currentMeasurements['Upper Lip to H-line']) {
                    drawDistanceToLine(ulPrimePos, pgPrimePos, ulPos, currentMeasurements['Upper Lip to H-line'], 'UL\'-H', ulColor, fontSize);
                }
              }
              }
              
              // Lower Lip to H-line
              const lipLandmark = llPrimeLandmark || llLandmark;
              if (lipLandmark) {
                const lipPoint = getLandmarkCanvasPosition(lipLandmark);
                if (lipPoint) {
                  const llColor = landmarkColors['LL\''] || landmarkColors.LL || landmarkColors.Li || landmarkColors.default || '#00D9FF';
                  drawPerpendicularLine(lipPoint, pgPrimePos, ulPos, llColor, actualLineWidth);
                  if (currentMeasurements['Lower Lip to H-line']) {
                    drawDistanceToLine(lipPoint, pgPrimePos, ulPos, currentMeasurements['Lower Lip to H-line'], 'LL\'-H', llColor, fontSize);
                  }
                }
              }
            }
          }
          
          // H-angle: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† N-Pog Ùˆ H-line (UL ØªØ§ Pog')
          // Ø¨Ø§ÛŒØ¯ Ø®Ø§Ø±Ø¬ Ø§Ø² Ø´Ø±Ø· ulPos && pgPrimePos Ø¨Ø§Ø´Ø¯ ØªØ§ Ù‡Ù…ÛŒØ´Ù‡ Ø±Ø³Ù… Ø´ÙˆØ¯
          if (nLandmark && pogLandmark && ulPos && pgPrimePos) {
            const nPos = getLandmarkCanvasPosition(nLandmark);
            const pogPos = getLandmarkCanvasPosition(pogLandmark);
            if (nPos && pogPos) {
              // Ø±Ø³Ù… Ø®Ø· N-Pog (Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´)
              const nColor = landmarkColors.N || landmarkColors.default || '#00D9FF';
              const pogColor = landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(nPos, pogPos, nColor, pogColor, actualLineWidth, false);
              
              // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ H-angle
              const hAngleValue = currentMeasurements['H-angle'];
              if (hAngleValue !== undefined && hAngleValue !== null && hAngleValue !== '') {
                drawAngleBetweenLines(nPos, pogPos, ulPos, pgPrimePos, parseFloat(hAngleValue), 'H-angle', '#FFD700', fontSize, radius, 'N', 'Pog', 'UL', 'Pog\'', false);
              } else {
                // Ø§Ú¯Ø± Ù…Ù‚Ø¯Ø§Ø± ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø²Ø§ÙˆÛŒÙ‡ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
                const calculatedHAngle = calculateAngleBetweenLines(nPos, pogPos, ulPos, pgPrimePos);
                if (calculatedHAngle !== null && !isNaN(calculatedHAngle)) {
                  drawAngleBetweenLines(nPos, pogPos, ulPos, pgPrimePos, calculatedHAngle, 'H-angle', '#FFD700', fontSize, radius, 'N', 'Pog', 'UL', 'Pog\'', false);
                }
              }
            }
          }
          
          // Or-Po (Frankfort Horizontal)
          if (orLandmark && poLandmark) {
            const orPos = getLandmarkCanvasPosition(orLandmark);
            const poPos = getLandmarkCanvasPosition(poLandmark);
            if (orPos && poPos) {
              const orColor = landmarkColors.Or || landmarkColors.default || '#00D9FF';
              const poColor = landmarkColors.Po || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(orPos, poPos, orColor, poColor);
            }
          }
          
          // Soft Tissue Facial Angle: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† N'-Pog' Ùˆ Frankfort Horizontal (Or-Po)
          if (nPrimeLandmark && pgPrimeLandmark && orLandmark && poLandmark) {
            const nPrimePos = getLandmarkCanvasPosition(nPrimeLandmark);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmark);
            const orPos = getLandmarkCanvasPosition(orLandmark);
            const poPos = getLandmarkCanvasPosition(poLandmark);
            if (nPrimePos && pgPrimePos && orPos && poPos) {
              // Ø±Ø³Ù… Ø®Ø· N'-Pog' (Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´)
              const nprimeColor = landmarkColors['N`'] || landmarkColors['N\''] || landmarkColors['Nâ€²'] || landmarkColors.N || landmarkColors.default || '#00D9FF';
              const pogPrimeColor = landmarkColors['Pog`'] || landmarkColors['Pog\''] || landmarkColors['Pogâ€²'] || landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(nPrimePos, pgPrimePos, nprimeColor, pogPrimeColor, actualLineWidth, false);
              
              // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ ST Facial Angle
              const stFacialAngleValue = currentMeasurements['Soft Tissue Facial Angle'];
              if (stFacialAngleValue !== undefined && stFacialAngleValue !== null && stFacialAngleValue !== '') {
                drawAngleBetweenLines(nPrimePos, pgPrimePos, orPos, poPos, parseFloat(stFacialAngleValue), 'ST Facial Angle', '#FFD700', fontSize, radius, 'N\'', 'Pog\'', 'Or', 'Po', true);
              }
            }
          }
          
          // Soft Tissue Chin Thickness
          if (pogLandmark && pgPrimeLandmark) {
            const pogPos = getLandmarkCanvasPosition(pogLandmark);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmark);
            if (pogPos && pgPrimePos) {
              const pogColor = landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              const pogPrimeColor = landmarkColors['Pog`'] || landmarkColors['Pog\''] || landmarkColors['Pogâ€²'] || landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(pogPos, pgPrimePos, pogColor, pogPrimeColor, actualLineWidth, false);
              if (currentMeasurements['Soft Tissue Chin Thickness']) {
                const lineColor = pogColor || pogPrimeColor || landmarkColors.default || '#00D9FF';
                drawDistance(pogPos, pgPrimePos, currentMeasurements['Soft Tissue Chin Thickness'], 'Chin Thickness', lineColor, fontSize);
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Arnett & McLaughlin (Soft Tissue) - E-line Ùˆ Ø®Ø·ÙˆØ· Ø¨Ø§ÙØª Ù†Ø±Ù…
        // Ù…Ø·Ø§Ø¨Ù‚ Ø¨Ø§ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù…Ø¯Ù„ CLdetection2023
        if (showMeasurements && (analysisType === 'arnettMcLaughlin' || analysisType === 'all')) {
          const prnLandmark = getLandmarkByName('Pn');
          const pgPrimeLandmarkArnett = getLandmarkByName('Pog\'');
          const lsLandmarkArnett = getLandmarkByName('UL');
          const liLandmarkArnett = getLandmarkByName('LL');
          const gLandmarkArnett = getLandmarkByName('G');
          const snLandmarkArnett = getLandmarkByName('Sn');
          const cmLandmarkArnett = getLandmarkByName('Cm');
          const mePrimeLandmarkArnett = getLandmarkByName('Me\'');
          const nLandmarkArnett = getLandmarkByName('N');
          
                const fontSize = isMobile ? 7 : 12;
          const radius = (isMobile ? 12 : 30) * zoom;
          
          // 1. E-line (Pn-Pog') - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (prnLandmark && pgPrimeLandmarkArnett) {
            const prnPos = getLandmarkCanvasPosition(prnLandmark);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkArnett);
            
            if (prnPos && pgPrimePos) {
              // Ø±Ø³Ù… E-line Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ù…Ø´ØªØ±Ú© (Ø¨Ø¯ÙˆÙ† Ø§Ù…ØªØ¯Ø§Ø¯)
              const pnColor = landmarkColors.Pn || landmarkColors.Prn || landmarkColors.default || '#00D9FF';
              const pogPrimeColor = landmarkColors['Pog`'] || landmarkColors['Pog\''] || landmarkColors['Pogâ€²'] || landmarkColors.Pog || landmarkColors.default || '#00D9FF';
              drawLineWithExtensions(prnPos, pgPrimePos, pnColor, pogPrimeColor, actualLineWidth, false);
              
              // Ø±Ø³Ù… ÙØ§ØµÙ„Ù‡ Ø§Ø² Ù„Ø¨ Ø¨Ø§Ù„Ø§ Ùˆ Ù¾Ø§ÛŒÛŒÙ† ØªØ§ E-line
              if (lsLandmarkArnett && liLandmarkArnett) {
                const lsPos = getLandmarkCanvasPosition(lsLandmarkArnett);
                const liPos = getLandmarkCanvasPosition(liLandmarkArnett);
                
                if (lsPos && liPos) {
                  // Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ Ø§Ø² Ls Ùˆ Li Ø¨Ù‡ E-line
              ctx.strokeStyle = '#FFD700';
                  ctx.lineWidth = actualLineWidth * 0.8;
                  ctx.setLineDash([3 * zoom, 3 * zoom]);
                  
                  // Ø®Ø· Ø¹Ù…ÙˆØ¯ Ø§Ø² Ls Ø¨Ù‡ E-line
                ctx.beginPath();
                  ctx.moveTo(lsPos.x, lsPos.y);
                  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ù‚Ø·Ù‡ ØªÙ‚Ø§Ø·Ø¹ Ø¹Ù…ÙˆØ¯
                  const eLineDx = pgPrimePos.x - prnPos.x;
                  const eLineDy = pgPrimePos.y - prnPos.y;
                  const eLineLength = Math.sqrt(eLineDx * eLineDx + eLineDy * eLineDy);
                  if (eLineLength > 0) {
                    const t = ((lsPos.x - prnPos.x) * eLineDx + (lsPos.y - prnPos.y) * eLineDy) / (eLineLength * eLineLength);
                    const intersectionX = prnPos.x + t * eLineDx;
                    const intersectionY = prnPos.y + t * eLineDy;
                    ctx.lineTo(intersectionX, intersectionY);
                ctx.stroke();
                  }
                
                  // Ø®Ø· Ø¹Ù…ÙˆØ¯ Ø§Ø² Li Ø¨Ù‡ E-line
                ctx.beginPath();
                  ctx.moveTo(liPos.x, liPos.y);
                  if (eLineLength > 0) {
                    const t = ((liPos.x - prnPos.x) * eLineDx + (liPos.y - prnPos.y) * eLineDy) / (eLineLength * eLineLength);
                    const intersectionX = prnPos.x + t * eLineDx;
                    const intersectionY = prnPos.y + t * eLineDy;
                    ctx.lineTo(intersectionX, intersectionY);
                ctx.stroke();
                  }
                
                  // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø§Ø¯ÛŒØ± ÙØ§ØµÙ„Ù‡
                ctx.setLineDash([]);
                
                  // Ø¨Ø±Ú†Ø³Ø¨ Upper Lip to E-line
                  // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
                  if (analysisType !== 'general' && analysisType !== 'all') {
                    const upperLipValue = currentMeasurements?.['Upper Lip to E-line'];
                    if (upperLipValue !== undefined && upperLipValue !== null) {
                      const upperLipLabelX = (lsPos.x + prnPos.x) / 2;
                      const upperLipLabelY = (lsPos.y + prnPos.y) / 2;
                      const upperLipText = `UL-E: ${typeof upperLipValue === 'number' ? upperLipValue.toFixed(1) : upperLipValue}mm`;
                      drawTextWithBackground(upperLipText, upperLipLabelX, upperLipLabelY, fontSize, '#FFD700');
                    }
                  }
                  
                  // Ø¨Ø±Ú†Ø³Ø¨ Lower Lip to E-line
                  // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
                  if (analysisType !== 'general' && analysisType !== 'all') {
                    const lowerLipValue = currentMeasurements?.['Lower Lip to E-line'];
                    if (lowerLipValue !== undefined && lowerLipValue !== null) {
                      const lowerLipLabelX = (liPos.x + prnPos.x) / 2;
                      const lowerLipLabelY = (liPos.y + prnPos.y) / 2;
                      const lowerLipText = `LL-E: ${typeof lowerLipValue === 'number' ? lowerLipValue.toFixed(1) : lowerLipValue}mm`;
                      drawTextWithBackground(lowerLipText, lowerLipLabelX, lowerLipLabelY, fontSize, '#FFD700');
                    }
                  }
                }
              }
            }
          }
          
          // 2. Nasolabial Angle (Cm-Sn-UL) - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (cmLandmarkArnett && snLandmarkArnett && lsLandmarkArnett) {
            const cmPos = getLandmarkCanvasPosition(cmLandmarkArnett);
            const snPos = getLandmarkCanvasPosition(snLandmarkArnett);
            const lsPos = getLandmarkCanvasPosition(lsLandmarkArnett);
            if (cmPos && snPos && lsPos) {
              let nasolabialValue = currentMeasurements?.['Nasolabial Angle'];
              if (nasolabialValue === undefined || nasolabialValue === null) {
                nasolabialValue = calculateAngle(cmPos, snPos, lsPos);
              }
              const nasoRadius = radius * 0.8;
              // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Arnett & McLaughlinØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
              drawAngle(cmPos, snPos, lsPos, nasolabialValue, 'Nasolabial', '#FFD700', fontSize, nasoRadius, 'Cm', 'UL', false);
            }
          }
          
          // 3. Chin Prominence (Pog' to N-Pog') - Ø®Ø· N-Pog' Ùˆ ÙØ§ØµÙ„Ù‡ Pog' ØªØ§ Ø®Ø·
          if (nLandmarkArnett && pgPrimeLandmarkArnett) {
            const nPos = getLandmarkCanvasPosition(nLandmarkArnett);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkArnett);
            if (nPos && pgPrimePos) {
              // ğŸ”§ FIX: Ø±Ø³Ù… Ø®Ø· N-Pog' ÙÙ‚Ø· Ø¨Ù‡ ØµÙˆØ±Øª solid (Ø¨Ø¯ÙˆÙ† Ø®Ø· Ú†ÛŒÙ†)
              const nPogDx = pgPrimePos.x - nPos.x;
              const nPogDy = pgPrimePos.y - nPos.y;
              const nPogLength = Math.sqrt(nPogDx * nPogDx + nPogDy * nPogDy);
              if (nPogLength > 0) {
                // Ø±Ø³Ù… Ø¨Ø®Ø´ Ø§ØµÙ„ÛŒ (solid) - Ø¨Ø¯ÙˆÙ† Ø®Ø· Ú†ÛŒÙ†
                const nPogColor = landmarkColorCache.getColorForLandmark('N');
                const pogPrimeColor = landmarkColorCache.getColorForLandmark('Pog\'');
                const nPogGradient = useGradientLines && nPos && pgPrimePos
                  ? (() => {
                      const gradient = ctx.createLinearGradient(nPos.x, nPos.y, pgPrimePos.x, pgPrimePos.y);
                      gradient.addColorStop(0, nPogColor);
                      gradient.addColorStop(1, pogPrimeColor);
                      return gradient;
                    })()
                  : nPogColor;
                ctx.strokeStyle = nPogColor;
                ctx.lineWidth = actualLineWidth;
                ctx.setLineDash([]); // solid
                ctx.beginPath();
                ctx.moveTo(nPos.x, nPos.y);
                ctx.lineTo(pgPrimePos.x, pgPrimePos.y);
                ctx.stroke();
                
                // Ù†Ù…Ø§ÛŒØ´ Chin Prominence (ÙØ§ØµÙ„Ù‡ Pog' ØªØ§ Ø®Ø· N-Pog' - Ú©Ù‡ ØµÙØ± Ø§Ø³Øª Ú†ÙˆÙ† Pog' Ø±ÙˆÛŒ Ø®Ø· Ø§Ø³Øª)
                // Ø¯Ø± ÙˆØ§Ù‚Ø¹ Chin Prominence ÙØ§ØµÙ„Ù‡ Pog' ØªØ§ Ø®Ø· N-Pog (hard tissue) Ø§Ø³Øª
                const pogLandmarkHard = getLandmarkByName('Pog');
                if (pogLandmarkHard) {
                  const pogPosHard = getLandmarkCanvasPosition(pogLandmarkHard);
                  if (pogPosHard) {
                    // ÙØ§ØµÙ„Ù‡ Pog (hard) ØªØ§ Ø®Ø· N-Pog'
                    const chinProminenceValue = currentMeasurements?.['Chin Prominence'];
                    if (chinProminenceValue !== undefined && chinProminenceValue !== null) {
                      // Ø±Ø³Ù… Ø®Ø· Ø¹Ù…ÙˆØ¯ Ø§Ø² Pog Ø¨Ù‡ Ø®Ø· N-Pog'
                ctx.strokeStyle = '#FFD700';
                      ctx.lineWidth = actualLineWidth * 0.8;
                      ctx.setLineDash([3 * zoom, 3 * zoom]);
                ctx.beginPath();
                      ctx.moveTo(pogPosHard.x, pogPosHard.y);
                      const t = ((pogPosHard.x - nPos.x) * nPogDx + (pogPosHard.y - nPos.y) * nPogDy) / (nPogLength * nPogLength);
                      const intersectionX = nPos.x + t * nPogDx;
                      const intersectionY = nPos.y + t * nPogDy;
                      ctx.lineTo(intersectionX, intersectionY);
                ctx.stroke();
                
                      // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø¯Ø§Ø±
                ctx.font = `bold ${fontSize * zoom}px Arial`;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.setLineDash([]);
                      const labelX = (pogPosHard.x + intersectionX) / 2;
                      const labelY = (pogPosHard.y + intersectionY) / 2;
                      const labelText = `Chin: ${typeof chinProminenceValue === 'number' ? chinProminenceValue.toFixed(1) : chinProminenceValue}mm`;
                const textMetrics = ctx.measureText(labelText);
                ctx.fillRect(labelX - textMetrics.width / 2 - 4 * zoom, labelY - (isMobile ? 6 : 8) * zoom, textMetrics.width + 8 * zoom, (isMobile ? 12 : 16) * zoom);
                ctx.fillStyle = '#FFD700';
                ctx.fillText(labelText, labelX, labelY);
                    }
                  }
                }
              }
            }
          }
          
          // 4. Facial Convexity (Glabella-Sn-Pog') - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (gLandmarkArnett && snLandmarkArnett && pgPrimeLandmarkArnett) {
            const gPos = getLandmarkCanvasPosition(gLandmarkArnett);
            const snPos = getLandmarkCanvasPosition(snLandmarkArnett);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkArnett);
            if (gPos && snPos && pgPrimePos) {
              let facialConvexityValue = currentMeasurements?.['Facial Convexity (Glabella-Sn-Pog\')'];
              if (facialConvexityValue === undefined || facialConvexityValue === null) {
                facialConvexityValue = calculateAngle(gPos, snPos, pgPrimePos);
              }
              // ğŸ”§ FIX: Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² Arnett & McLaughlinØŒ Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ù†Ú©Ù†
              drawAngle(gPos, snPos, pgPrimePos, facialConvexityValue, 'Facial Convexity', '#FFD700', fontSize, radius, 'G', 'Pog\'', false);
            }
          }
          
          // 5. Lower Face Height (Sn-Me') - Ø®Ø· Ùˆ ÙØ§ØµÙ„Ù‡
          if (snLandmarkArnett && mePrimeLandmarkArnett) {
            const snPos = getLandmarkCanvasPosition(snLandmarkArnett);
            const mePrimePos = getLandmarkCanvasPosition(mePrimeLandmarkArnett);
            if (snPos && mePrimePos) {
              // Ø±Ø³Ù… Ø®Ø· Sn-Me' Ø¨Ø§ gradient Ùˆ Ø®Ø· Ú†ÛŒÙ†
              const getLineColorForPoints = (startName, endName, startPos, endPos) => {
                const startColor = landmarkColors[startName] || landmarkColors.default || '#00D9FF';
                const endColor = landmarkColors[endName] || landmarkColors.default || '#00D9FF';
                
                if (useGradientLines && startPos && endPos) {
                  const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
                  gradient.addColorStop(0, startColor);
                  gradient.addColorStop(1, endColor);
                  return gradient;
                }
                return startColor;
              };
              
              const lineColor = getLineColorForPoints('Sn', 'Me\'', snPos, mePrimePos);
              ctx.strokeStyle = lineColor;
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid
              ctx.beginPath();
              ctx.moveTo(snPos.x, snPos.y);
              ctx.lineTo(mePrimePos.x, mePrimePos.y);
              ctx.stroke();
              
              // Ù†Ù…Ø§ÛŒØ´ ÙØ§ØµÙ„Ù‡
              const lowerFaceHeightValue = currentMeasurements?.['Lower Face Height (Sn-Me\')'];
              if (lowerFaceHeightValue !== undefined && lowerFaceHeightValue !== null) {
                drawDistance(snPos, mePrimePos, lowerFaceHeightValue, 'Lower Face Height', '#FFD700', fontSize);
              }
            }
          }
          
          // 6. Upper Lip Protrusion (Cm-Sn-UL) - Ø®Ø· Cm-UL Ùˆ ÙØ§ØµÙ„Ù‡
          if (cmLandmarkArnett && snLandmarkArnett && lsLandmarkArnett) {
            const cmPos = getLandmarkCanvasPosition(cmLandmarkArnett);
            const snPos = getLandmarkCanvasPosition(snLandmarkArnett);
            const lsPos = getLandmarkCanvasPosition(lsLandmarkArnett);
            if (cmPos && snPos && lsPos) {
              // Ø±Ø³Ù… Ø®Ø· Cm-UL Ø¨Ø§ gradient
              const getLineColorForPoints = (startName, endName, startPos, endPos) => {
                const startColor = landmarkColors[startName] || landmarkColors.default || '#00D9FF';
                const endColor = landmarkColors[endName] || landmarkColors.default || '#00D9FF';
                
                if (useGradientLines && startPos && endPos) {
                  const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endPos.x, endPos.y);
                  gradient.addColorStop(0, startColor);
                  gradient.addColorStop(1, endColor);
                  return gradient;
                }
                return startColor;
              };
              
              const lineColor = getLineColorForPoints('Cm', 'UL', cmPos, lsPos);
              ctx.strokeStyle = lineColor;
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid
              ctx.beginPath();
              ctx.moveTo(cmPos.x, cmPos.y);
              ctx.lineTo(lsPos.x, lsPos.y);
              ctx.stroke();
              
              // Ù†Ù…Ø§ÛŒØ´ ÙØ§ØµÙ„Ù‡
              const upperLipProtrusionValue = currentMeasurements?.['Upper Lip Protrusion'];
              if (upperLipProtrusionValue !== undefined && upperLipProtrusionValue !== null) {
                drawDistance(cmPos, lsPos, upperLipProtrusionValue, 'Upper Lip Protrusion', '#FFD700', fontSize);
              }
            }
          }
        }
        
        // Ø¢Ù†Ø§Ù„ÛŒØ² Soft Tissue Angular (Soft Tissue) - Ø²ÙˆØ§ÛŒØ§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù…
        // Ù…Ø·Ø§Ø¨Ù‚ Ø¨Ø§ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù…Ø¯Ù„ CLdetection2023
        if (showMeasurements && (analysisType === 'softTissueAngular' || analysisType === 'all')) {
                const fontSize = isMobile ? 7 : 12;
                const radius = (isMobile ? 10 : 30) * zoom;
          
          const gLandmarkAngular = getLandmarkByName('G');
          const snLandmarkAngular = getLandmarkByName('Sn');
          const pgPrimeLandmarkAngular = getLandmarkByName('Pog\'');
          const cmLandmarkAngular = getLandmarkByName('Cm');
          const lsLandmarkAngular = getLandmarkByName('UL');
          const liLandmarkAngular = getLandmarkByName('LL');
          const mePrimeLandmarkAngular = getLandmarkByName('Me\'');
          const gnPrimeLandmarkAngular = getLandmarkByName('Gn\'');
          
          // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ØªØ§Ø¨Ø¹ Ù…Ø´ØªØ±Ú© drawLineWithExtensions Ø¨Ø±Ø§ÛŒ Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ·
          
          // Mentolabial Angle (LL-Pog'-Me') - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (liLandmarkAngular && pgPrimeLandmarkAngular && mePrimeLandmarkAngular) {
            const liPos = getLandmarkCanvasPosition(liLandmarkAngular);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkAngular);
            const mePrimePos = getLandmarkCanvasPosition(mePrimeLandmarkAngular);
            if (liPos && pgPrimePos && mePrimePos) {
              let mentolabialValue = currentMeasurements?.['Mentolabial Angle'];
              if (mentolabialValue === undefined || mentolabialValue === null) {
                mentolabialValue = calculateAngle(liPos, pgPrimePos, mePrimePos);
              }
              drawAngle(liPos, pgPrimePos, mePrimePos, mentolabialValue, 'Mentolabial', '#FFD700', fontSize, radius, 'LL', 'Me\'', false);
            }
          }
          
          // Soft Tissue Chin Angle (Pog'-Sn-N') - Ù…Ø´Ø§Ø¨Ù‡ steiner
          const nPrimeLandmarkAngular = getLandmarkByName('N\'') || getLandmarkByName('N');
          if (pgPrimeLandmarkAngular && snLandmarkAngular && nPrimeLandmarkAngular) {
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkAngular);
            const snPos = getLandmarkCanvasPosition(snLandmarkAngular);
            const nPrimePos = getLandmarkCanvasPosition(nPrimeLandmarkAngular);
            if (pgPrimePos && snPos && nPrimePos) {
              let stChinAngleValue = currentMeasurements?.['Soft Tissue Chin Angle'];
              if (stChinAngleValue === undefined || stChinAngleValue === null) {
                stChinAngleValue = calculateAngle(pgPrimePos, snPos, nPrimePos);
              }
              drawAngle(pgPrimePos, snPos, nPrimePos, stChinAngleValue, 'ST Chin Angle', '#FFD700', fontSize, radius, 'Pog\'', 'N\'', false);
            }
          }
          
          // Upper Lip Angle (Cm-Sn-UL) - Ø§Ú¯Ø± Ù‚Ø¨Ù„Ø§Ù‹ Ø±Ø³Ù… Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (cmLandmarkAngular && snLandmarkAngular && lsLandmarkAngular) {
            const cmPos = getLandmarkCanvasPosition(cmLandmarkAngular);
            const snPos = getLandmarkCanvasPosition(snLandmarkAngular);
            const lsPos = getLandmarkCanvasPosition(lsLandmarkAngular);
            if (cmPos && snPos && lsPos) {
              // ÙÙ‚Ø· Ø§Ú¯Ø± Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø³Ù… Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
              if (analysisType === 'softTissueAngular') {
                let upperLipAngleValue = currentMeasurements?.['Upper Lip Angle'];
                if (upperLipAngleValue === undefined || upperLipAngleValue === null) {
                  upperLipAngleValue = calculateAngle(cmPos, snPos, lsPos);
                }
                drawAngle(cmPos, snPos, lsPos, upperLipAngleValue, 'Upper Lip Angle', '#FFD700', fontSize, radius, 'Cm', 'UL', false);
              }
            }
          }
          
          // Lower Lip Angle (Sn-LL-Pog') - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (snLandmarkAngular && liLandmarkAngular && pgPrimeLandmarkAngular) {
            const snPos = getLandmarkCanvasPosition(snLandmarkAngular);
            const liPos = getLandmarkCanvasPosition(liLandmarkAngular);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkAngular);
            if (snPos && liPos && pgPrimePos) {
              let lowerLipAngleValue = currentMeasurements?.['Lower Lip Angle'];
              if (lowerLipAngleValue === undefined || lowerLipAngleValue === null) {
                lowerLipAngleValue = calculateAngle(snPos, liPos, pgPrimePos);
              }
              drawAngle(snPos, liPos, pgPrimePos, lowerLipAngleValue, 'Lower Lip Angle', '#FFD700', fontSize, radius, 'Sn', 'Pog\'', false);
            }
          }
          
          // Total Facial Convexity (Glabella-Sn-Pog') - Ø§Ú¯Ø± Ù‚Ø¨Ù„Ø§Ù‹ Ø±Ø³Ù… Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ - Ù…Ø´Ø§Ø¨Ù‡ steiner
          if (gLandmarkAngular && snLandmarkAngular && pgPrimeLandmarkAngular) {
            const gPos = getLandmarkCanvasPosition(gLandmarkAngular);
            const snPos = getLandmarkCanvasPosition(snLandmarkAngular);
            const pgPrimePos = getLandmarkCanvasPosition(pgPrimeLandmarkAngular);
            if (gPos && snPos && pgPrimePos) {
              // ÙÙ‚Ø· Ø§Ú¯Ø± Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø³Ù… Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
              if (analysisType === 'softTissueAngular') {
                // Ø±Ø³Ù… Ø²Ø§ÙˆÛŒÙ‡ Glabella-Sn-Pog' Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Total Facial Convexity
                let totalConvexity = currentMeasurements?.['Total Facial Convexity'];
                if (totalConvexity === undefined || totalConvexity === null) {
                  totalConvexity = calculateAngle(gPos, snPos, pgPrimePos);
                }
                drawAngle(gPos, snPos, pgPrimePos, totalConvexity, 'Total Convexity', '#FFD700', fontSize, radius, 'G', 'Pog\'', false);
              }
            }
          }
        }
        
        if (showMeasurements && currentMeasurements && (analysisType === 'ricketts' || analysisType === 'general')) {
          // 1. Facial Axis - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø·ÙˆØ· Gn-Pt Ùˆ Pt-Ba (Ø¯Ø± Ù†Ù‚Ø·Ù‡ Pt)
          const baLandmark = getLandmarkByName('Ba');
          const ptLandmark = getLandmarkByName('Pt');
          const gnLandmark = getLandmarkByName('Gn');
          
          if (baLandmark && ptLandmark && gnLandmark && currentMeasurements['Facial Axis']) {
            const baPos = getLandmarkCanvasPosition(baLandmark);
            const ptPos = getLandmarkCanvasPosition(ptLandmark);
            const gnPos = getLandmarkCanvasPosition(gnLandmark);
            
            if (baPos && ptPos && gnPos) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              // Ø®Ø· Ø§ÙˆÙ„: Gn-Pt (Ø§Ø² Gn Ø¨Ù‡ Pt)
              // Ø®Ø· Ø¯ÙˆÙ…: Pt-Ba (Ø§Ø² Pt Ø¨Ù‡ Ba)
              drawAngleBetweenLines(ptPos, gnPos, ptPos, baPos, currentMeasurements['Facial Axis'], 'Facial Axis', '#FFD700', fontSize, radius, 'Gn', 'Pt', 'Ba', 'Pt');
            }
          }
          
          // 2. Facial Depth - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø§Ù…ØªØ¯Ø§Ø¯ Ø®Ø·ÙˆØ· N-Pog Ùˆ Or-Po - Ù…Ø´Ø§Ø¨Ù‡ steiner
          const nLandmarkFacialDepth = getLandmarkByName('N');
          const pogLandmark = getLandmarkByName('Pog');
          const orLandmarkFacialDepth = getLandmarkByName('Or');
          const poLandmarkFacialDepth = getLandmarkByName('Po');
          
          if (nLandmarkFacialDepth && pogLandmark && orLandmarkFacialDepth && poLandmarkFacialDepth && currentMeasurements['Facial Depth']) {
            const nPos = getLandmarkCanvasPosition(nLandmarkFacialDepth);
            const pogPos = getLandmarkCanvasPosition(pogLandmark);
            const orPos = getLandmarkCanvasPosition(orLandmarkFacialDepth);
            const poPos = getLandmarkCanvasPosition(poLandmarkFacialDepth);
            
            if (nPos && pogPos && orPos && poPos) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª - Ù…Ø´Ø§Ø¨Ù‡ steiner
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              drawAngleBetweenLines(nPos, pogPos, orPos, poPos, currentMeasurements['Facial Depth'], 'Facial Depth', '#FFD700', fontSize, radius, 'N', 'Pog', 'Or', 'Po');
            }
          }
          
          // 3. Interincisal Angle - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· U1-U1A Ùˆ Ø®Ø· L1-L1A
          const u1LandmarkInter = getLandmarkByName('U1');
          const u1aLandmarkInter = getLandmarkByName('U1A');
          const l1LandmarkInter = getLandmarkByName('L1');
          const l1aLandmarkInter = getLandmarkByName('L1A');
          
          if (u1LandmarkInter && u1aLandmarkInter && l1LandmarkInter && l1aLandmarkInter && currentMeasurements.InterincisalAngle) {
            const u1Pos = getLandmarkCanvasPosition(u1LandmarkInter);
            const u1aPos = getLandmarkCanvasPosition(u1aLandmarkInter);
            const l1Pos = getLandmarkCanvasPosition(l1LandmarkInter);
            const l1aPos = getLandmarkCanvasPosition(l1aLandmarkInter);
            
            if (u1Pos && u1aPos && l1Pos && l1aPos) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª - Ù…Ø´Ø§Ø¨Ù‡ steiner
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              drawAngleBetweenLines(u1Pos, u1aPos, l1Pos, l1aPos, currentMeasurements.InterincisalAngle, 'Interincisal', '#FFD700', fontSize, radius, 'U1', 'U1A', 'L1', 'L1A');
            }
          }
          
          // 4. Occlusal Plane Angle - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Occlusal Plane (L1-Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ LMT Ùˆ UMT) Ùˆ Ø®Ø· S-N
          const l1LandmarkOcclusal = getLandmarkByName('L1');
          const lmtLandmark = getLandmarkByName('LMT');
          const umtLandmark = getLandmarkByName('UMT');
          const sLandmarkOcclusal = getLandmarkByName('S');
          const nLandmarkOcclusal = getLandmarkByName('N');
          
          if (l1LandmarkOcclusal && lmtLandmark && sLandmarkOcclusal && nLandmarkOcclusal && currentMeasurements['Occlusal Plane Angle']) {
            const l1Pos = getLandmarkCanvasPosition(l1LandmarkOcclusal);
            const lmtPos = getLandmarkCanvasPosition(lmtLandmark);
            const umtPos = umtLandmark ? getLandmarkCanvasPosition(umtLandmark) : null;
            const sPos = getLandmarkCanvasPosition(sLandmarkOcclusal);
            const nPos = getLandmarkCanvasPosition(nLandmarkOcclusal);
            
            if (l1Pos && lmtPos && sPos && nPos) {
              // Ù†Ù‚Ø·Ù‡ Ù¾Ø§ÛŒØ§Ù†ÛŒ Occlusal Plane: Ù†Ù‚Ø·Ù‡ Ù…ÛŒØ§Ù†ÛŒ Ø¨ÛŒÙ† LMT Ùˆ UMT
              const occlusalEndPos = umtPos ? {
                x: (lmtPos.x + umtPos.x) / 2,
                y: (lmtPos.y + umtPos.y) / 2
              } : lmtPos;
              
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø±Ø³Ù… ÛŒÚ©Ù†ÙˆØ§Ø®Øª - Ù…Ø´Ø§Ø¨Ù‡ steiner
                const fontSize = isMobile ? 7 : 12;
                const radius = (isMobile ? 10 : 30) * zoom;
                // Ù…Ù‚Ø¯Ø§Ø± Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¨Ø§ÛŒØ¯ Ø§Ø² 180 Ú©Ù… Ø´ÙˆØ¯
                const displayedAngle = 180 - (currentMeasurements['Occlusal Plane Angle'] || 0);
              drawAngleBetweenLines(l1Pos, occlusalEndPos, sPos, nPos, displayedAngle, 'OP-SN', '#FFD700', fontSize, radius, 'L1', 'LMT', 'S', 'N');
            }
          }
          
          // 5. Cranial Deflection - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ba-N-S (Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ø± Ù†Ù‚Ø·Ù‡ N)
          const baLandmarkCranial = getLandmarkByName('Ba');
          const nLandmarkCranial = getLandmarkByName('N');
          const sLandmarkCranial = getLandmarkByName('S');
          
          if (baLandmarkCranial && nLandmarkCranial && sLandmarkCranial && currentMeasurements['Cranial Deflection']) {
            const baPos = getLandmarkCanvasPosition(baLandmarkCranial);
            const nPos = getLandmarkCanvasPosition(nLandmarkCranial);
            const sPos = getLandmarkCanvasPosition(sLandmarkCranial);
            
            if (baPos && nPos && sPos) {
              // ØªØ±Ø³ÛŒÙ… ÙÙ‚Ø· Ø®Ø· Ba-N (Ø®Ø· S-N Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± baseLines ØªØ±Ø³ÛŒÙ… Ø´Ø¯Ù‡ Ø§Ø³Øª)
              ctx.lineWidth = actualLineWidth * 1.5;
              ctx.setLineDash([]);
              
              // Ø®Ø· Ba-N
              ctx.strokeStyle = getLineColor('Ba', 'N', baPos, nPos);
              ctx.beginPath();
              ctx.moveTo(baPos.x, baPos.y);
              ctx.lineTo(nPos.x, nPos.y);
              ctx.stroke();
              
              // ØªØ±Ø³ÛŒÙ… Ú©Ù…Ø§Ù† Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ø± Ù†Ù‚Ø·Ù‡ N
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              const angle1 = Math.atan2(baPos.y - nPos.y, baPos.x - nPos.x);
              const angle2 = Math.atan2(sPos.y - nPos.y, sPos.x - nPos.x);
              
              ctx.strokeStyle = '#FFD700';
              ctx.lineWidth = actualLineWidth;
              ctx.setLineDash([]); // solid arc
              ctx.beginPath();
              ctx.arc(nPos.x, nPos.y, radius, angle1, angle2);
              ctx.stroke();
              ctx.setLineDash([]);
              
              // Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø¯Ø§Ø± Ø²Ø§ÙˆÛŒÙ‡ Ø¯Ø±Ø³Øª Ø¨Ø§Ù„Ø§ÛŒ Ù†Ù‚Ø·Ù‡ Ù…Ø±Ú©Ø²ÛŒ (vertex)
              // Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº (general Ùˆ all)ØŒ label Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
              if (analysisType !== 'general' && analysisType !== 'all') {
                const labelX = nPos.x;
                const labelY = nPos.y - (radius + (isMobile ? 18 : 25) * zoom);
                
                const cranialDeflectionValue = typeof currentMeasurements['Cranial Deflection'] === 'number' 
                  ? currentMeasurements['Cranial Deflection'].toFixed(1) 
                  : currentMeasurements['Cranial Deflection'];
                const labelText = isMobile ? `CD: ${cranialDeflectionValue}Â°` : `Cranial Deflection: ${cranialDeflectionValue}Â°`;
                drawTextWithBackground(labelText, labelX, labelY, fontSize, '#FFD700');
              }
            }
          }
          
          // 6. Palatal Plane Angle to S-N - Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· Ø³Ù‚Ù Ø¯Ù‡Ø§Ù† (ANS-PNS) Ùˆ Ø®Ø· S-N
          const ansLandmarkPalatal = getLandmarkByName('ANS');
          const pnsLandmarkPalatal = getLandmarkByName('PNS');
          const sLandmarkPalatal = getLandmarkByName('S');
          const nLandmarkPalatal = getLandmarkByName('N');
          
          // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ measurement ÛŒØ§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù† Ø§Ø² landmarks
          const palatalPlaneAngleValue = currentMeasurements['Palatal Plane Angle'];
          
          // Ø§Ú¯Ø± measurement ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªØŒ Ø§Ø² landmarks Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
          let calculatedPalatalAngle = null;
          if (!palatalPlaneAngleValue && ansLandmarkPalatal && pnsLandmarkPalatal && sLandmarkPalatal && nLandmarkPalatal) {
            // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø¯Ùˆ Ø®Ø·
            const calculateAngleBetweenLines = (line1Start, line1End, line2Start, line2End) => {
              const v1x = line1End.x - line1Start.x;
              const v1y = line1End.y - line1Start.y;
              const v2x = line2End.x - line2Start.x;
              const v2y = line2End.y - line2Start.y;
              
              const dotProduct = v1x * v2x + v1y * v2y;
              const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
              const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
              
              if (mag1 === 0 || mag2 === 0) return 0;
              
              const cosAngle = dotProduct / (mag1 * mag2);
              const clampedCos = Math.max(-1, Math.min(1, cosAngle));
              const angleRad = Math.acos(clampedCos);
              const angleDeg = angleRad * (180 / Math.PI);
              
              return angleDeg > 90 ? 180 - angleDeg : angleDeg;
            };
            
            const ansPos = getLandmarkCanvasPosition(ansLandmarkPalatal);
            const pnsPos = getLandmarkCanvasPosition(pnsLandmarkPalatal);
            const sPos = getLandmarkCanvasPosition(sLandmarkPalatal);
            const nPos = getLandmarkCanvasPosition(nLandmarkPalatal);
            
            if (ansPos && pnsPos && sPos && nPos) {
              calculatedPalatalAngle = calculateAngleBetweenLines(
                ansPos, pnsPos,  // Ø®Ø· Ø§ÙˆÙ„: ANS-PNS
                sPos, nPos       // Ø®Ø· Ø¯ÙˆÙ…: S-N
              );
              if (calculatedPalatalAngle > 90) {
                calculatedPalatalAngle = 180 - calculatedPalatalAngle;
              }
              // calculatedPalatalAngle Ø¨Ø¯ÙˆÙ† Ú¯Ø±Ø¯ Ú©Ø±Ø¯Ù†
            }
          }
          
          // Ensure finalPalatalAngle is a number for proper formatting
          let finalPalatalAngle = palatalPlaneAngleValue || calculatedPalatalAngle;
          if (finalPalatalAngle !== undefined && finalPalatalAngle !== null) {
            // Convert to number if it's a string
            if (typeof finalPalatalAngle === 'string') {
              finalPalatalAngle = parseFloat(finalPalatalAngle);
            }
            // Format to one decimal place if it's a valid number
            if (typeof finalPalatalAngle === 'number' && !isNaN(finalPalatalAngle)) {
              finalPalatalAngle = parseFloat(finalPalatalAngle.toFixed(1));
            }
          }
          
          if (ansLandmarkPalatal && pnsLandmarkPalatal && sLandmarkPalatal && nLandmarkPalatal && finalPalatalAngle !== undefined && finalPalatalAngle !== null) {
            const ansPos = getLandmarkCanvasPosition(ansLandmarkPalatal);
            const pnsPos = getLandmarkCanvasPosition(pnsLandmarkPalatal);
            const sPos = getLandmarkCanvasPosition(sLandmarkPalatal);
            const nPos = getLandmarkCanvasPosition(nLandmarkPalatal);
            
            if (ansPos && pnsPos && sPos && nPos) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø±ÙˆÛŒ Ù‡Ù… Ø§ÙØªØ§Ø¯Ù† Ù†ÙˆØ´ØªÙ‡â€ŒÙ‡Ø§
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;
              drawAngleBetweenLines(
                ansPos, pnsPos,  // Ø®Ø· Ø§ÙˆÙ„: ANS-PNS
                sPos, nPos,      // Ø®Ø· Ø¯ÙˆÙ…: S-N
                finalPalatalAngle,
                'PP-SN',
                '#FFD700',
                fontSize,
                radius,
                'ANS', 'PNS', 'S', 'N',
                true
              );
            }
          }
        }
        
        // Ø±Ø³Ù… Ù…Ø«Ù„Ø« Tweed (FMA, FMIA, IMPA) Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² drawAngleBetweenLines
        // Ù…Ø«Ù„Ø« Tweed Ø§Ø² Ø³Ù‡ Ø²Ø§ÙˆÛŒÙ‡ ØªØ´Ú©ÛŒÙ„ Ù…ÛŒâ€ŒØ´ÙˆØ¯:
        // 1. FMA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Or-Po) Ùˆ Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± (Go-Me)
        // 2. FMIA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Or-Po) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ L1-Me)
        // 3. IMPA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± (Go-Me) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ L1-Me)
        // ÙÙ‚Ø· Ø¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² Tweed Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
        if (showTweedTriangle && showMeasurements && measurements && (analysisType === 'tweed' || analysisType === 'general')) {
          const currentMeasurements = Object.keys(calculatedMeasurements).length > 0 ? calculatedMeasurements : (measurements || {});
          const orLandmark = getLandmarkByName('Or');
          const poLandmark = getLandmarkByName('Po');
          const goLandmark = getLandmarkByName('Go');
          const meLandmark = getLandmarkByName('Me');
          const l1aLandmark = getLandmarkByName('L1A');
          const l1Landmark = getLandmarkByName('L1');

          if (orLandmark && poLandmark && goLandmark && meLandmark) {
            const orPos = getLandmarkCanvasPosition(orLandmark);
            const poPos = getLandmarkCanvasPosition(poLandmark);
            const goPos = getLandmarkCanvasPosition(goLandmark);
            const mePos = getLandmarkCanvasPosition(meLandmark);

            // ØªØ¹ÛŒÛŒÙ† Ø®Ø· incisor: Ø¨Ø§ÛŒØ¯ Ø§Ø² L1A Ùˆ L1 Ø¹Ø¨ÙˆØ± Ú©Ù†Ø¯
            let incisorStartPos = null;
            let incisorEndPos = null;
            let incisorStartName = 'L1';
            let incisorEndName = 'Me';

            if (l1aLandmark && l1Landmark) {
              // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² L1A-L1 (Ø§Ø² L1A Ø¨Ù‡ L1)
              const l1aPos = getLandmarkCanvasPosition(l1aLandmark);
              const l1Pos = getLandmarkCanvasPosition(l1Landmark);
              if (l1aPos && l1Pos) {
                incisorStartPos = l1aPos;
                incisorEndPos = l1Pos;
                incisorStartName = 'L1A';
                incisorEndName = 'L1';
              }
            } else if (l1Landmark) {
              // Fallback: Ø§Ú¯Ø± L1A Ù…ÙˆØ¬ÙˆØ¯ Ù†Ø¨ÙˆØ¯ØŒ ÙÙ‚Ø· Ø§Ø² L1 Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
              const l1Pos = getLandmarkCanvasPosition(l1Landmark);
              if (l1Pos) {
                incisorStartPos = l1Pos;
                incisorEndPos = mePos;
                incisorStartName = 'L1';
                incisorEndName = 'Me';
              }
            }

            if (orPos && poPos && goPos && mePos && incisorStartPos && incisorEndPos) {
              const fontSize = isMobile ? 7 : 12;
              const radius = (isMobile ? 10 : 30) * zoom;

              // 1. FMA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Or-Po) Ùˆ Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± (Go-Me)
              if (currentMeasurements?.FMA !== undefined && currentMeasurements?.FMA !== null) {
                drawAngleBetweenLines(
                  orPos, poPos,  // Ø®Ø· Ø§ÙˆÙ„: Or-Po (Frankfort)
                  goPos, mePos,  // Ø®Ø· Ø¯ÙˆÙ…: Go-Me (Mandibular)
                  currentMeasurements.FMA,
                  'FMA',
                  '#FFD700',
                  fontSize,
                  radius,
                  'Or', 'Po', 'Go', 'Me',
                  true  // Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
                );
              }

              // 2. FMIA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· ÙØ±Ø§Ù†Ú©ÙÙˆØ±Øª (Or-Po) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ L1-Me)
              if (currentMeasurements?.FMIA !== undefined && currentMeasurements?.FMIA !== null) {
                drawAngleBetweenLines(
                  orPos, poPos,  // Ø®Ø· Ø§ÙˆÙ„: Or-Po (Frankfort)
                  incisorStartPos, incisorEndPos,  // Ø®Ø· Ø¯ÙˆÙ…: L1A-L1 ÛŒØ§ L1-Me (Incisor)
                  currentMeasurements.FMIA,
                  'FMIA',
                  '#FFD700',
                  fontSize,
                  radius,
                  'Or', 'Po', incisorStartName, incisorEndName,
                  true  // Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
                );
              }

              // 3. IMPA: Ø²Ø§ÙˆÛŒÙ‡ Ø¨ÛŒÙ† Ø®Ø· Ù…Ù†Ø¯ÛŒØ¨ÙˆÙ„Ø§Ø± (Go-Me) Ùˆ Ø®Ø· incisor (L1A-L1 ÛŒØ§ L1-Me)
              if (currentMeasurements?.IMPA !== undefined && currentMeasurements?.IMPA !== null) {
                drawAngleBetweenLines(
                   mePos, goPos,  // Ø®Ø· Ø§ÙˆÙ„: Go-Me (Mandibular)
                  incisorStartPos, incisorEndPos,  // Ø®Ø· Ø¯ÙˆÙ…: L1A-L1 ÛŒØ§ L1-Me (Incisor)
                  currentMeasurements.IMPA,
                  'IMPA',
                  '#FFD700',
                  fontSize,
                  radius,
                  'Go', 'Me', incisorStartName, incisorEndName,
                  true  // Ø®Ø· Ú†ÛŒÙ† (Ø§Ù…ØªØ¯Ø§Ø¯) Ø±Ø§ Ø±Ø³Ù… Ú©Ù†
                );
              }
            }
          }
        }

        ctx.setLineDash([]);
      }

      // Define soft tissue landmarks (Ø¨Ø§ÙØª Ù†Ø±Ù…)
      // Ø´Ø§Ù…Ù„ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ùˆ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù¾Ø±Ø§ÛŒÙ… Ø¯Ø§Ø±Ù†Ø¯ (Ù…Ø«Ù„ Pog', Gn', Me', N')
      const softTissueLandmarks = [
        'Li', 'LL', 'UL', 'Sn', 'Pn', 'Cm', 'cm', 'CM', 'columella', 'Columella', 'LL\'', 'UL\'', 'LMT', 'UMT',
        'Pog\'', 'Gn\'', 'Me\'', 'N\'', // Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ÙØª Ù†Ø±Ù… Ø¨Ø§ Ù¾Ø±Ø§ÛŒÙ…
        'Pogâ€²', 'Gnâ€²', 'Meâ€²', 'Nâ€²', // Ù†Ø³Ø®Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ø¨Ø§ Ú©Ø§Ø±Ø§Ú©ØªØ± Ù¾Ø±Ø§ÛŒÙ… Unicode
      ];
      
      // Helper function to check if a landmark is soft tissue
      const isSoftTissueLandmark = (landmarkName) => {
        // Calibration points (p1, p2) are not soft tissue - always show them
        if (landmarkName === 'p1' || landmarkName === 'p2') {
          return false;
        }
        // Check if it's in the explicit list
        if (softTissueLandmarks.includes(landmarkName)) {
          return true;
        }
        // Check if it ends with prime (') or prime Unicode (â€²)
        return landmarkName.endsWith('\'') || landmarkName.endsWith('â€²');
      };
      
      // ğŸ”§ FIX: Helper function to get required landmarks for each analysis type
      const getRequiredLandmarksForAnalysis = (analysisType) => {
        // Ù‡Ù…ÛŒØ´Ù‡ Ù†Ù‚Ø§Ø· Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
        const required = new Set(['p1', 'p2', 'P1', 'P2']);
        
        // Ù‡Ù…ÛŒØ´Ù‡ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡ (N S Go Pog Me A B Or Po Ar Pt ANS PNS)
        const alwaysShowLandmarks = ['N', 'S', 'Go', 'Pog', 'Me', 'A', 'B', 'Or', 'Po', 'Ar', 'Pt', 'ANS', 'PNS'];
        alwaysShowLandmarks.forEach(landmark => {
          required.add(landmark);
          required.add(landmark.toLowerCase());
          required.add(landmark.toUpperCase());
        });
        
        if (analysisType === 'all') {
          // Ø¯Ø± Ø­Ø§Ù„Øª 'all' Ù‡Ù…Ù‡ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
          return null; // null means show all
        }
        
        // ØªØ¹Ø±ÛŒÙ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¢Ù†Ø§Ù„ÛŒØ²
        const analysisLandmarks = {
          steiner: ['S', 'N', 'A', 'B', 'Pog', 'Go', 'Gn', 'Me', 'Or', 'Po', 'ANS', 'PNS', 'U1', 'U1A', 'L1', 'L1A'],
          ricketts: ['N', 'Pog', 'Pt', 'Ba', 'Go', 'Me', 'Or', 'Po', 'ANS', 'PNS', 'L1', 'LMT', 'Pn', 'Pog\'', 'Pogâ€²', 'Gn', 'U1A', 'L1A', 'UMT'],
          mcnamara: ['N', 'A', 'Pog', 'S', 'Go', 'Me', 'Gn', 'U1', 'L1', 'Co', 'Ar'],
          tweed: ['Or', 'Po', 'Go', 'Me', 'L1A', 'L1', 'L1a'],
          jarabak: ['S', 'N', 'ANS', 'Go', 'Me', 'Gn', 'Ar', 'Co'],
          sassouni: ['S', 'N', 'Me', 'Go', 'Ar', 'Co', 'L1', 'LMT', 'ANS', 'PNS'],
          wits: ['A', 'B', 'L1', 'LMT'],
          leganBurstone: ['G', 'Sn', 'Pog\'', 'Pogâ€²', 'Cm', 'UL', 'LL', 'Or', 'Po', 'Pn', 'Prn', 'Gn\'', 'Gnâ€²', 'C', 'N\'', 'Nâ€²', 'Me\'', 'Meâ€²'],
          arnettMcLaughlin: ['Pn', 'Prn', 'Pog\'', 'Pogâ€²', 'UL', 'LL', 'G', 'Sn', 'Cm', 'Me\'', 'Meâ€²', 'N'],
          holdaway: ['N', 'N\'', 'Nâ€²', 'Pog', 'Pog\'', 'Pogâ€²', 'UL', 'LL', 'UL\'', 'ULâ€²', 'LL\'', 'LLâ€²', 'Or', 'Po'],
          softTissueAngular: ['G', 'Sn', 'Pog\'', 'Pogâ€²', 'Cm', 'UL', 'LL', 'Me\'', 'Meâ€²', 'Gn\'', 'Gnâ€²', 'N\'', 'Nâ€²', 'Li', 'Ls'],
        };
        
        const requiredList = analysisLandmarks[analysisType];
        if (!requiredList) {
          // Ø§Ú¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ØŒ ÙÙ‚Ø· Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
          return required;
        }
        
        // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù (case-insensitive Ùˆ variations)
        requiredList.forEach(landmark => {
          required.add(landmark);
          required.add(landmark.toLowerCase());
          required.add(landmark.toUpperCase());
          // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† variations
          if (landmark.includes('\'')) {
            required.add(landmark.replace(/'/g, 'â€²'));
          }
          if (landmark.includes('â€²')) {
            required.add(landmark.replace(/â€²/g, '\''));
          }
        });
        
        return required;
      };
      
      // Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ² ÙØ¹Ù„ÛŒ
      const requiredLandmarks = getRequiredLandmarksForAnalysis(analysisType);
      
      // Helper function to check if landmark should be shown
      const shouldShowLandmark = (name) => {
        // Ù‡Ù…ÛŒØ´Ù‡ Ù†Ù‚Ø§Ø· Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
        if (name === 'p1' || name === 'p2' || name === 'P1' || name === 'P2') {
          return true;
        }
        
        // Ø§Ú¯Ø± requiredLandmarks null Ø¨Ø§Ø´Ø¯ (analysisType === 'all')ØŒ Ù‡Ù…Ù‡ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
        if (requiredLandmarks === null) {
          // Skip soft tissue landmarks in hard-tissue-only mode
          if (viewMode === 'hard-tissue-only' && isSoftTissueLandmark(name)) {
            return false;
          }
          return true;
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù„Ù†Ø¯Ù…Ø§Ø±Ú© Ø¯Ø± Ù„ÛŒØ³Øª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª
        const nameLower = name.toLowerCase();
        const nameUpper = name.toUpperCase();
        const nameVariations = [
          name,
          nameLower,
          nameUpper,
          name.charAt(0).toUpperCase() + name.slice(1).toLowerCase(),
          name.replace(/'/g, 'â€²'),
          name.replace(/â€²/g, '\''),
        ];
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ…
        if (requiredLandmarks.has(name)) {
          return true;
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ variations
        for (const variation of nameVariations) {
          if (requiredLandmarks.has(variation)) {
            return true;
          }
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ partial match Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ (Ø¨Ø§ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ±)
        for (const required of requiredLandmarks) {
          const requiredLower = required.toLowerCase();
          const nameLower = name.toLowerCase();
          
          // Match Ø¯Ù‚ÛŒÙ‚
          if (nameLower === requiredLower) {
            return true;
          }
          
          // Match Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ prime (Ù…Ø«Ù„ Pog' Ùˆ Pogâ€²)
          if ((requiredLower.includes('pog\'') || requiredLower.includes('pogâ€²')) && 
              (nameLower.includes('pog\'') || nameLower.includes('pogâ€²'))) {
            return true;
          }
          if ((requiredLower.includes('n\'') || requiredLower.includes('nâ€²')) && 
              (nameLower.includes('n\'') || nameLower.includes('nâ€²'))) {
            return true;
          }
          if ((requiredLower.includes('me\'') || requiredLower.includes('meâ€²')) && 
              (nameLower.includes('me\'') || nameLower.includes('meâ€²'))) {
            return true;
          }
          if ((requiredLower.includes('gn\'') || requiredLower.includes('gnâ€²')) && 
              (nameLower.includes('gn\'') || nameLower.includes('gnâ€²'))) {
            return true;
          }
          if ((requiredLower.includes('ul\'') || requiredLower.includes('ulâ€²')) && 
              (nameLower.includes('ul\'') || nameLower.includes('ulâ€²'))) {
            return true;
          }
          if ((requiredLower.includes('ll\'') || requiredLower.includes('llâ€²')) && 
              (nameLower.includes('ll\'') || nameLower.includes('llâ€²'))) {
            return true;
          }
          
          // Match Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ù…Ù„ (Ù…Ø«Ù„ 'Soft tissue Pogonion' Ø¨Ø±Ø§ÛŒ 'Pog\'')
          if (requiredLower === 'pog\'' || requiredLower === 'pogâ€²') {
            if (nameLower.includes('pogonion') || nameLower.includes('pog')) {
              return true;
            }
          }
          if (requiredLower === 'n\'' || requiredLower === 'nâ€²') {
            if (nameLower.includes('nasion') && nameLower.includes('soft')) {
              return true;
            }
          }
          if (requiredLower === 'ul' || requiredLower === 'ul\'') {
            if (nameLower.includes('labiale') && nameLower.includes('superius')) {
              return true;
            }
          }
          if (requiredLower === 'll' || requiredLower === 'll\'') {
            if (nameLower.includes('labiale') && nameLower.includes('inferius')) {
              return true;
            }
          }
          if (requiredLower === 'cm') {
            if (nameLower.includes('columella')) {
              return true;
            }
          }
          if (requiredLower === 'pn' || requiredLower === 'prn') {
            if (nameLower.includes('pronasale')) {
              return true;
            }
          }
          if (requiredLower === 'g') {
            if (nameLower.includes('glabella')) {
              return true;
            }
          }
          if (requiredLower === 'sn') {
            if (nameLower.includes('subnasale')) {
              return true;
            }
          }
        }
        
        return false;
      };
      
      // Draw landmarks - filter based on viewMode and analysis type
      Object.entries(landmarks).forEach(([name, coords]) => {
        // Skip if landmark is not required for current analysis
        if (!shouldShowLandmark(name)) {
          return;
        }
        
        // Skip soft tissue landmarks in hard-tissue-only mode
        if (viewMode === 'hard-tissue-only' && isSoftTissueLandmark(name)) {
          return;
        }
        
        const pos = getLandmarkCanvasPosition(coords);
        if (!pos) {
          return;
        }

        const isHovered = hoveredLandmark === name;
        const isSelected = selectedLandmark === name;
        
        // Scale Ø¨Ø§ smooth transition (0.1s) - Ø§Ø² ref Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        const scale = animatedScalesRef.current[name] || 1.0;
        const size = actualPointSize * scale;

        // Point Ø¨Ø¯ÙˆÙ† shadow
        // Use landmarkColorCache to support backtick variations
        ctx.fillStyle = landmarkColorCache.getColorForLandmark(name);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, 2 * Math.PI);
        ctx.fill();

        // Border - Ù‡Ù…ÛŒØ´Ù‡ Ø³ÙÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ù†Ù‚Ø§Ø·
        // Ø§Ú¯Ø± Ù†Ù‚Ø·Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ border Ø·Ù„Ø§ÛŒÛŒØŒ Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª Ø³ÙÛŒØ¯
        ctx.strokeStyle = isSelected ? '#FFD700' : '#FFFFFF';
        // Use basePointSize for border width calculation (before zoom scaling)
        const baseSizeForBorder = basePointSize * scale;
        const baseBorderWidth = baseSizeForBorder <= 2 ? 0.5 : (baseSizeForBorder <= 4 ? 1 : (isSelected ? 1.5 : 1));
        const borderWidth = (isMobile ? baseBorderWidth / 2 : baseBorderWidth) * zoom;
        ctx.lineWidth = borderWidth;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, 2 * Math.PI);
        ctx.stroke();

        // Label (ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ showLabels ÙØ¹Ø§Ù„ Ø§Ø³Øª) - Ø¨Ø§Ù„Ø§ÛŒ Ø¯Ø§ÛŒØ±Ù‡
        if (showLabels && localShowLandmarkNames) {
          // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙÙˆÙ†Øª Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªØºÛŒÛŒØ± ÙÙˆÙ†Øª - scale with zoom for quality
          // ÙÙˆÙ†Øª Arial ÛŒØ§ sans-serif Ø¨Ø±Ø§ÛŒ Ø«Ø¨Ø§Øª Ø¯Ø± ØªÙ…Ø§Ù… Ø­Ø§Ù„Ø§Øª
          const baseFontSize = isMobile ? 9 : 14; // Ú©ÙˆÚ†Ú©ØªØ± Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
          const fontSize = baseFontSize * zoom; // Scale font size with zoom
          ctx.font = `bold ${fontSize}px Arial, sans-serif`; // ÙÙˆÙ†Øª Ø«Ø§Ø¨Øª Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ
          ctx.fillStyle = '#FFFFFF';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          
          // Fix RTL direction issue - force LTR for landmark names to prevent prime symbol (â€²) from appearing after letter
          // This ensures names like "Pogâ€²" display correctly as "Pogâ€²" not "â€²Pog"
          // Use Unicode Left-to-Right Override (LRO) to force LTR rendering even in RTL context
          const ltrName = `\u202D${name}\u202C`; // LRO + name + PDF (Pop Directional Formatting)
          
          // Shadow/border Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ù†Ø§ÛŒÛŒ Ø¨Ù‡ØªØ± - scale with zoom
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
          const baseLabelLineWidth = isMobile ? 1 : 2;
          ctx.lineWidth = baseLabelLineWidth * zoom;
          
          // Ù†Ù…Ø§ÛŒØ´ Ù†Ø§Ù… Ø¨Ø§Ù„Ø§ÛŒ Ø¯Ø§ÛŒØ±Ù‡ (with LTR override) - scale distance with zoom
          // ÙØ§ØµÙ„Ù‡ Ú©Ù…ØªØ± Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ - Ø§ÙØ²Ø§ÛŒØ´ ÙØ§ØµÙ„Ù‡ Ø¹Ù…ÙˆØ¯ÛŒ
          const baseLabelDistance = isMobile ? 4 : 10;
          const initialLabelY = pos.y - size - (baseLabelDistance * zoom);
          
          ctx.strokeText(ltrName, pos.x, initialLabelY);
          ctx.fillText(ltrName, pos.x, initialLabelY);
          
          // Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ù‡ Ø­Ø§Ù„Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';
        }
      });
    }

    // Draw tracing points - scale with zoom
    if (tracingPoints.length > 0) {
      ctx.strokeStyle = '#00FF00';
      const baseTracingLineWidth = isMobile ? 1 : 2;
      ctx.lineWidth = baseTracingLineWidth * zoom;
      ctx.setLineDash([]);

      ctx.beginPath();
      tracingPoints.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.stroke();

      // Draw points - scale with zoom
      tracingPoints.forEach((point) => {
        ctx.fillStyle = '#00FF00';
        ctx.beginPath();
        const baseTracingPointSize = isMobile ? 2 : 4;
        const tracingPointSize = baseTracingPointSize * zoom;
        ctx.arc(point.x, point.y, tracingPointSize, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    // Draw saved tracing structures - scale with zoom
    tracingStructures.forEach((structure) => {
      ctx.strokeStyle = structure.color || '#FF00FF';
      const baseTracingStructureLineWidth = isMobile ? 1 : 2;
      ctx.lineWidth = baseTracingStructureLineWidth * zoom;
      ctx.setLineDash([]);

      ctx.beginPath();
      structure.points.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      if (structure.closed) {
        ctx.closePath();
      }
      ctx.stroke();
    });

    // Helper function to convert hex to rgba
    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    // Helper function to smooth contour points
    function smoothContourPoints(points) {
      if (!points || points.length < 3) return points;
      
      const smoothed = [];
      const alpha = 0.5; // Smoothing factor
      
      for (let i = 0; i < points.length; i++) {
        const prev = points[i - 1] || points[points.length - 1];
        const curr = points[i];
        const next = points[i + 1] || points[0];
        
        // Weighted average for smoothness
        smoothed.push([
          curr[0] * (1 - alpha) + (prev[0] + next[0]) / 2 * alpha,
          curr[1] * (1 - alpha) + (prev[1] + next[1]) / 2 * alpha
        ]);
      }
      
      return smoothed;
    }

    // Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§ Ùˆ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø¯Ø± Ø¨Ø§Ù„Ø§ Ùˆ Ú†Ù¾ Ø¨Ø±Ø§ÛŒ Ø¢Ù†Ø§Ù„ÛŒØ²Ù‡Ø§ÛŒ Ø´Ù„ÙˆØº
    if (showMeasurements && (analysisType === 'general' || analysisType === 'all')) {
      const currentMeasurements = Object.keys(calculatedMeasurements).length > 0 ? calculatedMeasurements : (measurements || {});
      
      if (Object.keys(currentMeasurements).length > 0) {
        const fontSize = isMobile ? 8 : 11;
        const lineHeight = fontSize * 1.4;
        const padding = 8 * zoom;
        const maxWidth = canvasWidth * 0.3; // Ø­Ø¯Ø§Ú©Ø«Ø± 30% Ø¹Ø±Ø¶ canvas
        const startX = padding;
        const startY = padding;
        
        // ÙÛŒÙ„ØªØ± Ú©Ø±Ø¯Ù† Ùˆ Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§
        const sortedParams = Object.entries(currentMeasurements)
          .filter(([key, value]) => value !== null && value !== undefined && value !== '')
          .sort(([a], [b]) => a.localeCompare(b))
          .slice(0, 30); // Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ù‡ 30 Ù¾Ø§Ø±Ø§Ù…ØªØ± Ø§ÙˆÙ„
        
        // Ø±Ø³Ù… Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Ù„ÛŒØ³Øª
        const listHeight = sortedParams.length * lineHeight + padding * 2;
        const listWidth = Math.min(maxWidth, 200 * zoom);
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(startX, startY, listWidth, listHeight);
        
        // Ø±Ø³Ù… border
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 1 * zoom;
        ctx.strokeRect(startX, startY, listWidth, listHeight);
        
        // Ø±Ø³Ù… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§
        ctx.fillStyle = '#FFFFFF';
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        let currentY = startY + padding;
        sortedParams.forEach(([key, value]) => {
          const displayValue = typeof value === 'number' ? value.toFixed(1) : value;
          const unit = key.includes('Angle') || key.includes('Ø²Ø§ÙˆÛŒÙ‡') || key.includes('Â°') ? 'Â°' : 
                      key.includes('mm') || key.includes('Distance') || key.includes('Height') || key.includes('Length') ? 'mm' : '';
          const text = `${key}: ${displayValue}${unit}`;
          
          // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù…ØªÙ† Ø¯Ø± Ø¹Ø±Ø¶ Ø¬Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
          const textWidth = ctx.measureText(text).width;
          if (textWidth > listWidth - padding * 2) {
            // Ú©ÙˆØªØ§Ù‡ Ú©Ø±Ø¯Ù† Ù…ØªÙ†
            const maxChars = Math.floor((listWidth - padding * 2) / (fontSize * 0.6));
            const shortenedText = text.length > maxChars ? `${text.substring(0, maxChars - 3)}...` : text;
            ctx.fillText(shortenedText, startX + padding, currentY);
          } else {
            ctx.fillText(text, startX + padding, currentY);
          }
          
          currentY += lineHeight;
        });
      }
    }

  }, [
    isImageLoaded,
    zoom,
    pan,
    landmarks,
    showLabels,
    showLines,
    lineColor,
    lineStyle,
    landmarkColors,
    hoveredLandmark,
    selectedLandmark,
    tracingPoints,
    tracingStructures,
    getLandmarkCanvasPosition,
    measurements,
    calculatedMeasurements, // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø²Ø§ÙˆÛŒÙ‡â€ŒÙ‡Ø§
    showMeasurements,
    showTweedTriangle,
    useGradientLines,
    showCoordinateSystemLocal,
    localShowLandmarkNames,
    theme.palette.mode,
    isMobile, // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ DPR Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
    viewMode,
    actualLineWidth,
    actualPointSize,
    basePointSize,
    analysisType,
    pixelToMmConversion,
    calculateAngle,
    calculateAngleBetweenLines,
    landmarkColorCache,
  ]);

  // Smooth scale animation for hover effect (0.1s transition)
  useEffect(() => {
    if (!isImageLoaded) return;

    const targetScales = {};
    Object.keys(landmarks).forEach(name => {
      targetScales[name] = name === hoveredLandmark ? 1.5 : 1.0;
    });

    let animationId = null;

    const animateScales = () => {
      let hasChanges = false;

      Object.keys(targetScales).forEach(name => {
        const current = animatedScalesRef.current[name] || 1.0;
        const target = targetScales[name];
        const diff = target - current;

        if (Math.abs(diff) > 0.01) {
          // Smooth transition over ~100ms (at 60fps, ~6 frames)
          animatedScalesRef.current[name] = current + diff * 0.3; // 30% per frame
          hasChanges = true;
        } else {
          animatedScalesRef.current[name] = target;
        }
      });

      // Redraw canvas
      if (hasChanges) {
        drawCanvas();
        animationId = requestAnimationFrame(animateScales);
      }
    };

    // Start animation
    animationId = requestAnimationFrame(animateScales);

    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [hoveredLandmark, isImageLoaded, landmarks, drawCanvas]);

  // Draw on changes - Ø¨Ø§ throttle Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² render Ù‡Ø§ÛŒ Ø²ÛŒØ§Ø¯ Ø¯Ø± Ø­ÛŒÙ† drag
  const drawCanvasRafRef = useRef(null);
  
  useEffect(() => {
    if (!isImageLoaded) return;
    
    // Ø§Ú¯Ø± Ø¯Ø± Ø­Ø§Ù„ drag Ù‡Ø³ØªÛŒÙ…ØŒ canvas Ø±Ø§ Ø¯Ø± handleMouseMove Ø¨Ø±ÙˆØ² Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    // Ø§ÛŒÙ†Ø¬Ø§ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ±Ø§Øª Ø¯ÛŒÚ¯Ø± canvas Ø±Ø§ Ø±Ø³Ù… Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
    if (draggedLandmark) {
      return;
    }
    
    // Ù„ØºÙˆ requestAnimationFrame Ù‚Ø¨Ù„ÛŒ
    if (drawCanvasRafRef.current) {
      cancelAnimationFrame(drawCanvasRafRef.current);
    }
    
    drawCanvasRafRef.current = requestAnimationFrame(() => {
      drawCanvas();
      drawCanvasRafRef.current = null;
    });
    
    return () => {
      if (drawCanvasRafRef.current) {
        cancelAnimationFrame(drawCanvasRafRef.current);
        drawCanvasRafRef.current = null;
      }
    };
  }, [landmarks, pan, zoom, lineColor, lineWidth, lineStyle, showLabels, showLines, useGradientLines, landmarkColors, showTweedTriangle, measurements, isImageLoaded, tracingPoints, tracingStructures, draggedLandmark, drawCanvas, analysisType, showMeasurements, calculatedMeasurements, containerHeight, showCoordinateSystemLocal, localShowLandmarkNames]); // ğŸ”§ FIX: Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† containerHeight Ø¨Ø±Ø§ÛŒ re-render

  // Handle resize
  useEffect(() => {
    const handleResize = () => {
      if (isImageLoaded) {
        drawCanvas();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [drawCanvas, isImageLoaded]);

  // Helper function to check if landmark should be shown (for click handlers)
  const shouldShowLandmarkForClick = useCallback((landmarkName) => {
    // Ù‡Ù…ÛŒØ´Ù‡ Ù†Ù‚Ø§Ø· Ú©Ø§Ù„ÛŒØ¨Ø±Ø§Ø³ÛŒÙˆÙ† Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
    if (landmarkName === 'p1' || landmarkName === 'p2' || landmarkName === 'P1' || landmarkName === 'P2') {
      return true;
    }

    // Define soft tissue landmarks
    const softTissueLandmarks = [
      'Li', 'LL', 'UL', 'Sn', 'Pn', 'Cm', 'cm', 'CM', 'columella', 'Columella', 'LL\'', 'UL\'', 'LMT', 'UMT',
      'Pog\'', 'Gn\'', 'Me\'', 'N\'',
      'Pogâ€²', 'Gnâ€²', 'Meâ€²', 'Nâ€²',
    ];
    
    const isSoftTissueLandmark = (name) => {
      if (name === 'p1' || name === 'p2') return false;
      if (softTissueLandmarks.includes(name)) return true;
      return name.endsWith('\'') || name.endsWith('â€²');
    };

    // Get required landmarks for analysis
    const getRequiredLandmarksForAnalysis = (type) => {
      const required = new Set(['p1', 'p2', 'P1', 'P2']);
      
      // Ù‡Ù…ÛŒØ´Ù‡ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡ (N S Go Pog Me A B Or Po Ar Pt ANS PNS)
      const alwaysShowLandmarks = ['N', 'S', 'Go', 'Pog', 'Me', 'A', 'B', 'Or', 'Po', 'Ar', 'Pt', 'ANS', 'PNS'];
      alwaysShowLandmarks.forEach(landmark => {
        required.add(landmark);
        required.add(landmark.toLowerCase());
        required.add(landmark.toUpperCase());
      });
      
      if (type === 'all') {
        return null; // null means show all
      }
      
      const analysisLandmarks = {
        steiner: ['S', 'N', 'A', 'B', 'Pog', 'Go', 'Gn', 'Me', 'Or', 'Po', 'ANS', 'PNS', 'U1', 'U1A', 'L1', 'L1A'],
        ricketts: ['N', 'Pog', 'Pt', 'Ba', 'Go', 'Me', 'Or', 'Po', 'ANS', 'PNS', 'L1', 'LMT', 'Pn', 'Pog\'', 'Pogâ€²', 'UL', 'LL', 'Ls', 'Li'],
        mcnamara: ['N', 'A', 'Pog', 'S', 'Go', 'Me', 'Gn', 'U1', 'L1', 'Co', 'Ar'],
        tweed: ['Or', 'Po', 'Go', 'Me', 'L1A', 'L1', 'L1a'],
        jarabak: ['S', 'N', 'Go', 'Me', 'Gn', 'Ar', 'Co'],
        sassouni: ['S', 'N', 'Me', 'Go', 'Ar', 'Co', 'L1', 'LMT', 'ANS', 'PNS'],
        wits: ['A', 'B', 'L1', 'LMT'],
        leganBurstone: ['G', 'Sn', 'Pog\'', 'Pog`', 'Pogâ€²', 'Cm', 'UL', 'LL', 'Or', 'Po', 'Pn', 'Prn', 'Gn\'', 'Gn`', 'Gnâ€²', 'C', 'N\'', 'N`', 'Nâ€²', 'Me\'', 'Me`', 'Meâ€²'],
        arnettMcLaughlin: ['Pn', 'Prn', 'Pog\'', 'Pog`', 'Pogâ€²', 'UL', 'LL', 'G', 'Sn', 'Cm', 'Me\'', 'Me`', 'Meâ€²', 'N'],
        holdaway: ['N', 'N\'', 'N`', 'Nâ€²', 'Pog', 'Pog\'', 'Pog`', 'Pogâ€²', 'UL', 'LL', 'UL\'', 'UL`', 'ULâ€²', 'LL\'', 'LL`', 'LLâ€²', 'Or', 'Po'],
        softTissueAngular: ['G', 'Sn', 'Pog\'', 'Pog`', 'Pogâ€²', 'Cm', 'UL', 'LL', 'Me\'', 'Me`', 'Meâ€²', 'Gn\'', 'Gn`', 'Gnâ€²', 'N\'', 'N`', 'Nâ€²', 'Li', 'Ls'],
      };
      
      const requiredList = analysisLandmarks[type];
      if (!requiredList) {
        // Ø§Ú¯Ø± Ø¢Ù†Ø§Ù„ÛŒØ² ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ØŒ ÙÙ‚Ø· Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
        return required;
      }
      
      requiredList.forEach(landmark => {
        required.add(landmark);
        required.add(landmark.toLowerCase());
        required.add(landmark.toUpperCase());
        if (landmark.includes('\'')) {
          required.add(landmark.replace(/'/g, 'â€²'));
          required.add(landmark.replace(/'/g, '`'));
        }
        if (landmark.includes('â€²')) {
          required.add(landmark.replace(/â€²/g, '\''));
          required.add(landmark.replace(/â€²/g, '`'));
        }
        if (landmark.includes('`')) {
          required.add(landmark.replace(/`/g, '\''));
          required.add(landmark.replace(/`/g, 'â€²'));
        }
      });
      
      return required;
    };

    const requiredLandmarks = getRequiredLandmarksForAnalysis(analysisType);
    
    // Ø§Ú¯Ø± requiredLandmarks null Ø¨Ø§Ø´Ø¯ (analysisType === 'all')ØŒ Ù‡Ù…Ù‡ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
    if (requiredLandmarks === null) {
      // Skip soft tissue landmarks in hard-tissue-only mode
      if (viewMode === 'hard-tissue-only' && isSoftTissueLandmark(landmarkName)) {
        return false;
      }
      return true;
    }
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù„Ù†Ø¯Ù…Ø§Ø±Ú© Ø¯Ø± Ù„ÛŒØ³Øª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª
    const nameLower = landmarkName.toLowerCase();
    const nameVariations = [
      landmarkName,
      nameLower,
      landmarkName.toUpperCase(),
      landmarkName.charAt(0).toUpperCase() + landmarkName.slice(1).toLowerCase(),
      landmarkName.replace(/'/g, 'â€²'),
      landmarkName.replace(/â€²/g, '\''),
      landmarkName.replace(/`/g, '\''),
      landmarkName.replace(/'/g, '`'),
      landmarkName.replace(/`/g, 'â€²'),
      landmarkName.replace(/â€²/g, '`'),
    ];
    
    // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ…
    if (requiredLandmarks.has(landmarkName)) {
      return true;
    }
    
    // Ø¨Ø±Ø±Ø³ÛŒ variations
    for (const variation of nameVariations) {
      if (requiredLandmarks.has(variation)) {
        return true;
      }
    }
    
    // Ø¨Ø±Ø±Ø³ÛŒ partial match Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ
    for (const required of requiredLandmarks) {
      const requiredLower = required.toLowerCase();
      
      if (nameLower === requiredLower) {
        return true;
      }
      
      // Match Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ÛŒ Ø¨Ø§ prime
      if ((requiredLower.includes('pog\'') || requiredLower.includes('pogâ€²')) && 
          (nameLower.includes('pog\'') || nameLower.includes('pogâ€²'))) {
        return true;
      }
      if ((requiredLower.includes('n\'') || requiredLower.includes('nâ€²')) && 
          (nameLower.includes('n\'') || nameLower.includes('nâ€²'))) {
        return true;
      }
      if ((requiredLower.includes('me\'') || requiredLower.includes('meâ€²')) && 
          (nameLower.includes('me\'') || nameLower.includes('meâ€²'))) {
        return true;
      }
      if ((requiredLower.includes('gn\'') || requiredLower.includes('gnâ€²')) && 
          (nameLower.includes('gn\'') || nameLower.includes('gnâ€²'))) {
        return true;
      }
      if ((requiredLower.includes('ul\'') || requiredLower.includes('ulâ€²')) && 
          (nameLower.includes('ul\'') || nameLower.includes('ulâ€²'))) {
        return true;
      }
      if ((requiredLower.includes('ll\'') || requiredLower.includes('llâ€²')) && 
          (nameLower.includes('ll\'') || nameLower.includes('llâ€²'))) {
        return true;
      }
      
      // Match Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ù…Ù„
      if (requiredLower === 'pog\'' || requiredLower === 'pogâ€²') {
        if (nameLower.includes('pogonion') || nameLower.includes('pog')) {
          return true;
        }
      }
      if (requiredLower === 'n\'' || requiredLower === 'nâ€²') {
        if (nameLower.includes('nasion') && nameLower.includes('soft')) {
          return true;
        }
      }
      if (requiredLower === 'ul' || requiredLower === 'ul\'') {
        if (nameLower.includes('labiale') && nameLower.includes('superius')) {
          return true;
        }
      }
      if (requiredLower === 'll' || requiredLower === 'll\'') {
        if (nameLower.includes('labiale') && nameLower.includes('inferius')) {
          return true;
        }
      }
      if (requiredLower === 'cm') {
        if (nameLower.includes('columella')) {
          return true;
        }
      }
      if (requiredLower === 'pn' || requiredLower === 'prn') {
        if (nameLower.includes('pronasale')) {
          return true;
        }
      }
      if (requiredLower === 'g') {
        if (nameLower.includes('glabella')) {
          return true;
        }
      }
      if (requiredLower === 'sn') {
        if (nameLower.includes('subnasale')) {
          return true;
        }
      }
    }
    
    return false;
  }, [analysisType, viewMode]);

  // Click handler for desktop - Ù†Ù…Ø§ÛŒØ´ snackbar Ø¨Ø§ ÛŒÚ© Ú©Ù„ÛŒÚ©
  const handleCanvasClick = (e) => {
    // ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø¯Ø³Ú©ØªØ§Ù¾
    if (isMobile) return;
    
    const canvas = canvasRef.current;
    const rect = containerRef.current?.getBoundingClientRect() || canvas.getBoundingClientRect();
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    // Check if clicking on landmark
    const clickedLandmark = findLandmarkAtPosition(canvasX, canvasY);
    
    // Debug: log all landmarks to see what names are actually in the state
    if (clickedLandmark && (clickedLandmark.includes('`') || clickedLandmark.includes('\'') || clickedLandmark.includes('â€²'))) {
      console.log('ğŸ” [Debug] Clicked soft tissue landmark:', clickedLandmark, '| All landmarks:', Object.keys(landmarks).filter(k => k.includes('`') || k.includes('\'') || k.includes('â€²')));
    }
    
    // Normalize landmark name for LANDMARK_DESCRIPTIONS lookup
    const normalizedLandmarkName = clickedLandmark ? normalizeLandmarkNameForDescription(clickedLandmark) : null;
    
    // Debug: log normalization result
    if (clickedLandmark && normalizedLandmarkName && (clickedLandmark.includes('`') || clickedLandmark.includes('\'') || clickedLandmark.includes('â€²'))) {
      console.log('ğŸ” [Debug] Normalized:', clickedLandmark, '->', normalizedLandmarkName, '| Has description:', !!LANDMARK_DESCRIPTIONS[normalizedLandmarkName], '| Should show:', shouldShowLandmarkForClick(clickedLandmark));
    }

    // Ù†Ù…Ø§ÛŒØ´ snackbar Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§ Ø¯Ø± Ø¯Ø³Ú©ØªØ§Ù¾ - ÙÙ‚Ø· Ø¯Ø± Ø­Ø§Ù„Øª readOnly Ùˆ ÙÙ‚Ø· Ø§Ú¯Ø± Ù„Ù†Ø¯Ù…Ø§Ø±Ú© Ù‚Ø§Ø¨Ù„ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø§Ø´Ø¯
    if (normalizedLandmarkName && LANDMARK_DESCRIPTIONS[normalizedLandmarkName] && readOnly && shouldShowLandmarkForClick(clickedLandmark)) {
      console.log('ğŸ–¥ï¸ [Snackbar] Opening snackbar for landmark:', clickedLandmark, '->', normalizedLandmarkName);
      setLandmarkSnackbarContent(clickedLandmark);
      setLandmarkSnackbarDisplayContent(normalizedLandmarkName);
      setLandmarkSnackbarOpen(true);
      e.stopPropagation(); // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² propagation
    } else if (clickedLandmark && (clickedLandmark.includes('`') || clickedLandmark.includes('\'') || clickedLandmark.includes('â€²'))) {
      // Debug: why snackbar didn't open
      console.log('âŒ [Debug] Snackbar NOT opened for:', clickedLandmark, {
        normalized: normalizedLandmarkName,
        hasDescription: !!LANDMARK_DESCRIPTIONS[normalizedLandmarkName],
        readOnly,
        shouldShow: shouldShowLandmarkForClick(clickedLandmark)
      });
    }
  };

  // Mouse handlers
  const handleMouseDown = (e) => {
    const canvas = canvasRef.current;
    const rect = containerRef.current?.getBoundingClientRect() || canvas.getBoundingClientRect();
    // ğŸ”§ FIX: Mouse coordinates are already in CSS pixels, no need to scale by canvas.width/rect.width
    // Ú†ÙˆÙ† canvas Ø¨Ø§ DPR scale Ø´Ø¯Ù‡ØŒ Ù…Ø§ Ø¨Ø§ÛŒØ¯ Ø§Ø² display coordinates Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ…
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    // Check if clicking on landmark
    const clickedLandmark = findLandmarkAtPosition(canvasX, canvasY);
    
    // Normalize landmark name for LANDMARK_DESCRIPTIONS lookup
    const normalizedLandmarkName = clickedLandmark ? normalizeLandmarkNameForDescription(clickedLandmark) : null;

    // Ù†Ù…Ø§ÛŒØ´ snackbar Ø¨Ø±Ø§ÛŒ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©â€ŒÙ‡Ø§
    // Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„: ÙÙ‚Ø· Ø¯Ø± Ø­Ø§Ù„Øª readOnly Ùˆ ÙÙ‚Ø· Ø§Ú¯Ø± Ù„Ù†Ø¯Ù…Ø§Ø±Ú© Ù‚Ø§Ø¨Ù„ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø§Ø´Ø¯
    if (normalizedLandmarkName && LANDMARK_DESCRIPTIONS[normalizedLandmarkName]) {
      // Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„: ÙÙ‚Ø· Ø¯Ø± Ø­Ø§Ù„Øª readOnly
      if (isMobile && readOnly && shouldShowLandmarkForClick(clickedLandmark)) {
        console.log('ğŸ“± [Snackbar] Opening snackbar for landmark:', clickedLandmark, '->', normalizedLandmarkName);
        // ØªÙ†Ø¸ÛŒÙ… Ù…Ø­ØªÙˆØ§
        setLandmarkSnackbarContent(clickedLandmark);
        setLandmarkSnackbarDisplayContent(normalizedLandmarkName);
        
        // Ù‡Ù…ÛŒØ´Ù‡ snackbar Ø±Ø§ Ø¨Ø§Ø² Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² key Ø¯Ø± Snackbar Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ ÙˆÙ‚ØªÛŒ Ù…Ø­ØªÙˆØ§ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŒ
        // Snackbar Ø¯ÙˆØ¨Ø§Ø±Ù‡ mount Ø´ÙˆØ¯ Ùˆ timer reset Ø´ÙˆØ¯
        setLandmarkSnackbarOpen(true);
        return; // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² drag ÛŒØ§ Ø³Ø§ÛŒØ± Ø¹Ù…Ù„ÛŒØ§Øª
      }
    }

    if (clickedLandmark && !readOnly) {
      // Drag mode - ÙÙ‚Ø· Ø§Ú¯Ø± readOnly Ù†Ø¨Ø§Ø´Ø¯
      setDraggedLandmark(clickedLandmark);
      setSelectedLandmark(clickedLandmark);

      // Ø°Ø®ÛŒØ±Ù‡ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ drag ÙˆØ§Ù‚Ø¹ÛŒ
      const landmarkPos = landmarks[clickedLandmark];
      if (landmarkPos) {
        dragStartPosition.current = { x: landmarkPos.x, y: landmarkPos.y };
        hasDragged.current = false;
      }
    } else if (isAddMode && !readOnly) {
      // Add mode - Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† modal Ø¨Ø±Ø§ÛŒ Ù†ÙˆØ´ØªÙ† Ù†Ø§Ù… (ÙÙ‚Ø· Ø§Ú¯Ø± readOnly Ù†Ø¨Ø§Ø´Ø¯)
      const imageCoords = getImageCoordinates(canvasX, canvasY);
      if (imageCoords) {
        setPendingLandmarkCoords(imageCoords);
        setIsAddModalOpen(true);
        setIsAddMode(false); // Ø®Ø§Ù…ÙˆØ´ Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Add
      }
    } else if (isTracingMode && !readOnly) {
      // Tracing mode
      setTracingPoints([...tracingPoints, { x: canvasX, y: canvasY }]);
    } else if (!readOnly) {
      // Pan mode - ÙÙ‚Ø· Ø§Ú¯Ø± readOnly Ù†Ø¨Ø§Ø´Ø¯
      setIsPanning(true);
      setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
    }
    // Ø§Ú¯Ø± readOnly Ø§Ø³ØªØŒ Ù‡ÛŒÚ† Ú©Ø§Ø±ÛŒ Ù†Ú©Ù† (pan Ùˆ drag ØºÛŒØ±ÙØ¹Ø§Ù„)
  };

  // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ref Ù‡Ù†Ú¯Ø§Ù…ÛŒ Ú©Ù‡ landmarks ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯
  useEffect(() => {
    landmarksRef.current = landmarks;
  }, [landmarks]);

  const handleMouseMove = (e) => {
    const canvas = canvasRef.current;
    const rect = containerRef.current?.getBoundingClientRect() || canvas.getBoundingClientRect();
    // ğŸ”§ FIX: Mouse coordinates are already in CSS pixels, no need to scale by canvas.width/rect.width
    // Ú†ÙˆÙ† canvas Ø¨Ø§ DPR scale Ø´Ø¯Ù‡ØŒ Ù…Ø§ Ø¨Ø§ÛŒØ¯ Ø§Ø² display coordinates Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒÙ…
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    if (draggedLandmark && !readOnly) {
      // Dragging landmark - ÙÙ‚Ø· Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ visualØŒ Ø¨Ø¯ÙˆÙ† callback
      // Ø§ÛŒÙ† Ú©Ø§Ø± Ø¨Ø§Ø¹Ø« Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ú©Ù‡ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¢Ù†Ø§Ù„ÛŒØ² ÙÙ‚Ø· Ø¯Ø± mouseUp Ø§Ù†Ø¬Ø§Ù… Ø´ÙˆØ¯
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² requestAnimationFrame Ø¨Ø±Ø§ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ performance
      // ÙÙ‚Ø· Ø§Ú¯Ø± readOnly Ù†Ø¨Ø§Ø´Ø¯
      if (rafRef.current) {
        cancelAnimationFrame(rafRef.current);
      }

      rafRef.current = requestAnimationFrame(() => {
        const imageCoords = getImageCoordinates(canvasX, canvasY);
        if (imageCoords && draggedLandmark) {
          // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ø¬Ø§Ø¨Ø¬Ø§ Ø´Ø¯Ù‡ ÛŒØ§ Ù†Ù‡
          const currentPos = landmarksRef.current[draggedLandmark];
          if (currentPos && (Math.abs(currentPos.x - imageCoords.x) > 0.1 || Math.abs(currentPos.y - imageCoords.y) > 0.1)) {
            hasDragged.current = true; // Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ú©Ù‡ drag ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
          }

          // ÙÙ‚Ø· state Ù…Ø­Ù„ÛŒ Ø±Ø§ Ø¨Ø±ÙˆØ² Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…ØŒ callback Ø±Ø§ ØµØ¯Ø§ Ù†Ù…ÛŒâ€ŒØ²Ù†ÛŒÙ…
          setLandmarks(prev => {
            const updated = {
              ...prev,
              [draggedLandmark]: {
                ...prev[draggedLandmark],
                x: imageCoords.x,
                y: imageCoords.y
              }
            };
            // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ref Ù‡Ù…Ø²Ù…Ø§Ù†
            landmarksRef.current = updated;
            return updated;
          });
          // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ canvas ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ visual (Ø¨Ø¯ÙˆÙ† Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù†Ø§Ù„ÛŒØ²)
          // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² requestAnimationFrame Ø¨Ø±Ø§ÛŒ Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ
          requestAnimationFrame(() => {
            drawCanvas();
          });
          // onLandmarksChange Ø±Ø§ ØµØ¯Ø§ Ù†Ù…ÛŒâ€ŒØ²Ù†ÛŒÙ… ØªØ§ Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø¢Ù†Ø§Ù„ÛŒØ² Ø§Ù†Ø¬Ø§Ù… Ù†Ø´ÙˆØ¯
        }
      });

      // Ù¾Ù†Ù‡Ø§Ù† Ú©Ø±Ø¯Ù† tooltip Ø¯Ø± Ø­ÛŒÙ† drag
      setCanvasTooltip({ show: false, text: '', x: 0, y: 0 });
    } else if (isPanning && !readOnly) {
      // Panning - ÙÙ‚Ø· Ø§Ú¯Ø± readOnly Ù†Ø¨Ø§Ø´Ø¯
      setPan({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y
      });
      // Ù¾Ù†Ù‡Ø§Ù† Ú©Ø±Ø¯Ù† tooltip Ø¯Ø± Ø­ÛŒÙ† pan
      setCanvasTooltip({ show: false, text: '', x: 0, y: 0 });
    } else {
      // Check for hover on landmarks
      const hoveredLm = findLandmarkAtPosition(canvasX, canvasY);
      setHoveredLandmark(hoveredLm);

      // â­ Contour hover ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯ (tooltip Ø­Ø°Ù Ø´Ø¯Ù‡)
      // const hoveredCnt = findContourAtPosition(canvasX, canvasY);
      // setHoveredContour(hoveredCnt);
      setHoveredContour(null); // Ù‡Ù…ÛŒØ´Ù‡ null
      const hoveredCnt = null; // ØªØ¹Ø±ÛŒÙ Ù…ØªØºÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø®Ø·Ø§

      // Tooltip Ø­Ø°Ù Ø´Ø¯Ù‡ - Ø¯ÛŒÚ¯Ø± Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯
      setCanvasTooltip({ show: false, text: '', x: 0, y: 0 });

      // Change cursor - Ø¯Ø± Ø­Ø§Ù„Øª readOnly Ù‡Ù…ÛŒØ´Ù‡ default
      // Ø¯Ø± Ø­Ø§Ù„Øª ÙˆÛŒØ±Ø§ÛŒØ´ Ù‡Ù… cursor Ø¨Ø§ÛŒØ¯ default Ø¨Ø§Ø´Ø¯
      canvas.style.cursor = 'default';
    }
  };

  const handleMouseUp = () => {
    // Ù„ØºÙˆ requestAnimationFrame Ø¯Ø± ØµÙˆØ±Øª ÙˆØ¬ÙˆØ¯
    if (rafRef.current) {
      cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
    }

    // Ø§Ú¯Ø± landmark Ø¯Ø± Ø­Ø§Ù„ drag Ø¨ÙˆØ¯ØŒ Ø­Ø§Ù„Ø§ Ú©Ù‡ Ø±Ù‡Ø§ Ø´Ø¯ØŒ ÙÙ‚Ø· Ø§Ú¯Ø± ÙˆØ§Ù‚Ø¹Ø§Ù‹ Ø¬Ø§Ø¨Ø¬Ø§ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ callback Ø±Ø§ ØµØ¯Ø§ Ø¨Ø²Ù†
    const currentDraggedLandmark = draggedLandmark;
    if (currentDraggedLandmark && hasDragged.current) {
      // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ref Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¢Ø®Ø±ÛŒÙ† landmarks
      // Ùˆ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² setTimeout Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ ØªÙ…Ø§Ù… state updates Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
      setTimeout(() => {
        // ÙÙ‚Ø· Ø§Ú¯Ø± landmarks ÙˆØ§Ù‚Ø¹Ø§Ù‹ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ callback Ø±Ø§ ØµØ¯Ø§ Ø¨Ø²Ù†
        const finalLandmarks = landmarksRef.current;
        if (finalLandmarks && Object.keys(finalLandmarks).length > 0) {
          onLandmarksChange?.(finalLandmarks);
        }
      }, 10); // Ú©Ù…ÛŒ delay Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ state
    }

    // Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ drag
    setDraggedLandmark(null);
    dragStartPosition.current = null;
    hasDragged.current = false;
    setIsPanning(false);
  };

  const handleContextMenu = (e) => {
    e.preventDefault();
    // Ø§Ú¯Ø± readOnly Ø§Ø³ØªØŒ context menu Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ù†Ø¯Ù‡
    if (readOnly) {
      return;
    }
    
    const canvas = canvasRef.current;
    const rect = containerRef.current?.getBoundingClientRect() || canvas.getBoundingClientRect();
    // ğŸ”§ FIX: Mouse coordinates are already in CSS pixels, no need to scale by canvas.width/rect.width
    const canvasX = e.clientX - rect.left;
    const canvasY = e.clientY - rect.top;

    const clickedLandmark = findLandmarkAtPosition(canvasX, canvasY);

    if (clickedLandmark) {
      setContextMenu({
        landmark: clickedLandmark,
        mouseX: e.clientX,
        mouseY: e.clientY,
      });
    }
  };

  const handleCloseContextMenu = () => {
    setContextMenu(null);
  };

  const handleDeleteLandmark = () => {
    if (contextMenu?.landmark) {
      const newLandmarks = { ...landmarks };
      delete newLandmarks[contextMenu.landmark];
      setLandmarks(newLandmarks);
      onLandmarksChange?.(newLandmarks);
    }
    handleCloseContextMenu();
  };

  const handleSelectLandmarkColor = (color) => {
    if (contextMenu?.landmark) {
      setLandmarkColors({
        ...landmarkColors,
        [contextMenu.landmark]: color
      });
    }
    handleCloseContextMenu();
  };

  const handleConfirmAddLandmark = () => {
    if (newLandmarkNameModal && pendingLandmarkCoords) {
      const newLandmarks = {
        ...landmarks,
        [newLandmarkNameModal]: { 
          x: pendingLandmarkCoords.x, 
          y: pendingLandmarkCoords.y, 
          confidence: 1 
        }
      };
      setLandmarks(newLandmarks);
      onLandmarksChange?.(newLandmarks);
    }
    // Reset
    setIsAddModalOpen(false);
    setNewLandmarkNameModal('');
    setPendingLandmarkCoords(null);
  };

  const handleWheel = (e) => {
    // Zoom with mouse wheel disabled
    // e.preventDefault();
    // e.stopPropagation();
    // const delta = e.deltaY > 0 ? -0.1 : 0.1;
    // setZoom((prev) => Math.max(0.5, Math.min(5, prev + delta)));
  };

  const handleResetView = () => {
    setZoom(1);
    setPan({ x: 0, y: 0 });
  };

  const handleDownloadCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) {
      console.error('Canvas not found');
      return;
    }

    // Create a temporary canvas to draw the current canvas content
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Draw the current canvas content to temp canvas
    tempCtx.drawImage(canvas, 0, 0);
    
    // Convert to blob and download
    tempCanvas.toBlob((blob) => {
      if (!blob) {
        console.error('Failed to create blob');
        return;
      }
      
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `cephalometric-analysis-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }, 'image/png');
  };

  const handleSaveTracing = () => {
    if (tracingPoints.length > 0 && currentTracingName) {
      setTracingStructures([
        ...tracingStructures,
        {
          name: currentTracingName,
          points: [...tracingPoints],
          color: '#FF00FF',
          closed: true
        }
      ]);
      setTracingPoints([]);
      setCurrentTracingName('');
      setIsTracingMode(false);
    }
  };

  const handleClearTracing = () => {
    setTracingPoints([]);
  };

  return (
    <>
    <Stack spacing={2}>
      {/* Toolbar - ÙÙ‚Ø· Ø¯Ø± Ø­Ø§Ù„Øª ÙˆÛŒØ±Ø§ÛŒØ´ (Ù†Ù‡ readOnly) */}
      {!readOnly && (
        <Card>
        <CardContent>
          <Stack 
            spacing={2}
            sx={{
              minHeight: 120, // Reserve space to prevent layout shift when icons load
            }}
          >
            {/* Zoom & Pan */}
            <Stack direction="row" spacing={2} alignItems="center" flexWrap="wrap" justifyContent="center">
              <Stack direction="row" spacing={1}>
                <IconButton 
                  size="small" 
                  onClick={() => setZoom(z => Math.min(z + 0.2, 5))}
                  sx={{ minWidth: 40, minHeight: 40 }} // Reserve space to prevent layout shift
                >
                  <Iconify icon="solar:magnifer-zoom-in-linear" />
                </IconButton>
                <IconButton 
                  size="small" 
                  onClick={() => setZoom(z => Math.max(z - 0.2, 0.5))}
                  sx={{ minWidth: 40, minHeight: 40 }} // Reserve space to prevent layout shift
                >
                  <Iconify icon="solar:magnifer-zoom-out-linear" />
                </IconButton>


				
				
				              {/* Show/Hide Landmark Names Button - like LandmarkVisualizer */}
              <Tooltip title={localShowLandmarkNames ? "Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù† Ù„Ù†Ø¯Ù…Ø§Ø±Ú©" : "Ù†Ù…Ø§ÛŒØ´ Ù„Ù†Ø¯Ù…Ø§Ø±Ú©"}>
                <IconButton
                  size="small"
                  onClick={() => {
                    setLocalShowLandmarkNames(!localShowLandmarkNames);
                  }}
                  color={localShowLandmarkNames ? "primary" : "default"}
                  sx={{ minWidth: 40, minHeight: 40 }} // Reserve space to prevent layout shift
                >
                  <Iconify icon={localShowLandmarkNames ? "solar:tag-bold" : "solar:tag-linear"} />
                </IconButton>
              </Tooltip>
              {/* Lines Toggle */}
              <Tooltip title="Ø®Ø·ÙˆØ·">
                <IconButton
                  size="small"
                  onClick={() => setShowLines(!showLines)}
                  sx={{
                    color: showLines ? 'primary.main' : 'text.secondary',
                    minWidth: 40, // Reserve space to prevent layout shift
                    minHeight: 40, // Reserve space to prevent layout shift
                  }}
                >
                  <Iconify icon="solar:hamburger-menu-linear" width={20} />
                </IconButton>
              </Tooltip>
              </Stack>







            </Stack>

            {/* Point & Line Settings */}
            <Stack direction="row" spacing={3} alignItems="center" flexWrap="wrap" justifyContent="center">
              <Stack direction="row" spacing={1} alignItems="center">
                {/* 5 Ø±Ù†Ú¯ Ø³Ø±ÛŒØ¹ */}
                <Stack direction="row" spacing={1}>
                  {QUICK_COLORS.map((color) => (
                    <IconButton
                      key={color}
                      size="small"
                      onClick={() => {
                        if (selectedLandmark) {
                          // Ø§Ú¯Ø± Ù„Ù†dmØ§Ø±Ú© Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ØŒ Ø±Ù†Ú¯ Ø¢Ù† Ø±Ø§ ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡
                          setLandmarkColors({
                            ...landmarkColors,
                            [selectedLandmark]: color
                          });
                        } else {
                          // Ø§Ú¯Ø± Ù„Ù†dmØ§Ø±Ú© Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ØŒ Ø±Ù†Ú¯ Ø®Ø· Ø±Ø§ ØªØºÛŒÛŒØ± Ø¨Ø¯Ù‡
                          setLineColor(color);
                        }
                      }}
                      sx={{
                        width: 24,
                        height: 24,
                        minWidth: 24, // Reserve space to prevent layout shift
                        minHeight: 24, // Reserve space to prevent layout shift
                        bgcolor: color,
                        border: '1px solid',
                        borderColor: 'divider',
                        flexShrink: 0, // Prevent shrinking
                        '&:hover': {
                          bgcolor: color, // Ø­ÙØ¸ Ø±Ù†Ú¯ Ø§ØµÙ„ÛŒ Ø¯Ø± hover
                        }
                      }}
                    />
                  ))}
                </Stack>
                
                {/* Ø¯Ú©Ù…Ù‡ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ù¾Ù†Ø¬Ø±Ù‡ 20 Ø±Ù†Ú¯ - Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¢ÛŒÚ©Ù† carbon:color-palette Ù…Ø§Ù†Ù†Ø¯ radiology */}
                <IconButton
                  size="small"
                  onClick={(e) => setLineColorAnchor(e.currentTarget)}
                  sx={{
                    width: 28,
                    height: 28,
                    minWidth: 28, // Reserve space to prevent layout shift
                    minHeight: 28, // Reserve space to prevent layout shift
                    border: '2px solid',
                    borderColor: 'divider',
                    '&:hover': {
                      opacity: 0.8,
                    },
                    display: 'flex', // Ensure flex display
                    alignItems: 'center', // Center icon vertically
                    justifyContent: 'center', // Center icon horizontally
                  }}
                >
                  <Box
                    sx={{
                      width: 20,
                      height: 20,
                      minWidth: 20, // Reserve space for icon
                      minHeight: 20, // Reserve space for icon
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                  }}
                >
                  <Iconify 
                    icon="carbon:color-palette" 
                    width={20} 
                    sx={{
                      color: theme.palette.mode === 'dark' 
                        ? 'rgba(255, 255, 255, 0.85)' // Ø³ÙÛŒØ¯ Ø¨Ø§ Ú©Ù…ÛŒ ØªÙ…Ø§ÛŒÙ„ Ø¨Ù‡ Ø®Ø§Ú©Ø³ØªØ±ÛŒ
                        : undefined,
                    }}
                  />
                  </Box>
                </IconButton>
              </Stack>

            </Stack>
          </Stack>
        </CardContent>
        </Card>
      )}

      {/* Canvas */}
      <Box
        ref={containerRef}
        sx={{
          width: '100%',
          maxWidth: '100%', // ğŸ”§ FIX: Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ Ø¹Ø±Ø¶ Ø¨ÛŒØ´ Ø§Ø² 100% Ù†Ø´ÙˆØ¯
          minWidth: 0, // ğŸ”§ FIX: Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ú©Ù‡ container Ú©ÙˆÚ†Ú© Ø´ÙˆØ¯
          height: isImageLoaded ? containerHeight : 'auto',
          bgcolor: 'transparent',
          borderRadius: { xs: 2, sm: 2 }, // border radius Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ùˆ Ø¯Ø³Ú©ØªØ§Ù¾
          overflow: 'hidden',
          position: 'relative',
          display: 'block', // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² block display Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
          boxSizing: 'border-box', // ğŸ”§ FIX: Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ padding Ø¯Ø± Ø¹Ø±Ø¶ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´ÙˆØ¯
        }}
        // Zoom with mouse wheel disabled
        // onWheel={(e) => {
        //   e.preventDefault();
        //   e.stopPropagation();
        //   handleWheel(e);
        // }}
      >
        <canvas
          id="cephalometric-canvas"
          ref={canvasRef}
          onClick={handleCanvasClick}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
          // Zoom with mouse wheel disabled
          // onWheel={handleWheel}
          onContextMenu={handleContextMenu}
          style={{
            width: '100%',
            height: '100%',
            cursor: 'default', // Ù‡Ù…ÛŒØ´Ù‡ default
            borderRadius: 'inherit', // Ø§Ø±Ø«â€ŒØ¨Ø±ÛŒ Ø§Ø² container
            display: 'block', // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ÙØ¶Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
            maxWidth: '100%', // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overflow Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
            maxHeight: '100%', // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² overflow Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„
          }}
        />
        
        {/* Tooltip Ø­Ø°Ù Ø´Ø¯Ù‡ - Ø¯ÛŒÚ¯Ø± Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ */}
      </Box>

      {/* Traced Structures */}
      {tracingStructures.length > 0 && (
        <Card>
          <CardContent>
            <Typography variant="h6" sx={{ mb: 1 }}>
              ğŸ¨ Ø³Ø§Ø®ØªØ§Ø±Ù‡Ø§ÛŒ ØªØ±Ø³ÛŒÙ… Ø´Ø¯Ù‡
            </Typography>
            <Stack spacing={1}>
              {tracingStructures.map((structure, index) => (
                <Box
                  key={index}
                  sx={{
                    p: 1,
                    borderRadius: 1,
                    bgcolor: 'background.neutral',
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                  }}
                >
                  <Stack direction="row" spacing={1} alignItems="center">
                    <Box
                      sx={{
                        width: 20,
                        height: 20,
                        bgcolor: structure.color,
                        borderRadius: 0.5,
                      }}
                    />
                    <Typography variant="body2">{structure.name}</Typography>
                    <Typography variant="caption" color="text.secondary">
                      ({structure.points.length} Ù†Ù‚Ø·Ù‡)
                    </Typography>
                  </Stack>
                  <IconButton
                    size="small"
                    onClick={() => {
                      setTracingStructures(tracingStructures.filter((_, i) => i !== index));
                    }}
                  >
                    <Iconify icon="solar:trash-bin-trash-bold" />
                  </IconButton>
                </Box>
              ))}
            </Stack>
          </CardContent>
        </Card>
      )}

      {/* Instructions removed per user request */}

      {/* Context Menu */}
      <Menu
        open={contextMenu !== null}
        onClose={handleCloseContextMenu}
        anchorReference="anchorPosition"
        anchorPosition={
          contextMenu !== null
            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
            : undefined
        }
        PaperProps={{
          sx: { 
            minWidth: 180,
          }
        }}
      >
        {/* 6 Ø±Ù†Ú¯ Ø³Ø±ÛŒØ¹ */}
        <Box sx={{ px: 2, py: 1 }}>
          <Typography variant="caption" sx={{ color: 'text.secondary', display: 'block', mb: 1 }}>
            Ø§Ù†ØªØ®Ø§Ø¨ Ø±Ù†Ú¯ {contextMenu?.landmark}:
          </Typography>
          <ColorPicker
            colors={QUICK_COLORS}
            selected={landmarkColors[contextMenu?.landmark] || landmarkColors.default}
            onSelectColor={handleSelectLandmarkColor}
          />
        </Box>
        
        <Divider sx={{ my: 1 }} />
        
        <MenuItem onClick={handleDeleteLandmark} sx={{ color: 'inherit' }}>
          <Iconify icon="solar:trash-bin-trash-bold" sx={{ mr: 1, color: 'inherit' }} />
          Ø­Ø°Ù {contextMenu?.landmark}
        </MenuItem>
      </Menu>

      {/* Line Style Menu */}
      <Menu
        open={Boolean(lineStyleAnchor)}
        anchorEl={lineStyleAnchor}
        onClose={() => setLineStyleAnchor(null)}
        PaperProps={{
          sx: { 
            minWidth: 150,
          }
        }}
      >
        <MenuItem 
          onClick={() => {
            setLineStyle('solid');
            setLineStyleAnchor(null);
          }}
          selected={lineStyle === 'solid'}
        >
          <Iconify icon="material-symbols:line-style" sx={{ mr: 1 }} />
          Ø®Ø· ØªÙˆÙ¾Ø±
        </MenuItem>
        <MenuItem 
          onClick={() => {
            setLineStyle('dashed');
            setLineStyleAnchor(null);
          }}
          selected={lineStyle === 'dashed'}
        >
          <Iconify icon="ph:minus-bold" sx={{ mr: 1 }} />
          Ø®Ø· Ú†ÛŒÙ†
        </MenuItem>
        <MenuItem 
          onClick={() => {
            setLineStyle('dotted');
            setLineStyleAnchor(null);
          }}
          selected={lineStyle === 'dotted'}
        >
          <Iconify icon="bi:three-dots" sx={{ mr: 1 }} />
          Ù†Ù‚Ø·Ù‡ Ú†ÛŒÙ†
        </MenuItem>
      </Menu>

      {/* Line Color Popover - 20 Ø±Ù†Ú¯ */}
      <Popover
        open={Boolean(lineColorAnchor)}
        anchorEl={lineColorAnchor}
        onClose={() => setLineColorAnchor(null)}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'left',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'left',
        }}
      >
        <Box sx={{ p: 1.5 }}>
          <Typography variant="caption" sx={{ mb: 1, display: 'block' }}>
            Ø§Ù†ØªØ®Ø§Ø¨ Ø±Ù†Ú¯ Ù†Ù‚Ø·Ù‡ {selectedLandmark ? `(${selectedLandmark})` : ''}
          </Typography>
          <Box
            sx={{
              display: 'grid',
              gridTemplateColumns: 'repeat(4, 1fr)',
              gap: 1,
              width: 160,
              justifyItems: 'center',
            }}
          >
            {ALL_COLORS.map((color) => (
              <IconButton
                key={color}
                onClick={() => {
                  if (selectedLandmark) {
                    setLandmarkColors({
                      ...landmarkColors,
                      [selectedLandmark]: color
                    });
                  }
                  setLineColorAnchor(null);
                }}
                disabled={!selectedLandmark}
                sx={{
                  width: 24,
                  height: 24,
                  minWidth: 24,
                  minHeight: 24,
                  padding: 0,
                  bgcolor: color,
                  border: '1px solid',
                  borderColor: 'divider',
                  opacity: selectedLandmark ? 1 : 0.5,
                  '&:hover': {
                    bgcolor: color,
                    opacity: selectedLandmark ? 0.8 : 0.5,
                  }
                }}
              />
            ))}
          </Box>
        </Box>
      </Popover>

      {/* Add Landmark Modal */}
      <Dialog
        open={isAddModalOpen}
        onClose={() => {
          setIsAddModalOpen(false);
          setNewLandmarkNameModal('');
          setPendingLandmarkCoords(null);
        }}
        maxWidth="xs"
        fullWidth
      >
        <DialogTitle>Ø§ÙØ²ÙˆØ¯Ù† Ù†Ù‚Ø·Ù‡ Ø¬Ø¯ÛŒØ¯</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            fullWidth
            label="Ù†Ø§Ù… Ù†Ù‚Ø·Ù‡"
            placeholder="Ù…Ø«Ù„Ø§Ù‹: M1, Landmark1, ..."
            value={newLandmarkNameModal}
            onChange={(e) => setNewLandmarkNameModal(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && newLandmarkNameModal) {
                handleConfirmAddLandmark();
              }
            }}
            sx={{ mt: 2 }}
          />
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => {
              setIsAddModalOpen(false);
              setNewLandmarkNameModal('');
              setPendingLandmarkCoords(null);
            }}
          >
            Ù„ØºÙˆ
          </Button>
          <Button 
            onClick={handleConfirmAddLandmark}
            variant="contained"
            disabled={!newLandmarkNameModal}
          >
            ØªØ§ÛŒÛŒØ¯
          </Button>
        </DialogActions>
      </Dialog>

    </Stack>

      {/* Landmark Tooltip Snackbar - Using Portal for fixed positioning */}
      <Portal>
        <Snackbar
          key={landmarkSnackbarContent || 'empty'}
          open={landmarkSnackbarOpen}
          autoHideDuration={null}
        onClose={() => {
          setLandmarkSnackbarOpen(false);
          // Ù…Ø­ØªÙˆØ§ Ø±Ø§ ØªØ§ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø®Ø±ÙˆØ¬ Ú©Ø§Ù…Ù„ Ù†Ø´Ø¯Ù‡ Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±ÛŒÙ…
        }}
        TransitionComponent={ZoomTransition}
        TransitionProps={{
          timeout: {
            enter: 300,
            exit: 300,
          },
          onExited: () => {
            // Ø¨Ø¹Ø¯ Ø§Ø² Ú©Ø§Ù…Ù„ Ø´Ø¯Ù† Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø®Ø±ÙˆØ¬ØŒ Ù…Ø­ØªÙˆØ§ Ø±Ø§ Ù¾Ø§Ú© Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
            setLandmarkSnackbarContent(null);
            setLandmarkSnackbarDisplayContent(null);
          },
        }}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'center',
        }}
        sx={{
          position: 'fixed',
          bottom: isMobile ? '16px' : '24px',
          left: '50%',
          transform: 'translateX(-50%)',
          zIndex: 9999,
          ...(isMobile && {
            maxWidth: '90vw',
            width: '90vw',
          }),
        }}
        message={
          landmarkSnackbarDisplayContent && LANDMARK_DESCRIPTIONS[landmarkSnackbarDisplayContent] ? (
            <Box sx={{ py: 0.5, minHeight: '60px' }}>
              <Typography variant="subtitle2" sx={{ fontWeight: 'bold', mb: 0.5 }}>
                {LANDMARK_DESCRIPTIONS[landmarkSnackbarDisplayContent].name}
              </Typography>
              <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                {LANDMARK_DESCRIPTIONS[landmarkSnackbarDisplayContent].description}
              </Typography>
            </Box>
          ) : (
            <Box sx={{ minHeight: '60px' }} />
          )
        }
        ContentProps={{
          sx: {
            maxWidth: isMobile ? '90vw' : 400,
            width: isMobile ? '90vw' : 'auto',
            minHeight: '60px',
            bgcolor: 'background.paper',
            color: 'text.primary',
            boxShadow: (theme) => theme.customShadows.z8,
            whiteSpace: 'pre-wrap',
            // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù‡Ù…Ø§Ù† Ø§Ø³ØªØ§ÛŒÙ„ popover
            borderRadius: 1,
          }
        }}
      />
    </Portal>
    </>
  );
}

AdvancedCephalometricVisualizer.propTypes = {
  imageUrl: PropTypes.string.isRequired,
  landmarks: PropTypes.object,
  imageSize: PropTypes.shape({
    width: PropTypes.number,
    height: PropTypes.number,
  }),
  onLandmarksChange: PropTypes.func,
  showMeasurements: PropTypes.bool,
  showCoordinateSystem: PropTypes.bool, // Ù†Ù…Ø§ÛŒØ´ Ù…Ø­ÙˆØ± Ù…Ø®ØªØµØ§Øª
  readOnly: PropTypes.bool, // Ø§Ú¯Ø± true Ø¨Ø§Ø´Ø¯ØŒ ÙˆÛŒØ±Ø§ÛŒØ´ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª
};

